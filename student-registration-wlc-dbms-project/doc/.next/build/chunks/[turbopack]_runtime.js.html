<!DOCTYPE html>
<html>
<head>
  <title>[turbopack]_runtime.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = ".next/build/chunks/[turbopack]_runtime.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#sourcemappingurl5bturbopack5d_runtime.js.map">sourceMappingURL=%5Bturbopack%5D_runtime.js.map</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>[turbopack]_runtime.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">const</span> RUNTIME_PUBLIC_PATH = <span class="hljs-string">"chunks/[turbopack]_runtime.js"</span>;
<span class="hljs-keyword">const</span> RELATIVE_ROOT_PATH = <span class="hljs-string">".."</span>;
<span class="hljs-keyword">const</span> ASSET_PREFIX = <span class="hljs-string">"/"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>This file contains runtime types and functions that are shared between all
TurboPack ECMAScript runtimes.</p>
</div>
<div class="body">
<p>It will be prepended to the runtime code of each runtime.
/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path="./runtime-types.d.ts" /></p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">const</span> REEXPORTED_OBJECTS = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>Constructs the <code>__turbopack_context__</code> object for a module.
function Context(module, exports) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.m = <span class="hljs-built_in">module</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>We need to store this here instead of accessing it from the module object to:</p>
<ol>
<li>Make it available to factories directly, since we rewrite <code>this</code> to
<code>__turbopack_context__.e</code> in CJS modules.</li>
<li>Support async modules which rewrite <code>module.exports</code> to a promise, so we
can still access the original exports object from functions like
<code>esmExport</code>
Ideally we could find a new approach for async modules and drop this property altogether.</li>
</ol>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.e = exports;
}
<span class="hljs-keyword">const</span> contextPrototype = Context.prototype;
<span class="hljs-keyword">const</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
<span class="hljs-keyword">const</span> toStringTag = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.toStringTag;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineProp</span>(<span class="hljs-params">obj, name, options</span>) </span>{
    <span class="hljs-keyword">if</span> (!hasOwnProperty.call(obj, name)) <span class="hljs-built_in">Object</span>.defineProperty(obj, name, options);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOverwrittenModule</span>(<span class="hljs-params">moduleCache, id</span>) </span>{
    <span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span> = moduleCache[id];
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">module</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>This is invoked when a module is merged into another module, thus it wasn't invoked via
instantiateModule and the cache entry wasn't created yet.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-built_in">module</span> = createModuleObject(id);
        moduleCache[id] = <span class="hljs-built_in">module</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates the module object. Only done here to ensure all module objects have the same shape.
function createModuleObject(id) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">exports</span>: {},
        <span class="hljs-attr">error</span>: <span class="hljs-literal">undefined</span>,
        id,
        <span class="hljs-attr">namespaceObject</span>: <span class="hljs-literal">undefined</span>
    };
}
<span class="hljs-keyword">const</span> BindingTag_Value = <span class="hljs-number">0</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<div class="dox">
<div class="summary">
<p>Adds the getters to the exports object.
function esm(exports, bindings) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    defineProp(exports, <span class="hljs-string">'__esModule'</span>, {
        <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>
    });
    <span class="hljs-keyword">if</span> (toStringTag) defineProp(exports, toStringTag, {
        <span class="hljs-attr">value</span>: <span class="hljs-string">'Module'</span>
    });
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(i &lt; bindings.length){
        <span class="hljs-keyword">const</span> propName = bindings[i++];
        <span class="hljs-keyword">const</span> tagOrFunction = bindings[i++];
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tagOrFunction === <span class="hljs-string">'number'</span>) {
            <span class="hljs-keyword">if</span> (tagOrFunction === BindingTag_Value) {
                defineProp(exports, propName, {
                    <span class="hljs-attr">value</span>: bindings[i++],
                    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
                    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
                });
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`unexpected tag: <span class="hljs-subst">${tagOrFunction}</span>`</span>);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">const</span> getterFn = tagOrFunction;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> bindings[i] === <span class="hljs-string">'function'</span>) {
                <span class="hljs-keyword">const</span> setterFn = bindings[i++];
                defineProp(exports, propName, {
                    <span class="hljs-attr">get</span>: getterFn,
                    <span class="hljs-attr">set</span>: setterFn,
                    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
                });
            } <span class="hljs-keyword">else</span> {
                defineProp(exports, propName, {
                    <span class="hljs-attr">get</span>: getterFn,
                    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
                });
            }
        }
    }
    <span class="hljs-built_in">Object</span>.seal(exports);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<div class="dox">
<div class="summary">
<p>Makes the module an ESM with exports
function esmExport(bindings, id) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span>;
    <span class="hljs-keyword">let</span> exports;
    <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) {
        <span class="hljs-built_in">module</span> = getOverwrittenModule(<span class="hljs-keyword">this</span>.c, id);
        exports = <span class="hljs-built_in">module</span>.exports;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.m;
        exports = <span class="hljs-keyword">this</span>.e;
    }
    <span class="hljs-built_in">module</span>.namespaceObject = exports;
    esm(exports, bindings);
}
contextPrototype.s = esmExport;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureDynamicExports</span>(<span class="hljs-params">module, exports</span>) </span>{
    <span class="hljs-keyword">let</span> reexportedObjects = REEXPORTED_OBJECTS.get(<span class="hljs-built_in">module</span>);
    <span class="hljs-keyword">if</span> (!reexportedObjects) {
        REEXPORTED_OBJECTS.set(<span class="hljs-built_in">module</span>, reexportedObjects = []);
        <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">module</span>.namespaceObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(exports, {
            <span class="hljs-keyword">get</span> (target, prop) {
                <span class="hljs-keyword">if</span> (hasOwnProperty.call(target, prop) || prop === <span class="hljs-string">'default'</span> || prop === <span class="hljs-string">'__esModule'</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop);
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> obj <span class="hljs-keyword">of</span> reexportedObjects){
                    <span class="hljs-keyword">const</span> value = <span class="hljs-built_in">Reflect</span>.get(obj, prop);
                    <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> value;
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            },
            ownKeys (target) {
                <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Reflect</span>.ownKeys(target);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> obj <span class="hljs-keyword">of</span> reexportedObjects){
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj)){
                        <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'default'</span> &amp;&amp; !keys.includes(key)) keys.push(key);
                    }
                }
                <span class="hljs-keyword">return</span> keys;
            }
        });
    }
    <span class="hljs-keyword">return</span> reexportedObjects;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<div class="dox">
<div class="summary">
<p>Dynamically exports properties from an object
function dynamicExport(object, id) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span>;
    <span class="hljs-keyword">let</span> exports;
    <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) {
        <span class="hljs-built_in">module</span> = getOverwrittenModule(<span class="hljs-keyword">this</span>.c, id);
        exports = <span class="hljs-built_in">module</span>.exports;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.m;
        exports = <span class="hljs-keyword">this</span>.e;
    }
    <span class="hljs-keyword">const</span> reexportedObjects = ensureDynamicExports(<span class="hljs-built_in">module</span>, exports);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> object === <span class="hljs-string">'object'</span> &amp;&amp; object !== <span class="hljs-literal">null</span>) {
        reexportedObjects.push(object);
    }
}
contextPrototype.j = dynamicExport;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportValue</span>(<span class="hljs-params">value, id</span>) </span>{
    <span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span>;
    <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) {
        <span class="hljs-built_in">module</span> = getOverwrittenModule(<span class="hljs-keyword">this</span>.c, id);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.m;
    }
    <span class="hljs-built_in">module</span>.exports = value;
}
contextPrototype.v = exportValue;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportNamespace</span>(<span class="hljs-params">namespace, id</span>) </span>{
    <span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span>;
    <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) {
        <span class="hljs-built_in">module</span> = getOverwrittenModule(<span class="hljs-keyword">this</span>.c, id);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.m;
    }
    <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">module</span>.namespaceObject = namespace;
}
contextPrototype.n = exportNamespace;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGetter</span>(<span class="hljs-params">obj, key</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>obj[key];
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-comment">/** Prototypes that are not expanded for exports */</span> <span class="hljs-keyword">const</span> LEAF_PROTOTYPES = [
    <span class="hljs-literal">null</span>,
    getProto({}),
    getProto([]),
    getProto(getProto)
];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">raw</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">ns</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">allowExportDefault</span>
<span><ul>
<li><code>false</code>: will have the raw module as default export
<ul>
<li><code>true</code>: will have the default property as default export
function interopEsm(raw, ns, allowExportDefault) {</li>
</ul>
</li>
</ul>
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">const</span> bindings = [];
    <span class="hljs-keyword">let</span> defaultLocation = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> current = raw; (<span class="hljs-keyword">typeof</span> current === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> current === <span class="hljs-string">'function'</span>) &amp;&amp; !LEAF_PROTOTYPES.includes(current); current = getProto(current)){
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(current)){
            bindings.push(key, createGetter(raw, key));
            <span class="hljs-keyword">if</span> (defaultLocation === <span class="hljs-number">-1</span> &amp;&amp; key === <span class="hljs-string">'default'</span>) {
                defaultLocation = bindings.length - <span class="hljs-number">1</span>;
            }
        }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>this is not really correct
we should set the <code>default</code> getter if the imported module is a <code>.cjs file</code></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!(allowExportDefault &amp;&amp; defaultLocation &gt;= <span class="hljs-number">0</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Replace the binding with one for the namespace itself in order to preserve iteration order.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (defaultLocation &gt;= <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Replace the getter with the value</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            bindings.splice(defaultLocation, <span class="hljs-number">1</span>, BindingTag_Value, raw);
        } <span class="hljs-keyword">else</span> {
            bindings.push(<span class="hljs-string">'default'</span>, BindingTag_Value, raw);
        }
    }
    esm(ns, bindings);
    <span class="hljs-keyword">return</span> ns;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNS</span>(<span class="hljs-params">raw</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> raw === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
            <span class="hljs-keyword">return</span> raw.apply(<span class="hljs-keyword">this</span>, args);
        };
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
    }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">esmImport</span>(<span class="hljs-params">id</span>) </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = getOrInstantiateModuleFromParent(id, <span class="hljs-keyword">this</span>.m);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>any ES module has to have <code>module.namespaceObject</code> defined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.namespaceObject) <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.namespaceObject;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>only ESM can be an async module, so we don't need to worry about exports being a promise here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">const</span> raw = <span class="hljs-built_in">module</span>.exports;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.namespaceObject = interopEsm(raw, createNS(raw), raw &amp;&amp; raw.__esModule);
}
contextPrototype.i = esmImport;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncLoader</span>(<span class="hljs-params">moduleId</span>) </span>{
    <span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">this</span>.r(moduleId);
    <span class="hljs-keyword">return</span> loader(esmImport.bind(<span class="hljs-keyword">this</span>));
}
contextPrototype.A = asyncLoader;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Add a simple runtime require so that environments without one can still pass
<code>typeof require</code> CommonJS checks so that exports are correctly registered.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">const</span> runtimeRequire = <span class="hljs-comment">// @ts-ignore</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> === <span class="hljs-string">'function'</span> ? <span class="hljs-built_in">require</span> : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require1</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unexpected use of runtime require'</span>);
};
contextPrototype.t = runtimeRequire;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonJsRequire</span>(<span class="hljs-params">id</span>) </span>{
    <span class="hljs-keyword">return</span> getOrInstantiateModuleFromParent(id, <span class="hljs-keyword">this</span>.m).exports;
}
contextPrototype.r = commonJsRequire;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<div class="dox">
<div class="summary">
<p><code>require.context</code> and require/import expression runtime.
function moduleContext(map) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moduleContext</span>(<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(map, id)) {
            <span class="hljs-keyword">return</span> map[id].module();
        }
        <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Cannot find module '<span class="hljs-subst">${id}</span>'`</span>);
        e.code = <span class="hljs-string">'MODULE_NOT_FOUND'</span>;
        <span class="hljs-keyword">throw</span> e;
    }
    moduleContext.keys = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(map);
    };
    moduleContext.resolve = <span class="hljs-function">(<span class="hljs-params">id</span>)=&gt;</span>{
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(map, id)) {
            <span class="hljs-keyword">return</span> map[id].id();
        }
        <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Cannot find module '<span class="hljs-subst">${id}</span>'`</span>);
        e.code = <span class="hljs-string">'MODULE_NOT_FOUND'</span>;
        <span class="hljs-keyword">throw</span> e;
    };
    moduleContext.import = <span class="hljs-keyword">async</span> (id)=&gt;{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> moduleContext(id);
    };
    <span class="hljs-keyword">return</span> moduleContext;
}
contextPrototype.f = moduleContext;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the path of a chunk defined by its data.
function getChunkPath(chunkData) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> chunkData === <span class="hljs-string">'string'</span> ? chunkData : chunkData.path;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPromise</span>(<span class="hljs-params">maybePromise</span>) </span>{
    <span class="hljs-keyword">return</span> maybePromise != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> maybePromise === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-string">'then'</span> <span class="hljs-keyword">in</span> maybePromise &amp;&amp; <span class="hljs-keyword">typeof</span> maybePromise.then === <span class="hljs-string">'function'</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAsyncModuleExt</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> turbopackQueues <span class="hljs-keyword">in</span> obj;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPromise</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> resolve;
    <span class="hljs-keyword">let</span> reject;
    <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>)=&gt;</span>{
        reject = rej;
        resolve = res;
    });
    <span class="hljs-keyword">return</span> {
        promise,
        <span class="hljs-attr">resolve</span>: resolve,
        <span class="hljs-attr">reject</span>: reject
    };
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Load the CompressedmoduleFactories of a chunk into the <code>moduleFactories</code> Map.
The CompressedModuleFactories format is</p>
<ul>
<li>1 or more module ids</li>
<li>a module factory function
So walking this is a little complex but the flat structure is also fast to
traverse, we can use <code>typeof</code> operators to distinguish the two cases.</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">installCompressedModuleFactories</span>(<span class="hljs-params">chunkModules, offset, moduleFactories, newModuleId</span>) </span>{
    <span class="hljs-keyword">let</span> i = offset;
    <span class="hljs-keyword">while</span>(i &lt; chunkModules.length){
        <span class="hljs-keyword">let</span> moduleId = chunkModules[i];
        <span class="hljs-keyword">let</span> end = i + <span class="hljs-number">1</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>Find our factory function</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">while</span>(end &lt; chunkModules.length &amp;&amp; <span class="hljs-keyword">typeof</span> chunkModules[end] !== <span class="hljs-string">'function'</span>){
            end++;
        }
        <span class="hljs-keyword">if</span> (end === chunkModules.length) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'malformed chunk format, expected a factory function'</span>);
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>Each chunk item has a 'primary id' and optional additional ids. If the primary id is already
present we know all the additional ids are also present, so we don't need to check.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!moduleFactories.has(moduleId)) {
            <span class="hljs-keyword">const</span> moduleFactoryFn = chunkModules[end];
            applyModuleFactoryName(moduleFactoryFn);
            newModuleId?.(moduleId);
            <span class="hljs-keyword">for</span>(; i &lt; end; i++){
                moduleId = chunkModules[i];
                moduleFactories.set(moduleId, moduleFactoryFn);
            }
        }
        i = end + <span class="hljs-number">1</span>; <span class="hljs-comment">// end is pointing at the last factory advance to the next id or the end of the array.</span>
    }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>everything below is adapted from webpack
https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">const</span> turbopackQueues = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'turbopack queues'</span>);
<span class="hljs-keyword">const</span> turbopackExports = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'turbopack exports'</span>);
<span class="hljs-keyword">const</span> turbopackError = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'turbopack error'</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveQueue</span>(<span class="hljs-params">queue</span>) </span>{
    <span class="hljs-keyword">if</span> (queue &amp;&amp; queue.status !== <span class="hljs-number">1</span>) {
        queue.status = <span class="hljs-number">1</span>;
        queue.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>)=&gt;</span>fn.queueCount--);
        queue.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>)=&gt;</span>fn.queueCount-- ? fn.queueCount++ : fn());
    }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapDeps</span>(<span class="hljs-params">deps</span>) </span>{
    <span class="hljs-keyword">return</span> deps.map(<span class="hljs-function">(<span class="hljs-params">dep</span>)=&gt;</span>{
        <span class="hljs-keyword">if</span> (dep !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> dep === <span class="hljs-string">'object'</span>) {
            <span class="hljs-keyword">if</span> (isAsyncModuleExt(dep)) <span class="hljs-keyword">return</span> dep;
            <span class="hljs-keyword">if</span> (isPromise(dep)) {
                <span class="hljs-keyword">const</span> queue = <span class="hljs-built_in">Object</span>.assign([], {
                    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>
                });
                <span class="hljs-keyword">const</span> obj = {
                    [turbopackExports]: {},
                    [turbopackQueues]: <span class="hljs-function">(<span class="hljs-params">fn</span>)=&gt;</span>fn(queue)
                };
                dep.then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>{
                    obj[turbopackExports] = res;
                    resolveQueue(queue);
                }, (err)=&gt;{
                    obj[turbopackError] = err;
                    resolveQueue(queue);
                });
                <span class="hljs-keyword">return</span> obj;
            }
        }
        <span class="hljs-keyword">return</span> {
            [turbopackExports]: dep,
            [turbopackQueues]: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{}
        };
    });
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncModule</span>(<span class="hljs-params">body, hasAwait</span>) </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.m;
    <span class="hljs-keyword">const</span> queue = hasAwait ? <span class="hljs-built_in">Object</span>.assign([], {
        <span class="hljs-attr">status</span>: <span class="hljs-number">-1</span>
    }) : <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">const</span> depQueues = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> { resolve, reject, <span class="hljs-attr">promise</span>: rawPromise } = createPromise();
    <span class="hljs-keyword">const</span> promise = <span class="hljs-built_in">Object</span>.assign(rawPromise, {
        [turbopackExports]: <span class="hljs-built_in">module</span>.exports,
        [turbopackQueues]: <span class="hljs-function">(<span class="hljs-params">fn</span>)=&gt;</span>{
            queue &amp;&amp; fn(queue);
            depQueues.forEach(fn);
            promise[<span class="hljs-string">'catch'</span>](<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{});
        }
    });
    <span class="hljs-keyword">const</span> attributes = {
        <span class="hljs-keyword">get</span> () {
            <span class="hljs-keyword">return</span> promise;
        },
        <span class="hljs-keyword">set</span> (v) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>Calling <code>esmExport</code> leads to this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (v !== promise) {
                promise[turbopackExports] = v;
            }
        }
    };
    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">module</span>, <span class="hljs-string">'exports'</span>, attributes);
    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">module</span>, <span class="hljs-string">'namespaceObject'</span>, attributes);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAsyncDependencies</span>(<span class="hljs-params">deps</span>) </span>{
        <span class="hljs-keyword">const</span> currentDeps = wrapDeps(deps);
        <span class="hljs-keyword">const</span> getResult = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>currentDeps.map(<span class="hljs-function">(<span class="hljs-params">d</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (d[turbopackError]) <span class="hljs-keyword">throw</span> d[turbopackError];
                <span class="hljs-keyword">return</span> d[turbopackExports];
            });
        <span class="hljs-keyword">const</span> { promise, resolve } = createPromise();
        <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Object</span>.assign(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>resolve(getResult), {
            <span class="hljs-attr">queueCount</span>: <span class="hljs-number">0</span>
        });
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnQueue</span>(<span class="hljs-params">q</span>) </span>{
            <span class="hljs-keyword">if</span> (q !== queue &amp;&amp; !depQueues.has(q)) {
                depQueues.add(q);
                <span class="hljs-keyword">if</span> (q &amp;&amp; q.status === <span class="hljs-number">0</span>) {
                    fn.queueCount++;
                    q.push(fn);
                }
            }
        }
        currentDeps.map(<span class="hljs-function">(<span class="hljs-params">dep</span>)=&gt;</span>dep[turbopackQueues](fnQueue));
        <span class="hljs-keyword">return</span> fn.queueCount ? promise : getResult();
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncResult</span>(<span class="hljs-params">err</span>) </span>{
        <span class="hljs-keyword">if</span> (err) {
            reject(promise[turbopackError] = err);
        } <span class="hljs-keyword">else</span> {
            resolve(promise[turbopackExports]);
        }
        resolveQueue(queue);
    }
    body(handleAsyncDependencies, asyncResult);
    <span class="hljs-keyword">if</span> (queue &amp;&amp; queue.status === <span class="hljs-number">-1</span>) {
        queue.status = <span class="hljs-number">0</span>;
    }
}
contextPrototype.a = asyncModule;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<div class="dox">
<div class="summary">
<p>A pseudo &quot;fake&quot; URL object to resolve to its relative path.</p>
</div>
<div class="body">
<p>When UrlRewriteBehavior is set to relative, calls to the <code>new URL()</code> will construct url without base using this
runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid
hydration mismatch.</p>
<p>This is based on webpack's existing implementation:
https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js
const relativeURL = function relativeURL(inputUrl) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">const</span> realUrl = <span class="hljs-keyword">new</span> URL(inputUrl, <span class="hljs-string">'x:/'</span>);
    <span class="hljs-keyword">const</span> values = {};
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> realUrl)values[key] = realUrl[key];
    values.href = inputUrl;
    values.pathname = inputUrl.replace(<span class="hljs-regexp">/[?#].*/</span>, <span class="hljs-string">''</span>);
    values.origin = values.protocol = <span class="hljs-string">''</span>;
    values.toString = values.toJSON = <span class="hljs-function">(<span class="hljs-params">..._args</span>)=&gt;</span>inputUrl;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> values)<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, key, {
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">value</span>: values[key]
    });
};
relativeURL.prototype = URL.prototype;
contextPrototype.U = relativeURL;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<div class="dox">
<div class="summary">
<p>Utility function to ensure all variants of an enum are handled.
function invariant(never, computeMessage) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invariant: <span class="hljs-subst">${computeMessage(never)}</span>`</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<div class="dox">
<div class="summary">
<p>A stub function to make <code>require</code> available but non-functional in ESM.
function requireStub(_moduleId) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'dynamic usage of require is not supported'</span>);
}
contextPrototype.z = requireStub;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>Make <code>globalThis</code> available to the module in a way that cannot be shadowed by a local variable.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">contextPrototype.g = globalThis;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyModuleFactoryName</span>(<span class="hljs-params">factory</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Give the module factory a nice name to improve stack traces.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-built_in">Object</span>.defineProperty(factory, <span class="hljs-string">'name'</span>, {
        <span class="hljs-attr">value</span>: <span class="hljs-string">'module evaluation'</span>
    });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>/ <reference path="../shared/runtime-utils.ts" />
/ A 'base' utilities to support runtime can have externals.
/ Currently this is for node.js / edge runtime both.
/ If a fn requires node.js specific behavior, it should be placed in <code>node-external-utils</code> instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">externalImport</span>(<span class="hljs-params">id</span>) </span>{
    <span class="hljs-keyword">let</span> raw;
    <span class="hljs-keyword">try</span> {
        raw = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(id);
    } <span class="hljs-keyword">catch</span> (err) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>TODO(alexkirsz) This can happen when a client-side module tries to load
an external module we don't provide a shim for (e.g. querystring, url).
For now, we fail semi-silently, but in the future this should be a
compilation error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Failed to load external module <span class="hljs-subst">${id}</span>: <span class="hljs-subst">${err}</span>`</span>);
    }
    <span class="hljs-keyword">if</span> (raw &amp;&amp; raw.__esModule &amp;&amp; raw.default &amp;&amp; <span class="hljs-string">'default'</span> <span class="hljs-keyword">in</span> raw.default) {
        <span class="hljs-keyword">return</span> interopEsm(raw.default, createNS(raw), <span class="hljs-literal">true</span>);
    }
    <span class="hljs-keyword">return</span> raw;
}
contextPrototype.y = externalImport;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">externalRequire</span>(<span class="hljs-params">id, thunk, esm = false</span>) </span>{
    <span class="hljs-keyword">let</span> raw;
    <span class="hljs-keyword">try</span> {
        raw = thunk();
    } <span class="hljs-keyword">catch</span> (err) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>TODO(alexkirsz) This can happen when a client-side module tries to load
an external module we don't provide a shim for (e.g. querystring, url).
For now, we fail semi-silently, but in the future this should be a
compilation error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Failed to load external module <span class="hljs-subst">${id}</span>: <span class="hljs-subst">${err}</span>`</span>);
    }
    <span class="hljs-keyword">if</span> (!esm || raw.__esModule) {
        <span class="hljs-keyword">return</span> raw;
    }
    <span class="hljs-keyword">return</span> interopEsm(raw, createNS(raw), <span class="hljs-literal">true</span>);
}
externalRequire.resolve = <span class="hljs-function">(<span class="hljs-params">id, options</span>)=&gt;</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>.resolve(id, options);
};
contextPrototype.x = externalRequire;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<div class="dox">
<div class="summary">
<p>eslint-disable @typescript-eslint/no-unused-vars    const path = require('path');
const relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.');
// Compute the relative path to the <code>distDir</code>.
const relativePathToDistRoot = path.join(relativePathToRuntimeRoot, RELATIVE_ROOT_PATH);
const RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot);
// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.
const ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot);
/**
Returns an absolute path to the given module path.
Module path should be relative, either path to a file or a directory.</p>
</div>
<div class="body">
<p>This fn allows to calculate an absolute path for some global static values, such as
<code>__dirname</code> or <code>import.meta.url</code> that Turbopack will not embeds in compile time.
See ImportMetaBinding::code_generation for the usage.
/ function resolveAbsolutePath(modulePath) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (modulePath) {
        <span class="hljs-keyword">return</span> path.join(ABSOLUTE_ROOT, modulePath);
    }
    <span class="hljs-keyword">return</span> ABSOLUTE_ROOT;
}
Context.prototype.P = resolveAbsolutePath;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<div class="dox">
<div class="summary">
<p>eslint-disable @typescript-eslint/no-unused-vars    /// <reference path="../shared/runtime-utils.ts" />
function readWebAssemblyAsResponse(path) {
const { createReadStream } = require('fs');
const { Readable } = require('stream');
const stream = createReadStream(path);
// @ts-ignore unfortunately there's a slight type mismatch with the stream.
return new Response(Readable.toWeb(stream), {
headers: {
'content-type': 'application/wasm'
}
});
}
async function compileWebAssemblyFromPath(path) {
const response = readWebAssemblyAsResponse(path);
return await WebAssembly.compileStreaming(response);
}
async function instantiateWebAssemblyFromPath(path, importsObj) {
const response = readWebAssemblyAsResponse(path);
const { instance } = await WebAssembly.instantiateStreaming(response, importsObj);
return instance.exports;
}
/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path="../shared/runtime-utils.ts" /></p>
</div>
<div class="body">
</div>
</div>
/ <reference path="../shared-node/base-externals-utils.ts" />
/ <reference path="../shared-node/node-externals-utils.ts" />
/ <reference path="../shared-node/node-wasm-utils.ts" />

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> SourceType = <span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">SourceType</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<div class="dox">
<div class="summary">
<p>The module was instantiated because it was included in an evaluated chunk's
runtime.
SourceData is a ChunkPath.
SourceType[SourceType[&quot;Runtime&quot;] = 0] = &quot;Runtime&quot;;</p>
</div>
<div class="body">
</div>
</div>
<div class="dox">
<div class="summary">
<p>The module was instantiated because a parent module imported it.
SourceData is a ModuleId.
SourceType[SourceType[&quot;Parent&quot;] = 1] = &quot;Parent&quot;;</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> SourceType;
}(SourceType || {});
process.env.TURBOPACK = <span class="hljs-string">'1'</span>;
<span class="hljs-keyword">const</span> nodeContextPrototype = Context.prototype;
<span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
<span class="hljs-keyword">const</span> moduleFactories = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
nodeContextPrototype.M = moduleFactories;
<span class="hljs-keyword">const</span> moduleCache = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
nodeContextPrototype.c = moduleCache;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns an absolute path to the given module's id.
function resolvePathFromModule(moduleId) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">const</span> exported = <span class="hljs-keyword">this</span>.r(moduleId);
    <span class="hljs-keyword">const</span> exportedPath = exported?.default ?? exported;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exportedPath !== <span class="hljs-string">'string'</span>) {
        <span class="hljs-keyword">return</span> exported;
    }
    <span class="hljs-keyword">const</span> strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length);
    <span class="hljs-keyword">const</span> resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix);
    <span class="hljs-keyword">return</span> url.pathToFileURL(resolved).href;
}
nodeContextPrototype.R = resolvePathFromModule;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadRuntimeChunk</span>(<span class="hljs-params">sourcePath, chunkData</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> chunkData === <span class="hljs-string">'string'</span>) {
        loadRuntimeChunkPath(sourcePath, chunkData);
    } <span class="hljs-keyword">else</span> {
        loadRuntimeChunkPath(sourcePath, chunkData.path);
    }
}
<span class="hljs-keyword">const</span> loadedChunks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
<span class="hljs-keyword">const</span> unsupportedLoadChunk = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-literal">undefined</span>);
<span class="hljs-keyword">const</span> loadedChunk = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-literal">undefined</span>);
<span class="hljs-keyword">const</span> chunkCache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearChunkCache</span>(<span class="hljs-params"></span>) </span>{
    chunkCache.clear();
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadRuntimeChunkPath</span>(<span class="hljs-params">sourcePath, chunkPath</span>) </span>{
    <span class="hljs-keyword">if</span> (!isJs(chunkPath)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>We only support loading JS chunks in Node.js.
This branch can be hit when trying to load a CSS chunk.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (loadedChunks.has(chunkPath)) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> resolved = path.resolve(RUNTIME_ROOT, chunkPath);
        <span class="hljs-keyword">const</span> chunkModules = <span class="hljs-built_in">require</span>(resolved);
        installCompressedModuleFactories(chunkModules, <span class="hljs-number">0</span>, moduleFactories);
        loadedChunks.add(chunkPath);
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">let</span> errorMessage = <span class="hljs-string">`Failed to load chunk <span class="hljs-subst">${chunkPath}</span>`</span>;
        <span class="hljs-keyword">if</span> (sourcePath) {
            errorMessage += <span class="hljs-string">` from runtime for chunk <span class="hljs-subst">${sourcePath}</span>`</span>;
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(errorMessage, {
            <span class="hljs-attr">cause</span>: e
        });
    }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadChunkAsync</span>(<span class="hljs-params">chunkData</span>) </span>{
    <span class="hljs-keyword">const</span> chunkPath = <span class="hljs-keyword">typeof</span> chunkData === <span class="hljs-string">'string'</span> ? chunkData : chunkData.path;
    <span class="hljs-keyword">if</span> (!isJs(chunkPath)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>We only support loading JS chunks in Node.js.
This branch can be hit when trying to load a CSS chunk.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> unsupportedLoadChunk;
    }
    <span class="hljs-keyword">let</span> entry = chunkCache.get(chunkPath);
    <span class="hljs-keyword">if</span> (entry === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>resolve to an absolute path to simplify <code>require</code> handling</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">const</span> resolved = path.resolve(RUNTIME_ROOT, chunkPath);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>TODO: consider switching to <code>import()</code> to enable concurrent chunk loading and async file io
However this is incompatible with hot reloading (since <code>import</code> doesn't use the require cache)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">const</span> chunkModules = <span class="hljs-built_in">require</span>(resolved);
            installCompressedModuleFactories(chunkModules, <span class="hljs-number">0</span>, moduleFactories);
            entry = loadedChunk;
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">const</span> errorMessage = <span class="hljs-string">`Failed to load chunk <span class="hljs-subst">${chunkPath}</span> from module <span class="hljs-subst">${<span class="hljs-keyword">this</span>.m.id}</span>`</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>Cache the failure promise, future requests will also get this same rejection</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            entry = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(errorMessage, {
                <span class="hljs-attr">cause</span>: e
            }));
        }
        chunkCache.set(chunkPath, entry);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>TODO: Return an instrumented Promise that React can use instead of relying on referential equality.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> entry;
}
contextPrototype.l = loadChunkAsync;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadChunkAsyncByUrl</span>(<span class="hljs-params">chunkUrl</span>) </span>{
    <span class="hljs-keyword">const</span> path1 = url.fileURLToPath(<span class="hljs-keyword">new</span> URL(chunkUrl, RUNTIME_ROOT));
    <span class="hljs-keyword">return</span> loadChunkAsync.call(<span class="hljs-keyword">this</span>, path1);
}
contextPrototype.L = loadChunkAsyncByUrl;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadWebAssembly</span>(<span class="hljs-params">chunkPath, _edgeModule, imports</span>) </span>{
    <span class="hljs-keyword">const</span> resolved = path.resolve(RUNTIME_ROOT, chunkPath);
    <span class="hljs-keyword">return</span> instantiateWebAssemblyFromPath(resolved, imports);
}
contextPrototype.w = loadWebAssembly;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadWebAssemblyModule</span>(<span class="hljs-params">chunkPath, _edgeModule</span>) </span>{
    <span class="hljs-keyword">const</span> resolved = path.resolve(RUNTIME_ROOT, chunkPath);
    <span class="hljs-keyword">return</span> compileWebAssemblyFromPath(resolved);
}
contextPrototype.u = loadWebAssemblyModule;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWorkerBlobURL</span>(<span class="hljs-params">_chunks</span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Worker blobs are not implemented yet for Node.js'</span>);
}
nodeContextPrototype.b = getWorkerBlobURL;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instantiateModule</span>(<span class="hljs-params">id, sourceType, sourceData</span>) </span>{
    <span class="hljs-keyword">const</span> moduleFactory = moduleFactories.get(id);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> moduleFactory !== <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>This can happen if modules incorrectly handle HMR disposes/updates,
e.g. when they keep a <code>setTimeout</code> around which still executes old code
and contains e.g. a <code>require(&quot;something&quot;)</code> call.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">let</span> instantiationReason;
        <span class="hljs-keyword">switch</span>(sourceType){
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                instantiationReason = <span class="hljs-string">`as a runtime entry of chunk <span class="hljs-subst">${sourceData}</span>`</span>;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                instantiationReason = <span class="hljs-string">`because it was required from module <span class="hljs-subst">${sourceData}</span>`</span>;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                invariant(sourceType, (sourceType)=&gt;<span class="hljs-string">`Unknown source type: <span class="hljs-subst">${sourceType}</span>`</span>);
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Module <span class="hljs-subst">${id}</span> was instantiated <span class="hljs-subst">${instantiationReason}</span>, but the module factory is not available.`</span>);
    }
    <span class="hljs-keyword">const</span> module1 = createModuleObject(id);
    <span class="hljs-keyword">const</span> exports = module1.exports;
    moduleCache[id] = module1;
    <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> Context(module1, exports);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>NOTE(alexkirsz) This can fail when the module encounters a runtime error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">try</span> {
        moduleFactory(context, module1, exports);
    } <span class="hljs-keyword">catch</span> (error) {
        module1.error = error;
        <span class="hljs-keyword">throw</span> error;
    }
    module1.loaded = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (module1.namespaceObject &amp;&amp; module1.exports !== module1.namespaceObject) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<p>in case of a circular dependency: cjs1 -&gt; esm2 -&gt; cjs1</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        interopEsm(module1.exports, module1.namespaceObject);
    }
    <span class="hljs-keyword">return</span> module1;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<div class="dox">
<div class="summary">
<p>Retrieves a module from the cache, or instantiate it if it is not cached.
// @ts-ignore</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOrInstantiateModuleFromParent</span>(<span class="hljs-params">id, sourceModule</span>) </span>{
    <span class="hljs-keyword">const</span> module1 = moduleCache[id];
    <span class="hljs-keyword">if</span> (module1) {
        <span class="hljs-keyword">if</span> (module1.error) {
            <span class="hljs-keyword">throw</span> module1.error;
        }
        <span class="hljs-keyword">return</span> module1;
    }
    <span class="hljs-keyword">return</span> instantiateModule(id, <span class="hljs-number">1</span>, sourceModule.id);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<div class="dox">
<div class="summary">
<p>Instantiates a runtime module.
function instantiateRuntimeModule(chunkPath, moduleId) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> instantiateModule(moduleId, <span class="hljs-number">0</span>, chunkPath);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<div class="dox">
<div class="summary">
<p>Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.
// @ts-ignore TypeScript doesn't separate this module space from the browser runtime</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOrInstantiateRuntimeModule</span>(<span class="hljs-params">chunkPath, moduleId</span>) </span>{
    <span class="hljs-keyword">const</span> module1 = moduleCache[moduleId];
    <span class="hljs-keyword">if</span> (module1) {
        <span class="hljs-keyword">if</span> (module1.error) {
            <span class="hljs-keyword">throw</span> module1.error;
        }
        <span class="hljs-keyword">return</span> module1;
    }
    <span class="hljs-keyword">return</span> instantiateRuntimeModule(chunkPath, moduleId);
}
<span class="hljs-keyword">const</span> regexJsUrl = <span class="hljs-regexp">/\.js(?:\?[^#]*)?(?:#.*)?$/</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<div class="dox">
<div class="summary">
<p>Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.
function isJs(chunkUrlOrPath) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> regexJsUrl.test(chunkUrlOrPath);
}
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">sourcePath</span>)=&gt;</span>({
        <span class="hljs-attr">m</span>: <span class="hljs-function">(<span class="hljs-params">id</span>)=&gt;</span>getOrInstantiateRuntimeModule(sourcePath, id),
        <span class="hljs-attr">c</span>: <span class="hljs-function">(<span class="hljs-params">chunkData</span>)=&gt;</span>loadRuntimeChunk(sourcePath, chunkData)
    });


</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="sourcemappingurl5bturbopack5d_runtime.js.map">
  <h1>
    <a href="#sourcemappingurl5bturbopack5d_runtime.js.map" name="sourcemappingurl5bturbopack5d_runtime.js.map" class="pilcrow"></a>
sourceMappingURL=%5Bturbopack%5D_runtime.js.map
  </h1>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"></pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
