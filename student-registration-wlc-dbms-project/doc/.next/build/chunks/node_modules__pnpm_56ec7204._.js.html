<!DOCTYPE html>
<html>
<head>
  <title>node_modules__pnpm_56ec7204._.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = ".next/build/chunks/node_modules__pnpm_56ec7204._.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#sourcemappingurlnode_modules__pnpm_56ec7204._.js.map">sourceMappingURL=node_modules__pnpm_56ec7204._.js.map</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>node_modules__pnpm_56ec7204._.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-built_in">module</span>.exports = [
<span class="hljs-string">"[project]/node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-keyword">let</span> p = process || {}, argv = p.argv || [], env = p.env || {};
<span class="hljs-keyword">let</span> isColorSupported = !(!!env.NO_COLOR || argv.includes(<span class="hljs-string">"--no-color"</span>)) &amp;&amp; (!!env.FORCE_COLOR || argv.includes(<span class="hljs-string">"--color"</span>) || p.platform === <span class="hljs-string">"win32"</span> || (p.stdout || {}).isTTY &amp;&amp; env.TERM !== <span class="hljs-string">"dumb"</span> || !!env.CI);
<span class="hljs-keyword">let</span> formatter = <span class="hljs-function">(<span class="hljs-params">open, close, replace = open</span>)=&gt;</span><span class="hljs-function">(<span class="hljs-params">input</span>)=&gt;</span>{
        <span class="hljs-keyword">let</span> string = <span class="hljs-string">""</span> + input, index = string.indexOf(close, open.length);
        <span class="hljs-keyword">return</span> ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
<span class="hljs-keyword">let</span> replaceClose = <span class="hljs-function">(<span class="hljs-params">string, close, replace, index</span>)=&gt;</span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>, cursor = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">do</span> {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
    }<span class="hljs-keyword">while</span> (~index)
    <span class="hljs-keyword">return</span> result + string.substring(cursor);
};
<span class="hljs-keyword">let</span> createColors = <span class="hljs-function">(<span class="hljs-params">enabled = isColorSupported</span>)=&gt;</span>{
    <span class="hljs-keyword">let</span> f = enabled ? formatter : <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-built_in">String</span>;
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">isColorSupported</span>: enabled,
        <span class="hljs-attr">reset</span>: f(<span class="hljs-string">"\x1b[0m"</span>, <span class="hljs-string">"\x1b[0m"</span>),
        <span class="hljs-attr">bold</span>: f(<span class="hljs-string">"\x1b[1m"</span>, <span class="hljs-string">"\x1b[22m"</span>, <span class="hljs-string">"\x1b[22m\x1b[1m"</span>),
        <span class="hljs-attr">dim</span>: f(<span class="hljs-string">"\x1b[2m"</span>, <span class="hljs-string">"\x1b[22m"</span>, <span class="hljs-string">"\x1b[22m\x1b[2m"</span>),
        <span class="hljs-attr">italic</span>: f(<span class="hljs-string">"\x1b[3m"</span>, <span class="hljs-string">"\x1b[23m"</span>),
        <span class="hljs-attr">underline</span>: f(<span class="hljs-string">"\x1b[4m"</span>, <span class="hljs-string">"\x1b[24m"</span>),
        <span class="hljs-attr">inverse</span>: f(<span class="hljs-string">"\x1b[7m"</span>, <span class="hljs-string">"\x1b[27m"</span>),
        <span class="hljs-attr">hidden</span>: f(<span class="hljs-string">"\x1b[8m"</span>, <span class="hljs-string">"\x1b[28m"</span>),
        <span class="hljs-attr">strikethrough</span>: f(<span class="hljs-string">"\x1b[9m"</span>, <span class="hljs-string">"\x1b[29m"</span>),
        <span class="hljs-attr">black</span>: f(<span class="hljs-string">"\x1b[30m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">red</span>: f(<span class="hljs-string">"\x1b[31m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">green</span>: f(<span class="hljs-string">"\x1b[32m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">yellow</span>: f(<span class="hljs-string">"\x1b[33m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">blue</span>: f(<span class="hljs-string">"\x1b[34m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">magenta</span>: f(<span class="hljs-string">"\x1b[35m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">cyan</span>: f(<span class="hljs-string">"\x1b[36m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">white</span>: f(<span class="hljs-string">"\x1b[37m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">gray</span>: f(<span class="hljs-string">"\x1b[90m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">bgBlack</span>: f(<span class="hljs-string">"\x1b[40m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgRed</span>: f(<span class="hljs-string">"\x1b[41m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgGreen</span>: f(<span class="hljs-string">"\x1b[42m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgYellow</span>: f(<span class="hljs-string">"\x1b[43m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgBlue</span>: f(<span class="hljs-string">"\x1b[44m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgMagenta</span>: f(<span class="hljs-string">"\x1b[45m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgCyan</span>: f(<span class="hljs-string">"\x1b[46m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgWhite</span>: f(<span class="hljs-string">"\x1b[47m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">blackBright</span>: f(<span class="hljs-string">"\x1b[90m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">redBright</span>: f(<span class="hljs-string">"\x1b[91m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">greenBright</span>: f(<span class="hljs-string">"\x1b[92m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">yellowBright</span>: f(<span class="hljs-string">"\x1b[93m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">blueBright</span>: f(<span class="hljs-string">"\x1b[94m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">magentaBright</span>: f(<span class="hljs-string">"\x1b[95m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">cyanBright</span>: f(<span class="hljs-string">"\x1b[96m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">whiteBright</span>: f(<span class="hljs-string">"\x1b[97m"</span>, <span class="hljs-string">"\x1b[39m"</span>),
        <span class="hljs-attr">bgBlackBright</span>: f(<span class="hljs-string">"\x1b[100m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgRedBright</span>: f(<span class="hljs-string">"\x1b[101m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgGreenBright</span>: f(<span class="hljs-string">"\x1b[102m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgYellowBright</span>: f(<span class="hljs-string">"\x1b[103m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgBlueBright</span>: f(<span class="hljs-string">"\x1b[104m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgMagentaBright</span>: f(<span class="hljs-string">"\x1b[105m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgCyanBright</span>: f(<span class="hljs-string">"\x1b[106m"</span>, <span class="hljs-string">"\x1b[49m"</span>),
        <span class="hljs-attr">bgWhiteBright</span>: f(<span class="hljs-string">"\x1b[107m"</span>, <span class="hljs-string">"\x1b[49m"</span>)
    };
};
<span class="hljs-built_in">module</span>.exports = createColors();
<span class="hljs-built_in">module</span>.exports.createColors = createColors;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">const</span> SINGLE_QUOTE = <span class="hljs-string">"'"</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> DOUBLE_QUOTE = <span class="hljs-string">'"'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> BACKSLASH = <span class="hljs-string">'\\'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> SLASH = <span class="hljs-string">'/'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> NEWLINE = <span class="hljs-string">'\n'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> SPACE = <span class="hljs-string">' '</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> FEED = <span class="hljs-string">'\f'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> TAB = <span class="hljs-string">'\t'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> CR = <span class="hljs-string">'\r'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> OPEN_SQUARE = <span class="hljs-string">'['</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> CLOSE_SQUARE = <span class="hljs-string">']'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> OPEN_PARENTHESES = <span class="hljs-string">'('</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> CLOSE_PARENTHESES = <span class="hljs-string">')'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> OPEN_CURLY = <span class="hljs-string">'{'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> CLOSE_CURLY = <span class="hljs-string">'}'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> SEMICOLON = <span class="hljs-string">';'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> ASTERISK = <span class="hljs-string">'*'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> COLON = <span class="hljs-string">':'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> AT = <span class="hljs-string">'@'</span>.charCodeAt(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> RE_AT_END = <span class="hljs-regexp">/[\t\n\f\r "#'()/;[\\\]{}]/g</span>;
<span class="hljs-keyword">const</span> RE_WORD_END = <span class="hljs-regexp">/[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g</span>;
<span class="hljs-keyword">const</span> RE_BAD_BRACKET = <span class="hljs-regexp">/.[\r\n"'(/\\]/</span>;
<span class="hljs-keyword">const</span> RE_HEX_ESCAPE = <span class="hljs-regexp">/[\da-f]/i</span>;
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenizer</span>(<span class="hljs-params">input, options = {}</span>) </span>{
    <span class="hljs-keyword">let</span> css = input.css.valueOf();
    <span class="hljs-keyword">let</span> ignore = options.ignoreErrors;
    <span class="hljs-keyword">let</span> code, next, quote, content, <span class="hljs-built_in">escape</span>;
    <span class="hljs-keyword">let</span> escaped, escapePos, prev, n, currentToken;
    <span class="hljs-keyword">let</span> length = css.length;
    <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> buffer = [];
    <span class="hljs-keyword">let</span> returned = [];
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">position</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> pos;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unclosed</span>(<span class="hljs-params">what</span>) </span>{
        <span class="hljs-keyword">throw</span> input.error(<span class="hljs-string">'Unclosed '</span> + what, pos);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOfFile</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> returned.length === <span class="hljs-number">0</span> &amp;&amp; pos &gt;= length;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextToken</span>(<span class="hljs-params">opts</span>) </span>{
        <span class="hljs-keyword">if</span> (returned.length) <span class="hljs-keyword">return</span> returned.pop();
        <span class="hljs-keyword">if</span> (pos &gt;= length) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">let</span> ignoreUnclosed = opts ? opts.ignoreUnclosed : <span class="hljs-literal">false</span>;
        code = css.charCodeAt(pos);
        <span class="hljs-keyword">switch</span>(code){
            <span class="hljs-keyword">case</span> NEWLINE:
            <span class="hljs-keyword">case</span> SPACE:
            <span class="hljs-keyword">case</span> TAB:
            <span class="hljs-keyword">case</span> CR:
            <span class="hljs-keyword">case</span> FEED:
                {
                    next = pos;
                    <span class="hljs-keyword">do</span> {
                        next += <span class="hljs-number">1</span>;
                        code = css.charCodeAt(next);
                    }<span class="hljs-keyword">while</span> (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED)
                    currentToken = [
                        <span class="hljs-string">'space'</span>,
                        css.slice(pos, next)
                    ];
                    pos = next - <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">break</span>;
                }
            <span class="hljs-keyword">case</span> OPEN_SQUARE:
            <span class="hljs-keyword">case</span> CLOSE_SQUARE:
            <span class="hljs-keyword">case</span> OPEN_CURLY:
            <span class="hljs-keyword">case</span> CLOSE_CURLY:
            <span class="hljs-keyword">case</span> COLON:
            <span class="hljs-keyword">case</span> SEMICOLON:
            <span class="hljs-keyword">case</span> CLOSE_PARENTHESES:
                {
                    <span class="hljs-keyword">let</span> controlChar = <span class="hljs-built_in">String</span>.fromCharCode(code);
                    currentToken = [
                        controlChar,
                        controlChar,
                        pos
                    ];
                    <span class="hljs-keyword">break</span>;
                }
            <span class="hljs-keyword">case</span> OPEN_PARENTHESES:
                {
                    prev = buffer.length ? buffer.pop()[<span class="hljs-number">1</span>] : <span class="hljs-string">''</span>;
                    n = css.charCodeAt(pos + <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">if</span> (prev === <span class="hljs-string">'url'</span> &amp;&amp; n !== SINGLE_QUOTE &amp;&amp; n !== DOUBLE_QUOTE &amp;&amp; n !== SPACE &amp;&amp; n !== NEWLINE &amp;&amp; n !== TAB &amp;&amp; n !== FEED &amp;&amp; n !== CR) {
                        next = pos;
                        <span class="hljs-keyword">do</span> {
                            escaped = <span class="hljs-literal">false</span>;
                            next = css.indexOf(<span class="hljs-string">')'</span>, next + <span class="hljs-number">1</span>);
                            <span class="hljs-keyword">if</span> (next === <span class="hljs-number">-1</span>) {
                                <span class="hljs-keyword">if</span> (ignore || ignoreUnclosed) {
                                    next = pos;
                                    <span class="hljs-keyword">break</span>;
                                } <span class="hljs-keyword">else</span> {
                                    unclosed(<span class="hljs-string">'bracket'</span>);
                                }
                            }
                            escapePos = next;
                            <span class="hljs-keyword">while</span>(css.charCodeAt(escapePos - <span class="hljs-number">1</span>) === BACKSLASH){
                                escapePos -= <span class="hljs-number">1</span>;
                                escaped = !escaped;
                            }
                        }<span class="hljs-keyword">while</span> (escaped)
                        currentToken = [
                            <span class="hljs-string">'brackets'</span>,
                            css.slice(pos, next + <span class="hljs-number">1</span>),
                            pos,
                            next
                        ];
                        pos = next;
                    } <span class="hljs-keyword">else</span> {
                        next = css.indexOf(<span class="hljs-string">')'</span>, pos + <span class="hljs-number">1</span>);
                        content = css.slice(pos, next + <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">if</span> (next === <span class="hljs-number">-1</span> || RE_BAD_BRACKET.test(content)) {
                            currentToken = [
                                <span class="hljs-string">'('</span>,
                                <span class="hljs-string">'('</span>,
                                pos
                            ];
                        } <span class="hljs-keyword">else</span> {
                            currentToken = [
                                <span class="hljs-string">'brackets'</span>,
                                content,
                                pos,
                                next
                            ];
                            pos = next;
                        }
                    }
                    <span class="hljs-keyword">break</span>;
                }
            <span class="hljs-keyword">case</span> SINGLE_QUOTE:
            <span class="hljs-keyword">case</span> DOUBLE_QUOTE:
                {
                    quote = code === SINGLE_QUOTE ? <span class="hljs-string">"'"</span> : <span class="hljs-string">'"'</span>;
                    next = pos;
                    <span class="hljs-keyword">do</span> {
                        escaped = <span class="hljs-literal">false</span>;
                        next = css.indexOf(quote, next + <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">if</span> (next === <span class="hljs-number">-1</span>) {
                            <span class="hljs-keyword">if</span> (ignore || ignoreUnclosed) {
                                next = pos + <span class="hljs-number">1</span>;
                                <span class="hljs-keyword">break</span>;
                            } <span class="hljs-keyword">else</span> {
                                unclosed(<span class="hljs-string">'string'</span>);
                            }
                        }
                        escapePos = next;
                        <span class="hljs-keyword">while</span>(css.charCodeAt(escapePos - <span class="hljs-number">1</span>) === BACKSLASH){
                            escapePos -= <span class="hljs-number">1</span>;
                            escaped = !escaped;
                        }
                    }<span class="hljs-keyword">while</span> (escaped)
                    currentToken = [
                        <span class="hljs-string">'string'</span>,
                        css.slice(pos, next + <span class="hljs-number">1</span>),
                        pos,
                        next
                    ];
                    pos = next;
                    <span class="hljs-keyword">break</span>;
                }
            <span class="hljs-keyword">case</span> AT:
                {
                    RE_AT_END.lastIndex = pos + <span class="hljs-number">1</span>;
                    RE_AT_END.test(css);
                    <span class="hljs-keyword">if</span> (RE_AT_END.lastIndex === <span class="hljs-number">0</span>) {
                        next = css.length - <span class="hljs-number">1</span>;
                    } <span class="hljs-keyword">else</span> {
                        next = RE_AT_END.lastIndex - <span class="hljs-number">2</span>;
                    }
                    currentToken = [
                        <span class="hljs-string">'at-word'</span>,
                        css.slice(pos, next + <span class="hljs-number">1</span>),
                        pos,
                        next
                    ];
                    pos = next;
                    <span class="hljs-keyword">break</span>;
                }
            <span class="hljs-keyword">case</span> BACKSLASH:
                {
                    next = pos;
                    <span class="hljs-built_in">escape</span> = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">while</span>(css.charCodeAt(next + <span class="hljs-number">1</span>) === BACKSLASH){
                        next += <span class="hljs-number">1</span>;
                        <span class="hljs-built_in">escape</span> = !<span class="hljs-built_in">escape</span>;
                    }
                    code = css.charCodeAt(next + <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">escape</span> &amp;&amp; code !== SLASH &amp;&amp; code !== SPACE &amp;&amp; code !== NEWLINE &amp;&amp; code !== TAB &amp;&amp; code !== CR &amp;&amp; code !== FEED) {
                        next += <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">if</span> (RE_HEX_ESCAPE.test(css.charAt(next))) {
                            <span class="hljs-keyword">while</span>(RE_HEX_ESCAPE.test(css.charAt(next + <span class="hljs-number">1</span>))){
                                next += <span class="hljs-number">1</span>;
                            }
                            <span class="hljs-keyword">if</span> (css.charCodeAt(next + <span class="hljs-number">1</span>) === SPACE) {
                                next += <span class="hljs-number">1</span>;
                            }
                        }
                    }
                    currentToken = [
                        <span class="hljs-string">'word'</span>,
                        css.slice(pos, next + <span class="hljs-number">1</span>),
                        pos,
                        next
                    ];
                    pos = next;
                    <span class="hljs-keyword">break</span>;
                }
            <span class="hljs-attr">default</span>:
                {
                    <span class="hljs-keyword">if</span> (code === SLASH &amp;&amp; css.charCodeAt(pos + <span class="hljs-number">1</span>) === ASTERISK) {
                        next = css.indexOf(<span class="hljs-string">'*/'</span>, pos + <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">if</span> (next === <span class="hljs-number">0</span>) {
                            <span class="hljs-keyword">if</span> (ignore || ignoreUnclosed) {
                                next = css.length;
                            } <span class="hljs-keyword">else</span> {
                                unclosed(<span class="hljs-string">'comment'</span>);
                            }
                        }
                        currentToken = [
                            <span class="hljs-string">'comment'</span>,
                            css.slice(pos, next + <span class="hljs-number">1</span>),
                            pos,
                            next
                        ];
                        pos = next;
                    } <span class="hljs-keyword">else</span> {
                        RE_WORD_END.lastIndex = pos + <span class="hljs-number">1</span>;
                        RE_WORD_END.test(css);
                        <span class="hljs-keyword">if</span> (RE_WORD_END.lastIndex === <span class="hljs-number">0</span>) {
                            next = css.length - <span class="hljs-number">1</span>;
                        } <span class="hljs-keyword">else</span> {
                            next = RE_WORD_END.lastIndex - <span class="hljs-number">2</span>;
                        }
                        currentToken = [
                            <span class="hljs-string">'word'</span>,
                            css.slice(pos, next + <span class="hljs-number">1</span>),
                            pos,
                            next
                        ];
                        buffer.push(currentToken);
                        pos = next;
                    }
                    <span class="hljs-keyword">break</span>;
                }
        }
        pos++;
        <span class="hljs-keyword">return</span> currentToken;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">back</span>(<span class="hljs-params">token</span>) </span>{
        returned.push(token);
    }
    <span class="hljs-keyword">return</span> {
        back,
        endOfFile,
        nextToken,
        position
    };
};
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> pico = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> tokenizer = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Input;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerInput</span>(<span class="hljs-params">dependant</span>) </span>{
    Input = dependant;
}
<span class="hljs-keyword">const</span> HIGHLIGHT_THEME = {
    <span class="hljs-string">';'</span>: pico.yellow,
    <span class="hljs-string">':'</span>: pico.yellow,
    <span class="hljs-string">'('</span>: pico.cyan,
    <span class="hljs-string">')'</span>: pico.cyan,
    <span class="hljs-string">'['</span>: pico.yellow,
    <span class="hljs-string">']'</span>: pico.yellow,
    <span class="hljs-string">'{'</span>: pico.yellow,
    <span class="hljs-string">'}'</span>: pico.yellow,
    <span class="hljs-string">'at-word'</span>: pico.cyan,
    <span class="hljs-string">'brackets'</span>: pico.cyan,
    <span class="hljs-string">'call'</span>: pico.cyan,
    <span class="hljs-string">'class'</span>: pico.yellow,
    <span class="hljs-string">'comment'</span>: pico.gray,
    <span class="hljs-string">'hash'</span>: pico.magenta,
    <span class="hljs-string">'string'</span>: pico.green
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTokenType</span>(<span class="hljs-params">[type, value], processor</span>) </span>{
    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'word'</span>) {
        <span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] === <span class="hljs-string">'.'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'class'</span>;
        }
        <span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] === <span class="hljs-string">'#'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'hash'</span>;
        }
    }
    <span class="hljs-keyword">if</span> (!processor.endOfFile()) {
        <span class="hljs-keyword">let</span> next = processor.nextToken();
        processor.back(next);
        <span class="hljs-keyword">if</span> (next[<span class="hljs-number">0</span>] === <span class="hljs-string">'brackets'</span> || next[<span class="hljs-number">0</span>] === <span class="hljs-string">'('</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'call'</span>;
    }
    <span class="hljs-keyword">return</span> type;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">terminalHighlight</span>(<span class="hljs-params">css</span>) </span>{
    <span class="hljs-keyword">let</span> processor = tokenizer(<span class="hljs-keyword">new</span> Input(css), {
        <span class="hljs-attr">ignoreErrors</span>: <span class="hljs-literal">true</span>
    });
    <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">while</span>(!processor.endOfFile()){
        <span class="hljs-keyword">let</span> token = processor.nextToken();
        <span class="hljs-keyword">let</span> color = HIGHLIGHT_THEME[getTokenType(token, processor)];
        <span class="hljs-keyword">if</span> (color) {
            result += token[<span class="hljs-number">1</span>].split(<span class="hljs-regexp">/\r?\n/</span>).map(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>color(i)).join(<span class="hljs-string">'\n'</span>);
        } <span class="hljs-keyword">else</span> {
            result += token[<span class="hljs-number">1</span>];
        }
    }
    <span class="hljs-keyword">return</span> result;
}
terminalHighlight.registerInput = registerInput;
<span class="hljs-built_in">module</span>.exports = terminalHighlight;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> pico = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> terminalHighlight = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CssSyntaxError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
    <span class="hljs-keyword">constructor</span>(message, line, column, source, file, plugin){
        <span class="hljs-keyword">super</span>(message);
        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'CssSyntaxError'</span>;
        <span class="hljs-keyword">this</span>.reason = message;
        <span class="hljs-keyword">if</span> (file) {
            <span class="hljs-keyword">this</span>.file = file;
        }
        <span class="hljs-keyword">if</span> (source) {
            <span class="hljs-keyword">this</span>.source = source;
        }
        <span class="hljs-keyword">if</span> (plugin) {
            <span class="hljs-keyword">this</span>.plugin = plugin;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> line !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> column !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> line === <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">this</span>.line = line;
                <span class="hljs-keyword">this</span>.column = column;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.line = line.line;
                <span class="hljs-keyword">this</span>.column = line.column;
                <span class="hljs-keyword">this</span>.endLine = column.line;
                <span class="hljs-keyword">this</span>.endColumn = column.column;
            }
        }
        <span class="hljs-keyword">this</span>.setMessage();
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Error</span>.captureStackTrace) {
            <span class="hljs-built_in">Error</span>.captureStackTrace(<span class="hljs-keyword">this</span>, CssSyntaxError);
        }
    }
    setMessage() {
        <span class="hljs-keyword">this</span>.message = <span class="hljs-keyword">this</span>.plugin ? <span class="hljs-keyword">this</span>.plugin + <span class="hljs-string">': '</span> : <span class="hljs-string">''</span>;
        <span class="hljs-keyword">this</span>.message += <span class="hljs-keyword">this</span>.file ? <span class="hljs-keyword">this</span>.file : <span class="hljs-string">'&lt;css input&gt;'</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.line !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">this</span>.message += <span class="hljs-string">':'</span> + <span class="hljs-keyword">this</span>.line + <span class="hljs-string">':'</span> + <span class="hljs-keyword">this</span>.column;
        }
        <span class="hljs-keyword">this</span>.message += <span class="hljs-string">': '</span> + <span class="hljs-keyword">this</span>.reason;
    }
    showSourceCode(color) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.source) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
        <span class="hljs-keyword">let</span> css = <span class="hljs-keyword">this</span>.source;
        <span class="hljs-keyword">if</span> (color == <span class="hljs-literal">null</span>) color = pico.isColorSupported;
        <span class="hljs-keyword">if</span> (terminalHighlight) {
            <span class="hljs-keyword">if</span> (color) css = terminalHighlight(css);
        }
        <span class="hljs-keyword">let</span> lines = css.split(<span class="hljs-regexp">/\r?\n/</span>);
        <span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.line - <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">let</span> end = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.line + <span class="hljs-number">2</span>, lines.length);
        <span class="hljs-keyword">let</span> maxWidth = <span class="hljs-built_in">String</span>(end).length;
        <span class="hljs-keyword">let</span> mark, aside;
        <span class="hljs-keyword">if</span> (color) {
            <span class="hljs-keyword">let</span> { bold, gray, red } = pico.createColors(<span class="hljs-literal">true</span>);
            mark = <span class="hljs-function">(<span class="hljs-params">text</span>)=&gt;</span>bold(red(text));
            aside = <span class="hljs-function">(<span class="hljs-params">text</span>)=&gt;</span>gray(text);
        } <span class="hljs-keyword">else</span> {
            mark = aside = <span class="hljs-function">(<span class="hljs-params">str</span>)=&gt;</span>str;
        }
        <span class="hljs-keyword">return</span> lines.slice(start, end).map(<span class="hljs-function">(<span class="hljs-params">line, index</span>)=&gt;</span>{
            <span class="hljs-keyword">let</span> number = start + <span class="hljs-number">1</span> + index;
            <span class="hljs-keyword">let</span> gutter = <span class="hljs-string">' '</span> + (<span class="hljs-string">' '</span> + number).slice(-maxWidth) + <span class="hljs-string">' | '</span>;
            <span class="hljs-keyword">if</span> (number === <span class="hljs-keyword">this</span>.line) {
                <span class="hljs-keyword">let</span> spacing = aside(gutter.replace(<span class="hljs-regexp">/\d/g</span>, <span class="hljs-string">' '</span>)) + line.slice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.column - <span class="hljs-number">1</span>).replace(<span class="hljs-regexp">/[^\t]/g</span>, <span class="hljs-string">' '</span>);
                <span class="hljs-keyword">return</span> mark(<span class="hljs-string">'&gt;'</span>) + aside(gutter) + line + <span class="hljs-string">'\n '</span> + spacing + mark(<span class="hljs-string">'^'</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span> + aside(gutter) + line;
        }).join(<span class="hljs-string">'\n'</span>);
    }
    toString() {
        <span class="hljs-keyword">let</span> code = <span class="hljs-keyword">this</span>.showSourceCode();
        <span class="hljs-keyword">if</span> (code) {
            code = <span class="hljs-string">'\n\n'</span> + code + <span class="hljs-string">'\n'</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name + <span class="hljs-string">': '</span> + <span class="hljs-keyword">this</span>.message + code;
    }
}
<span class="hljs-built_in">module</span>.exports = CssSyntaxError;
CssSyntaxError.default = CssSyntaxError;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-built_in">module</span>.exports.isClean = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'isClean'</span>);
<span class="hljs-built_in">module</span>.exports.my = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'my'</span>);
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">const</span> DEFAULT_RAW = {
    <span class="hljs-attr">after</span>: <span class="hljs-string">'\n'</span>,
    <span class="hljs-attr">beforeClose</span>: <span class="hljs-string">'\n'</span>,
    <span class="hljs-attr">beforeComment</span>: <span class="hljs-string">'\n'</span>,
    <span class="hljs-attr">beforeDecl</span>: <span class="hljs-string">'\n'</span>,
    <span class="hljs-attr">beforeOpen</span>: <span class="hljs-string">' '</span>,
    <span class="hljs-attr">beforeRule</span>: <span class="hljs-string">'\n'</span>,
    <span class="hljs-attr">colon</span>: <span class="hljs-string">': '</span>,
    <span class="hljs-attr">commentLeft</span>: <span class="hljs-string">' '</span>,
    <span class="hljs-attr">commentRight</span>: <span class="hljs-string">' '</span>,
    <span class="hljs-attr">emptyBody</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">indent</span>: <span class="hljs-string">'    '</span>,
    <span class="hljs-attr">semicolon</span>: <span class="hljs-literal">false</span>
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalize</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>].toUpperCase() + str.slice(<span class="hljs-number">1</span>);
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stringifier</span> </span>{
    <span class="hljs-keyword">constructor</span>(builder){
        <span class="hljs-keyword">this</span>.builder = builder;
    }
    atrule(node, semicolon) {
        <span class="hljs-keyword">let</span> name = <span class="hljs-string">'@'</span> + node.name;
        <span class="hljs-keyword">let</span> params = node.params ? <span class="hljs-keyword">this</span>.rawValue(node, <span class="hljs-string">'params'</span>) : <span class="hljs-string">''</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node.raws.afterName !== <span class="hljs-string">'undefined'</span>) {
            name += node.raws.afterName;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (params) {
            name += <span class="hljs-string">' '</span>;
        }
        <span class="hljs-keyword">if</span> (node.nodes) {
            <span class="hljs-keyword">this</span>.block(node, name + params);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> end = (node.raws.between || <span class="hljs-string">''</span>) + (semicolon ? <span class="hljs-string">';'</span> : <span class="hljs-string">''</span>);
            <span class="hljs-keyword">this</span>.builder(name + params + end, node);
        }
    }
    beforeAfter(node, detect) {
        <span class="hljs-keyword">let</span> value;
        <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'decl'</span>) {
            value = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-literal">null</span>, <span class="hljs-string">'beforeDecl'</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'comment'</span>) {
            value = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-literal">null</span>, <span class="hljs-string">'beforeComment'</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (detect === <span class="hljs-string">'before'</span>) {
            value = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-literal">null</span>, <span class="hljs-string">'beforeRule'</span>);
        } <span class="hljs-keyword">else</span> {
            value = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-literal">null</span>, <span class="hljs-string">'beforeClose'</span>);
        }
        <span class="hljs-keyword">let</span> buf = node.parent;
        <span class="hljs-keyword">let</span> depth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(buf &amp;&amp; buf.type !== <span class="hljs-string">'root'</span>){
            depth += <span class="hljs-number">1</span>;
            buf = buf.parent;
        }
        <span class="hljs-keyword">if</span> (value.includes(<span class="hljs-string">'\n'</span>)) {
            <span class="hljs-keyword">let</span> indent = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-literal">null</span>, <span class="hljs-string">'indent'</span>);
            <span class="hljs-keyword">if</span> (indent.length) {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span>; step &lt; depth; step++)value += indent;
            }
        }
        <span class="hljs-keyword">return</span> value;
    }
    block(node, start) {
        <span class="hljs-keyword">let</span> between = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'between'</span>, <span class="hljs-string">'beforeOpen'</span>);
        <span class="hljs-keyword">this</span>.builder(start + between + <span class="hljs-string">'{'</span>, node, <span class="hljs-string">'start'</span>);
        <span class="hljs-keyword">let</span> after;
        <span class="hljs-keyword">if</span> (node.nodes &amp;&amp; node.nodes.length) {
            <span class="hljs-keyword">this</span>.body(node);
            after = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'after'</span>);
        } <span class="hljs-keyword">else</span> {
            after = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'after'</span>, <span class="hljs-string">'emptyBody'</span>);
        }
        <span class="hljs-keyword">if</span> (after) <span class="hljs-keyword">this</span>.builder(after);
        <span class="hljs-keyword">this</span>.builder(<span class="hljs-string">'}'</span>, node, <span class="hljs-string">'end'</span>);
    }
    body(node) {
        <span class="hljs-keyword">let</span> last = node.nodes.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(last &gt; <span class="hljs-number">0</span>){
            <span class="hljs-keyword">if</span> (node.nodes[last].type !== <span class="hljs-string">'comment'</span>) <span class="hljs-keyword">break</span>;
            last -= <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">let</span> semicolon = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'semicolon'</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; node.nodes.length; i++){
            <span class="hljs-keyword">let</span> child = node.nodes[i];
            <span class="hljs-keyword">let</span> before = <span class="hljs-keyword">this</span>.raw(child, <span class="hljs-string">'before'</span>);
            <span class="hljs-keyword">if</span> (before) <span class="hljs-keyword">this</span>.builder(before);
            <span class="hljs-keyword">this</span>.stringify(child, last !== i || semicolon);
        }
    }
    comment(node) {
        <span class="hljs-keyword">let</span> left = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'left'</span>, <span class="hljs-string">'commentLeft'</span>);
        <span class="hljs-keyword">let</span> right = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'right'</span>, <span class="hljs-string">'commentRight'</span>);
        <span class="hljs-keyword">this</span>.builder(<span class="hljs-string">'/*'</span> + left + node.text + right + <span class="hljs-string">'*/'</span>, node);
    }
    decl(node, semicolon) {
        <span class="hljs-keyword">let</span> between = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'between'</span>, <span class="hljs-string">'colon'</span>);
        <span class="hljs-keyword">let</span> string = node.prop + between + <span class="hljs-keyword">this</span>.rawValue(node, <span class="hljs-string">'value'</span>);
        <span class="hljs-keyword">if</span> (node.important) {
            string += node.raws.important || <span class="hljs-string">' !important'</span>;
        }
        <span class="hljs-keyword">if</span> (semicolon) string += <span class="hljs-string">';'</span>;
        <span class="hljs-keyword">this</span>.builder(string, node);
    }
    <span class="hljs-built_in">document</span>(node) {
        <span class="hljs-keyword">this</span>.body(node);
    }
    raw(node, own, detect) {
        <span class="hljs-keyword">let</span> value;
        <span class="hljs-keyword">if</span> (!detect) detect = own;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Already had</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (own) {
            value = node.raws[own];
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> value;
        }
        <span class="hljs-keyword">let</span> parent = node.parent;
        <span class="hljs-keyword">if</span> (detect === <span class="hljs-string">'before'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Hack for first rule in CSS</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (!parent || parent.type === <span class="hljs-string">'root'</span> &amp;&amp; parent.first === node) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
            }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p><code>root</code> nodes in <code>document</code> should use only their own raws</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (parent &amp;&amp; parent.type === <span class="hljs-string">'document'</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
            }
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Floating child without parent</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!parent) <span class="hljs-keyword">return</span> DEFAULT_RAW[detect];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Detect style by other nodes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">let</span> root = node.root();
        <span class="hljs-keyword">if</span> (!root.rawCache) root.rawCache = {};
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> root.rawCache[detect] !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> root.rawCache[detect];
        }
        <span class="hljs-keyword">if</span> (detect === <span class="hljs-string">'before'</span> || detect === <span class="hljs-string">'after'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beforeAfter(node, detect);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> method = <span class="hljs-string">'raw'</span> + capitalize(detect);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[method]) {
                value = <span class="hljs-keyword">this</span>[method](root, node);
            } <span class="hljs-keyword">else</span> {
                root.walk(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
                    value = i.raws[own];
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                });
            }
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span>) value = DEFAULT_RAW[detect];
        root.rawCache[detect] = value;
        <span class="hljs-keyword">return</span> value;
    }
    rawBeforeClose(root) {
        <span class="hljs-keyword">let</span> value;
        root.walk(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (i.nodes &amp;&amp; i.nodes.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i.raws.after !== <span class="hljs-string">'undefined'</span>) {
                    value = i.raws.after;
                    <span class="hljs-keyword">if</span> (value.includes(<span class="hljs-string">'\n'</span>)) {
                        value = value.replace(<span class="hljs-regexp">/[^\n]+$/</span>, <span class="hljs-string">''</span>);
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
        });
        <span class="hljs-keyword">if</span> (value) value = value.replace(<span class="hljs-regexp">/\S/g</span>, <span class="hljs-string">''</span>);
        <span class="hljs-keyword">return</span> value;
    }
    rawBeforeComment(root, node) {
        <span class="hljs-keyword">let</span> value;
        root.walkComments(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i.raws.before !== <span class="hljs-string">'undefined'</span>) {
                value = i.raws.before;
                <span class="hljs-keyword">if</span> (value.includes(<span class="hljs-string">'\n'</span>)) {
                    value = value.replace(<span class="hljs-regexp">/[^\n]+$/</span>, <span class="hljs-string">''</span>);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        });
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span>) {
            value = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-literal">null</span>, <span class="hljs-string">'beforeDecl'</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value) {
            value = value.replace(<span class="hljs-regexp">/\S/g</span>, <span class="hljs-string">''</span>);
        }
        <span class="hljs-keyword">return</span> value;
    }
    rawBeforeDecl(root, node) {
        <span class="hljs-keyword">let</span> value;
        root.walkDecls(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i.raws.before !== <span class="hljs-string">'undefined'</span>) {
                value = i.raws.before;
                <span class="hljs-keyword">if</span> (value.includes(<span class="hljs-string">'\n'</span>)) {
                    value = value.replace(<span class="hljs-regexp">/[^\n]+$/</span>, <span class="hljs-string">''</span>);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        });
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span>) {
            value = <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-literal">null</span>, <span class="hljs-string">'beforeRule'</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value) {
            value = value.replace(<span class="hljs-regexp">/\S/g</span>, <span class="hljs-string">''</span>);
        }
        <span class="hljs-keyword">return</span> value;
    }
    rawBeforeOpen(root) {
        <span class="hljs-keyword">let</span> value;
        root.walk(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (i.type !== <span class="hljs-string">'decl'</span>) {
                value = i.raws.between;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        });
        <span class="hljs-keyword">return</span> value;
    }
    rawBeforeRule(root) {
        <span class="hljs-keyword">let</span> value;
        root.walk(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (i.nodes &amp;&amp; (i.parent !== root || root.first !== i)) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i.raws.before !== <span class="hljs-string">'undefined'</span>) {
                    value = i.raws.before;
                    <span class="hljs-keyword">if</span> (value.includes(<span class="hljs-string">'\n'</span>)) {
                        value = value.replace(<span class="hljs-regexp">/[^\n]+$/</span>, <span class="hljs-string">''</span>);
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
        });
        <span class="hljs-keyword">if</span> (value) value = value.replace(<span class="hljs-regexp">/\S/g</span>, <span class="hljs-string">''</span>);
        <span class="hljs-keyword">return</span> value;
    }
    rawColon(root) {
        <span class="hljs-keyword">let</span> value;
        root.walkDecls(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i.raws.between !== <span class="hljs-string">'undefined'</span>) {
                value = i.raws.between.replace(<span class="hljs-regexp">/[^\s:]/g</span>, <span class="hljs-string">''</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        });
        <span class="hljs-keyword">return</span> value;
    }
    rawEmptyBody(root) {
        <span class="hljs-keyword">let</span> value;
        root.walk(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (i.nodes &amp;&amp; i.nodes.length === <span class="hljs-number">0</span>) {
                value = i.raws.after;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        });
        <span class="hljs-keyword">return</span> value;
    }
    rawIndent(root) {
        <span class="hljs-keyword">if</span> (root.raws.indent) <span class="hljs-keyword">return</span> root.raws.indent;
        <span class="hljs-keyword">let</span> value;
        root.walk(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">let</span> p = i.parent;
            <span class="hljs-keyword">if</span> (p &amp;&amp; p !== root &amp;&amp; p.parent &amp;&amp; p.parent === root) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i.raws.before !== <span class="hljs-string">'undefined'</span>) {
                    <span class="hljs-keyword">let</span> parts = i.raws.before.split(<span class="hljs-string">'\n'</span>);
                    value = parts[parts.length - <span class="hljs-number">1</span>];
                    value = value.replace(<span class="hljs-regexp">/\S/g</span>, <span class="hljs-string">''</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
        });
        <span class="hljs-keyword">return</span> value;
    }
    rawSemicolon(root) {
        <span class="hljs-keyword">let</span> value;
        root.walk(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (i.nodes &amp;&amp; i.nodes.length &amp;&amp; i.last.type === <span class="hljs-string">'decl'</span>) {
                value = i.raws.semicolon;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        });
        <span class="hljs-keyword">return</span> value;
    }
    rawValue(node, prop) {
        <span class="hljs-keyword">let</span> value = node[prop];
        <span class="hljs-keyword">let</span> raw = node.raws[prop];
        <span class="hljs-keyword">if</span> (raw &amp;&amp; raw.value === value) {
            <span class="hljs-keyword">return</span> raw.raw;
        }
        <span class="hljs-keyword">return</span> value;
    }
    root(node) {
        <span class="hljs-keyword">this</span>.body(node);
        <span class="hljs-keyword">if</span> (node.raws.after) <span class="hljs-keyword">this</span>.builder(node.raws.after);
    }
    rule(node) {
        <span class="hljs-keyword">this</span>.block(node, <span class="hljs-keyword">this</span>.rawValue(node, <span class="hljs-string">'selector'</span>));
        <span class="hljs-keyword">if</span> (node.raws.ownSemicolon) {
            <span class="hljs-keyword">this</span>.builder(node.raws.ownSemicolon, node, <span class="hljs-string">'end'</span>);
        }
    }
    stringify(node, semicolon) {
        <span class="hljs-comment">/* c8 ignore start */</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>[node.type]) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unknown AST node type '</span> + node.type + <span class="hljs-string">'. '</span> + <span class="hljs-string">'Maybe you need to change PostCSS stringifier.'</span>);
        }
        <span class="hljs-comment">/* c8 ignore stop */</span> <span class="hljs-keyword">this</span>[node.type](node, semicolon);
    }
}
<span class="hljs-built_in">module</span>.exports = Stringifier;
Stringifier.default = Stringifier;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Stringifier = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringify</span>(<span class="hljs-params">node, builder</span>) </span>{
    <span class="hljs-keyword">let</span> str = <span class="hljs-keyword">new</span> Stringifier(builder);
    str.stringify(node);
}
<span class="hljs-built_in">module</span>.exports = stringify;
stringify.default = stringify;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/node.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> { isClean, my } = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> CssSyntaxError = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Stringifier = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> stringify = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneNode</span>(<span class="hljs-params">obj, parent</span>) </span>{
    <span class="hljs-keyword">let</span> cloned = <span class="hljs-keyword">new</span> obj.constructor();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj){
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, i)) {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span> (i === <span class="hljs-string">'proxyCache'</span>) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">let</span> value = obj[i];
        <span class="hljs-keyword">let</span> type = <span class="hljs-keyword">typeof</span> value;
        <span class="hljs-keyword">if</span> (i === <span class="hljs-string">'parent'</span> &amp;&amp; type === <span class="hljs-string">'object'</span>) {
            <span class="hljs-keyword">if</span> (parent) cloned[i] = parent;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i === <span class="hljs-string">'source'</span>) {
            cloned[i] = value;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
            cloned[i] = value.map(<span class="hljs-function">(<span class="hljs-params">j</span>)=&gt;</span>cloneNode(j, cloned));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) value = cloneNode(value);
            cloned[i] = value;
        }
    }
    <span class="hljs-keyword">return</span> cloned;
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
    <span class="hljs-keyword">constructor</span>(defaults = {}){
        <span class="hljs-keyword">this</span>.raws = {};
        <span class="hljs-keyword">this</span>[isClean] = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>[my] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> name <span class="hljs-keyword">in</span> defaults){
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'nodes'</span>) {
                <span class="hljs-keyword">this</span>.nodes = [];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> defaults[name]){
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node.clone === <span class="hljs-string">'function'</span>) {
                        <span class="hljs-keyword">this</span>.append(node.clone());
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">this</span>.append(node);
                    }
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>[name] = defaults[name];
            }
        }
    }
    addToError(error) {
        error.postcssNode = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">if</span> (error.stack &amp;&amp; <span class="hljs-keyword">this</span>.source &amp;&amp; <span class="hljs-regexp">/\n\s{4}at /</span>.test(error.stack)) {
            <span class="hljs-keyword">let</span> s = <span class="hljs-keyword">this</span>.source;
            error.stack = error.stack.replace(<span class="hljs-regexp">/\n\s{4}at /</span>, <span class="hljs-string">`$&amp;<span class="hljs-subst">${s.input.<span class="hljs-keyword">from</span>}</span>:<span class="hljs-subst">${s.start.line}</span>:<span class="hljs-subst">${s.start.column}</span>$&amp;`</span>);
        }
        <span class="hljs-keyword">return</span> error;
    }
    after(add) {
        <span class="hljs-keyword">this</span>.parent.insertAfter(<span class="hljs-keyword">this</span>, add);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    assign(overrides = {}) {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> name <span class="hljs-keyword">in</span> overrides){
            <span class="hljs-keyword">this</span>[name] = overrides[name];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    before(add) {
        <span class="hljs-keyword">this</span>.parent.insertBefore(<span class="hljs-keyword">this</span>, add);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    cleanRaws(keepBetween) {
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.raws.before;
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.raws.after;
        <span class="hljs-keyword">if</span> (!keepBetween) <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.raws.between;
    }
    clone(overrides = {}) {
        <span class="hljs-keyword">let</span> cloned = cloneNode(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> name <span class="hljs-keyword">in</span> overrides){
            cloned[name] = overrides[name];
        }
        <span class="hljs-keyword">return</span> cloned;
    }
    cloneAfter(overrides = {}) {
        <span class="hljs-keyword">let</span> cloned = <span class="hljs-keyword">this</span>.clone(overrides);
        <span class="hljs-keyword">this</span>.parent.insertAfter(<span class="hljs-keyword">this</span>, cloned);
        <span class="hljs-keyword">return</span> cloned;
    }
    cloneBefore(overrides = {}) {
        <span class="hljs-keyword">let</span> cloned = <span class="hljs-keyword">this</span>.clone(overrides);
        <span class="hljs-keyword">this</span>.parent.insertBefore(<span class="hljs-keyword">this</span>, cloned);
        <span class="hljs-keyword">return</span> cloned;
    }
    error(message, opts = {}) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.source) {
            <span class="hljs-keyword">let</span> { end, start } = <span class="hljs-keyword">this</span>.rangeBy(opts);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.source.input.error(message, {
                <span class="hljs-attr">column</span>: start.column,
                <span class="hljs-attr">line</span>: start.line
            }, {
                <span class="hljs-attr">column</span>: end.column,
                <span class="hljs-attr">line</span>: end.line
            }, opts);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CssSyntaxError(message);
    }
    getProxyProcessor() {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-keyword">get</span> (node, prop) {
                <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'proxyOf'</span>) {
                    <span class="hljs-keyword">return</span> node;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'root'</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>node.root().toProxy();
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> node[prop];
                }
            },
            <span class="hljs-keyword">set</span> (node, prop, value) {
                <span class="hljs-keyword">if</span> (node[prop] === value) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                node[prop] = value;
                <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'prop'</span> || prop === <span class="hljs-string">'value'</span> || prop === <span class="hljs-string">'name'</span> || prop === <span class="hljs-string">'params'</span> || prop === <span class="hljs-string">'important'</span> || <span class="hljs-comment">/* c8 ignore next */</span> prop === <span class="hljs-string">'text'</span>) {
                    node.markDirty();
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        };
    }
    markDirty() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[isClean]) {
            <span class="hljs-keyword">this</span>[isClean] = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">let</span> next = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">while</span>(next = next.parent){
                next[isClean] = <span class="hljs-literal">false</span>;
            }
        }
    }
    next() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.parent) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">let</span> index = <span class="hljs-keyword">this</span>.parent.index(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parent.nodes[index + <span class="hljs-number">1</span>];
    }
    positionBy(opts, stringRepresentation) {
        <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.source.start;
        <span class="hljs-keyword">if</span> (opts.index) {
            pos = <span class="hljs-keyword">this</span>.positionInside(opts.index, stringRepresentation);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opts.word) {
            stringRepresentation = <span class="hljs-keyword">this</span>.toString();
            <span class="hljs-keyword">let</span> index = stringRepresentation.indexOf(opts.word);
            <span class="hljs-keyword">if</span> (index !== <span class="hljs-number">-1</span>) pos = <span class="hljs-keyword">this</span>.positionInside(index, stringRepresentation);
        }
        <span class="hljs-keyword">return</span> pos;
    }
    positionInside(index, stringRepresentation) {
        <span class="hljs-keyword">let</span> string = stringRepresentation || <span class="hljs-keyword">this</span>.toString();
        <span class="hljs-keyword">let</span> column = <span class="hljs-keyword">this</span>.source.start.column;
        <span class="hljs-keyword">let</span> line = <span class="hljs-keyword">this</span>.source.start.line;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++){
            <span class="hljs-keyword">if</span> (string[i] === <span class="hljs-string">'\n'</span>) {
                column = <span class="hljs-number">1</span>;
                line += <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                column += <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">return</span> {
            column,
            line
        };
    }
    prev() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.parent) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">let</span> index = <span class="hljs-keyword">this</span>.parent.index(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parent.nodes[index - <span class="hljs-number">1</span>];
    }
    rangeBy(opts) {
        <span class="hljs-keyword">let</span> start = {
            <span class="hljs-attr">column</span>: <span class="hljs-keyword">this</span>.source.start.column,
            <span class="hljs-attr">line</span>: <span class="hljs-keyword">this</span>.source.start.line
        };
        <span class="hljs-keyword">let</span> end = <span class="hljs-keyword">this</span>.source.end ? {
            <span class="hljs-attr">column</span>: <span class="hljs-keyword">this</span>.source.end.column + <span class="hljs-number">1</span>,
            <span class="hljs-attr">line</span>: <span class="hljs-keyword">this</span>.source.end.line
        } : {
            <span class="hljs-attr">column</span>: start.column + <span class="hljs-number">1</span>,
            <span class="hljs-attr">line</span>: start.line
        };
        <span class="hljs-keyword">if</span> (opts.word) {
            <span class="hljs-keyword">let</span> stringRepresentation = <span class="hljs-keyword">this</span>.toString();
            <span class="hljs-keyword">let</span> index = stringRepresentation.indexOf(opts.word);
            <span class="hljs-keyword">if</span> (index !== <span class="hljs-number">-1</span>) {
                start = <span class="hljs-keyword">this</span>.positionInside(index, stringRepresentation);
                end = <span class="hljs-keyword">this</span>.positionInside(index + opts.word.length, stringRepresentation);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (opts.start) {
                start = {
                    <span class="hljs-attr">column</span>: opts.start.column,
                    <span class="hljs-attr">line</span>: opts.start.line
                };
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opts.index) {
                start = <span class="hljs-keyword">this</span>.positionInside(opts.index);
            }
            <span class="hljs-keyword">if</span> (opts.end) {
                end = {
                    <span class="hljs-attr">column</span>: opts.end.column,
                    <span class="hljs-attr">line</span>: opts.end.line
                };
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opts.endIndex) {
                end = <span class="hljs-keyword">this</span>.positionInside(opts.endIndex);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opts.index) {
                end = <span class="hljs-keyword">this</span>.positionInside(opts.index + <span class="hljs-number">1</span>);
            }
        }
        <span class="hljs-keyword">if</span> (end.line &lt; start.line || end.line === start.line &amp;&amp; end.column &lt;= start.column) {
            end = {
                <span class="hljs-attr">column</span>: start.column + <span class="hljs-number">1</span>,
                <span class="hljs-attr">line</span>: start.line
            };
        }
        <span class="hljs-keyword">return</span> {
            end,
            start
        };
    }
    raw(prop, defaultType) {
        <span class="hljs-keyword">let</span> str = <span class="hljs-keyword">new</span> Stringifier();
        <span class="hljs-keyword">return</span> str.raw(<span class="hljs-keyword">this</span>, prop, defaultType);
    }
    remove() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent) {
            <span class="hljs-keyword">this</span>.parent.removeChild(<span class="hljs-keyword">this</span>);
        }
        <span class="hljs-keyword">this</span>.parent = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    replaceWith(...nodes) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent) {
            <span class="hljs-keyword">let</span> bookmark = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">let</span> foundSelf = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> nodes){
                <span class="hljs-keyword">if</span> (node === <span class="hljs-keyword">this</span>) {
                    foundSelf = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (foundSelf) {
                    <span class="hljs-keyword">this</span>.parent.insertAfter(bookmark, node);
                    bookmark = node;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.parent.insertBefore(bookmark, node);
                }
            }
            <span class="hljs-keyword">if</span> (!foundSelf) {
                <span class="hljs-keyword">this</span>.remove();
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    root() {
        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">while</span>(result.parent &amp;&amp; result.parent.type !== <span class="hljs-string">'document'</span>){
            result = result.parent;
        }
        <span class="hljs-keyword">return</span> result;
    }
    toJSON(_, inputs) {
        <span class="hljs-keyword">let</span> fixed = {};
        <span class="hljs-keyword">let</span> emitInputs = inputs == <span class="hljs-literal">null</span>;
        inputs = inputs || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
        <span class="hljs-keyword">let</span> inputsNextIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> name <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>){
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(<span class="hljs-keyword">this</span>, name)) {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'parent'</span> || name === <span class="hljs-string">'proxyCache'</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>[name];
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
                fixed[name] = value.map(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i === <span class="hljs-string">'object'</span> &amp;&amp; i.toJSON) {
                        <span class="hljs-keyword">return</span> i.toJSON(<span class="hljs-literal">null</span>, inputs);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> i;
                    }
                });
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value.toJSON) {
                fixed[name] = value.toJSON(<span class="hljs-literal">null</span>, inputs);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'source'</span>) {
                <span class="hljs-keyword">let</span> inputId = inputs.get(value.input);
                <span class="hljs-keyword">if</span> (inputId == <span class="hljs-literal">null</span>) {
                    inputId = inputsNextIndex;
                    inputs.set(value.input, inputsNextIndex);
                    inputsNextIndex++;
                }
                fixed[name] = {
                    <span class="hljs-attr">end</span>: value.end,
                    inputId,
                    <span class="hljs-attr">start</span>: value.start
                };
            } <span class="hljs-keyword">else</span> {
                fixed[name] = value;
            }
        }
        <span class="hljs-keyword">if</span> (emitInputs) {
            fixed.inputs = [
                ...inputs.keys()
            ].map(<span class="hljs-function">(<span class="hljs-params">input</span>)=&gt;</span>input.toJSON());
        }
        <span class="hljs-keyword">return</span> fixed;
    }
    toProxy() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.proxyCache) {
            <span class="hljs-keyword">this</span>.proxyCache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.getProxyProcessor());
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxyCache;
    }
    toString(stringifier = stringify) {
        <span class="hljs-keyword">if</span> (stringifier.stringify) stringifier = stringifier.stringify;
        <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;
        stringifier(<span class="hljs-keyword">this</span>, (i)=&gt;{
            result += i;
        });
        <span class="hljs-keyword">return</span> result;
    }
    warn(result, text, opts) {
        <span class="hljs-keyword">let</span> data = {
            <span class="hljs-attr">node</span>: <span class="hljs-keyword">this</span>
        };
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> opts)data[i] = opts[i];
        <span class="hljs-keyword">return</span> result.warn(text, data);
    }
    <span class="hljs-keyword">get</span> proxyOf() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
}
<span class="hljs-built_in">module</span>.exports = Node;
Node.default = Node;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Node = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/node.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Declaration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>{
    <span class="hljs-keyword">constructor</span>(defaults){
        <span class="hljs-keyword">if</span> (defaults &amp;&amp; <span class="hljs-keyword">typeof</span> defaults.value !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> defaults.value !== <span class="hljs-string">'string'</span>) {
            defaults = {
                ...defaults,
                <span class="hljs-attr">value</span>: <span class="hljs-built_in">String</span>(defaults.value)
            };
        }
        <span class="hljs-keyword">super</span>(defaults);
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'decl'</span>;
    }
    <span class="hljs-keyword">get</span> variable() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.prop.startsWith(<span class="hljs-string">'--'</span>) || <span class="hljs-keyword">this</span>.prop[<span class="hljs-number">0</span>] === <span class="hljs-string">'$'</span>;
    }
}
<span class="hljs-built_in">module</span>.exports = Declaration;
Declaration.default = Declaration;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-keyword">var</span> intToCharMap = <span class="hljs-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>.split(<span class="hljs-string">''</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<div class="dox">
<div class="summary">
<p>Encode an integer in the range of 0 to 63 to a single base 64 digit.
exports.encode = function(number) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= number &amp;&amp; number &lt; intToCharMap.length) {
        <span class="hljs-keyword">return</span> intToCharMap[number];
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Must be between 0 and 63: "</span> + number);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<div class="dox">
<div class="summary">
<p>Decode a single base 64 character code digit to an integer. Returns -1 on
failure.
exports.decode = function(charCode) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> bigA = <span class="hljs-number">65</span>; <span class="hljs-comment">// 'A'</span>
    <span class="hljs-keyword">var</span> bigZ = <span class="hljs-number">90</span>; <span class="hljs-comment">// 'Z'</span>
    <span class="hljs-keyword">var</span> littleA = <span class="hljs-number">97</span>; <span class="hljs-comment">// 'a'</span>
    <span class="hljs-keyword">var</span> littleZ = <span class="hljs-number">122</span>; <span class="hljs-comment">// 'z'</span>
    <span class="hljs-keyword">var</span> zero = <span class="hljs-number">48</span>; <span class="hljs-comment">// '0'</span>
    <span class="hljs-keyword">var</span> nine = <span class="hljs-number">57</span>; <span class="hljs-comment">// '9'</span>
    <span class="hljs-keyword">var</span> plus = <span class="hljs-number">43</span>; <span class="hljs-comment">// '+'</span>
    <span class="hljs-keyword">var</span> slash = <span class="hljs-number">47</span>; <span class="hljs-comment">// '/'</span>
    <span class="hljs-keyword">var</span> littleOffset = <span class="hljs-number">26</span>;
    <span class="hljs-keyword">var</span> numberOffset = <span class="hljs-number">52</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {
        <span class="hljs-keyword">return</span> charCode - bigA;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>26 - 51: abcdefghijklmnopqrstuvwxyz</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {
        <span class="hljs-keyword">return</span> charCode - littleA + littleOffset;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>52 - 61: 0123456789</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {
        <span class="hljs-keyword">return</span> charCode - zero + numberOffset;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>62: +</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (charCode == plus) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">62</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>63: /</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (charCode == slash) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">63</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Invalid base64 digit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
};
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span> <span class="hljs-keyword">var</span> base64 = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)"</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>A single base 64 digit can contain 6 bits of data. For the base 64 variable
length quantities we use in the source map spec, the first bit is the sign,
the next four bits are the actual value, and the 6th bit is the
continuation bit. The continuation bit tells us whether there are more
digits in this value following this digit.</p>
<p>Continuation
|    Sign
|    |
V    V
101011</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> VLQ_BASE_SHIFT = <span class="hljs-number">5</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>binary: 100000</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> VLQ_BASE = <span class="hljs-number">1</span> &lt;&lt; VLQ_BASE_SHIFT;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>binary: 011111</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> VLQ_BASE_MASK = VLQ_BASE - <span class="hljs-number">1</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>binary: 100000</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> VLQ_CONTINUATION_BIT = VLQ_BASE;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<div class="dox">
<div class="summary">
<p>Converts from a two-complement value to a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
function toVLQSigned(aValue) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> aValue &lt; <span class="hljs-number">0</span> ? (-aValue &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> : (aValue &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">0</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<div class="dox">
<div class="summary">
<p>Converts to a two-complement value from a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
2 (10 binary) becomes 1, 3 (11 binary) becomes -1
4 (100 binary) becomes 2, 5 (101 binary) becomes -2
function fromVLQSigned(aValue) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> isNegative = (aValue &amp; <span class="hljs-number">1</span>) === <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> shifted = aValue &gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> isNegative ? -shifted : shifted;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the base 64 VLQ encoded value.
exports.encode = function base64VLQ_encode(aValue) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> encoded = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">var</span> digit;
    <span class="hljs-keyword">var</span> vlq = toVLQSigned(aValue);
    <span class="hljs-keyword">do</span> {
        digit = vlq &amp; VLQ_BASE_MASK;
        vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT;
        <span class="hljs-keyword">if</span> (vlq &gt; <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>There are still more digits in this value, so we must make sure the
continuation bit is marked.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    }<span class="hljs-keyword">while</span> (vlq &gt; <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> encoded;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<div class="dox">
<div class="summary">
<p>Decodes the next base 64 VLQ value from the given string and returns the
value and the rest of the string via the out parameter.
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> strLen = aStr.length;
    <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> shift = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> continuation, digit;
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (aIndex &gt;= strLen) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected more digits in base 64 VLQ value."</span>);
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        <span class="hljs-keyword">if</span> (digit === <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid base64 digit: "</span> + aStr.charAt(aIndex - <span class="hljs-number">1</span>));
        }
        continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);
        digit &amp;= VLQ_BASE_MASK;
        result = result + (digit &lt;&lt; shift);
        shift += VLQ_BASE_SHIFT;
    }<span class="hljs-keyword">while</span> (continuation)
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-comment">/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * <span class="hljs-doctag">@param </span>args The object we are extracting values from
 * <span class="hljs-doctag">@param </span>name The name of the property we are getting.
 * <span class="hljs-doctag">@param </span>defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArg</span>(<span class="hljs-params">aArgs, aName, aDefaultValue</span>) </span>{
    <span class="hljs-keyword">if</span> (aName <span class="hljs-keyword">in</span> aArgs) {
        <span class="hljs-keyword">return</span> aArgs[aName];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">return</span> aDefaultValue;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'"'</span> + aName + <span class="hljs-string">'" is a required argument.'</span>);
    }
}
exports.getArg = getArg;
<span class="hljs-keyword">var</span> urlRegexp = <span class="hljs-regexp">/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/</span>;
<span class="hljs-keyword">var</span> dataUrlRegexp = <span class="hljs-regexp">/^data:.+\,.+$/</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlParse</span>(<span class="hljs-params">aUrl</span>) </span>{
    <span class="hljs-keyword">var</span> match = aUrl.match(urlRegexp);
    <span class="hljs-keyword">if</span> (!match) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">scheme</span>: match[<span class="hljs-number">1</span>],
        <span class="hljs-attr">auth</span>: match[<span class="hljs-number">2</span>],
        <span class="hljs-attr">host</span>: match[<span class="hljs-number">3</span>],
        <span class="hljs-attr">port</span>: match[<span class="hljs-number">4</span>],
        <span class="hljs-attr">path</span>: match[<span class="hljs-number">5</span>]
    };
}
exports.urlParse = urlParse;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlGenerate</span>(<span class="hljs-params">aParsedUrl</span>) </span>{
    <span class="hljs-keyword">var</span> url = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + <span class="hljs-string">':'</span>;
    }
    url += <span class="hljs-string">'//'</span>;
    <span class="hljs-keyword">if</span> (aParsedUrl.auth) {
        url += aParsedUrl.auth + <span class="hljs-string">'@'</span>;
    }
    <span class="hljs-keyword">if</span> (aParsedUrl.host) {
        url += aParsedUrl.host;
    }
    <span class="hljs-keyword">if</span> (aParsedUrl.port) {
        url += <span class="hljs-string">":"</span> + aParsedUrl.port;
    }
    <span class="hljs-keyword">if</span> (aParsedUrl.path) {
        url += aParsedUrl.path;
    }
    <span class="hljs-keyword">return</span> url;
}
exports.urlGenerate = urlGenerate;
<span class="hljs-keyword">var</span> MAX_CACHED_INPUTS = <span class="hljs-number">32</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<div class="dox">
<div class="summary">
<p>Takes some function <code>f(input) -&gt; result</code> and returns a memoized version of
<code>f</code>.</p>
</div>
<div class="body">
<p>We keep at most <code>MAX_CACHED_INPUTS</code> memoized results of <code>f</code> alive. The
memoization is a dumb-simple, linear least-recently-used cache.
function lruMemoize(f) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> cache = [];
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cache.length; i++){
            <span class="hljs-keyword">if</span> (cache[i].input === input) {
                <span class="hljs-keyword">var</span> temp = cache[<span class="hljs-number">0</span>];
                cache[<span class="hljs-number">0</span>] = cache[i];
                cache[i] = temp;
                <span class="hljs-keyword">return</span> cache[<span class="hljs-number">0</span>].result;
            }
        }
        <span class="hljs-keyword">var</span> result = f(input);
        cache.unshift({
            input,
            result
        });
        <span class="hljs-keyword">if</span> (cache.length &gt; MAX_CACHED_INPUTS) {
            cache.pop();
        }
        <span class="hljs-keyword">return</span> result;
    };
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<div class="dox">
<div class="summary">
<p>Normalizes a path, or the path portion of a URL:</p>
</div>
<div class="body">
<ul>
<li>Replaces consecutive slashes with one slash.</li>
<li>Removes unnecessary '.' parts.</li>
<li>Removes unnecessary '<dir>/..' parts.</li>
</ul>
<p>Based on code in the Node.js 'path' core module.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aPath</span>
<span>The path or url to normalize. var normalize = lruMemoize(function normalize(aPath) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> path = aPath;
    <span class="hljs-keyword">var</span> url = urlParse(aPath);
    <span class="hljs-keyword">if</span> (url) {
        <span class="hljs-keyword">if</span> (!url.path) {
            <span class="hljs-keyword">return</span> aPath;
        }
        path = url.path;
    }
    <span class="hljs-keyword">var</span> isAbsolute = exports.isAbsolute(path);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>Split the path into parts between <code>/</code> characters. This is much faster than
using <code>.split(/\/+/g)</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> parts = [];
    <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
        start = i;
        i = path.indexOf(<span class="hljs-string">"/"</span>, start);
        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">-1</span>) {
            parts.push(path.slice(start));
            <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> {
            parts.push(path.slice(start, i));
            <span class="hljs-keyword">while</span>(i &lt; path.length &amp;&amp; path[i] === <span class="hljs-string">"/"</span>){
                i++;
            }
        }
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> part, up = <span class="hljs-number">0</span>, i = parts.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
        part = parts[i];
        <span class="hljs-keyword">if</span> (part === <span class="hljs-string">'.'</span>) {
            parts.splice(i, <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (part === <span class="hljs-string">'..'</span>) {
            up++;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (up &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (part === <span class="hljs-string">''</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>The first part is blank if the path is absolute. Trying to go
above the root is a no-op. Therefore we can remove all '..' parts
directly after the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                parts.splice(i + <span class="hljs-number">1</span>, up);
                up = <span class="hljs-number">0</span>;
            } <span class="hljs-keyword">else</span> {
                parts.splice(i, <span class="hljs-number">2</span>);
                up--;
            }
        }
    }
    path = parts.join(<span class="hljs-string">'/'</span>);
    <span class="hljs-keyword">if</span> (path === <span class="hljs-string">''</span>) {
        path = isAbsolute ? <span class="hljs-string">'/'</span> : <span class="hljs-string">'.'</span>;
    }
    <span class="hljs-keyword">if</span> (url) {
        url.path = path;
        <span class="hljs-keyword">return</span> urlGenerate(url);
    }
    <span class="hljs-keyword">return</span> path;
});
exports.normalize = normalize;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<div class="dox">
<div class="summary">
<p>Joins two paths/URLs.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aRoot</span>
<span>The root path or URL.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aPath</span>
<span>The path or URL to be joined with the root.
<ul>
<li>If aPath is a URL or a data URI, aPath is returned, unless aPath is a
scheme-relative URL: Then the scheme of aRoot, if any, is prepended
first.</li>
<li>Otherwise aPath is a path. If aRoot is a URL, then its path portion
is updated with the result and aRoot is returned. Otherwise the result
is returned.
<ul>
<li>If aPath is absolute, the result is aPath.</li>
<li>Otherwise the two paths are joined with a slash.</li>
</ul>
</li>
<li>Joining for example 'http://' and 'www.example.com' is also supported.
function join(aRoot, aPath) {</li>
</ul>
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aRoot === <span class="hljs-string">""</span>) {
        aRoot = <span class="hljs-string">"."</span>;
    }
    <span class="hljs-keyword">if</span> (aPath === <span class="hljs-string">""</span>) {
        aPath = <span class="hljs-string">"."</span>;
    }
    <span class="hljs-keyword">var</span> aPathUrl = urlParse(aPath);
    <span class="hljs-keyword">var</span> aRootUrl = urlParse(aRoot);
    <span class="hljs-keyword">if</span> (aRootUrl) {
        aRoot = aRootUrl.path || <span class="hljs-string">'/'</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p><code>join(foo, '//www.example.org')</code></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aPathUrl &amp;&amp; !aPathUrl.scheme) {
        <span class="hljs-keyword">if</span> (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
        }
        <span class="hljs-keyword">return</span> urlGenerate(aPathUrl);
    }
    <span class="hljs-keyword">if</span> (aPathUrl || aPath.match(dataUrlRegexp)) {
        <span class="hljs-keyword">return</span> aPath;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p><code>join('http://', 'www.example.com')</code></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {
        aRootUrl.host = aPath;
        <span class="hljs-keyword">return</span> urlGenerate(aRootUrl);
    }
    <span class="hljs-keyword">var</span> joined = aPath.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'/'</span> ? aPath : normalize(aRoot.replace(<span class="hljs-regexp">/\/+$/</span>, <span class="hljs-string">''</span>) + <span class="hljs-string">'/'</span> + aPath);
    <span class="hljs-keyword">if</span> (aRootUrl) {
        aRootUrl.path = joined;
        <span class="hljs-keyword">return</span> urlGenerate(aRootUrl);
    }
    <span class="hljs-keyword">return</span> joined;
}
exports.join = join;
exports.isAbsolute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aPath</span>) </span>{
    <span class="hljs-keyword">return</span> aPath.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'/'</span> || urlRegexp.test(aPath);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<div class="dox">
<div class="summary">
<p>Make a path relative to a URL or another path.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aRoot</span>
<span>The root path or URL.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aPath</span>
<span>The path or URL to be made relative to aRoot. function relative(aRoot, aPath) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aRoot === <span class="hljs-string">""</span>) {
        aRoot = <span class="hljs-string">"."</span>;
    }
    aRoot = aRoot.replace(<span class="hljs-regexp">/\/$/</span>, <span class="hljs-string">''</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>It is possible for the path to be above the root. In this case, simply
checking whether the root is a prefix of the path won't work. Instead, we
need to remove components from the root one by one, until either we find
a prefix that fits, or we run out of components to remove.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> level = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(aPath.indexOf(aRoot + <span class="hljs-string">'/'</span>) !== <span class="hljs-number">0</span>){
        <span class="hljs-keyword">var</span> index = aRoot.lastIndexOf(<span class="hljs-string">"/"</span>);
        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> aPath;
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>If the only part of the root that is left is the scheme (i.e. http://,
file:///, etc.), one or more slashes (/), or simply nothing at all, we
have exhausted all components, so the path is not relative to the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        aRoot = aRoot.slice(<span class="hljs-number">0</span>, index);
        <span class="hljs-keyword">if</span> (aRoot.match(<span class="hljs-regexp">/^([^\/]+:\/)?\/*$/</span>)) {
            <span class="hljs-keyword">return</span> aPath;
        }
        ++level;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>Make sure we add a &quot;../&quot; for each component we removed from the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(level + <span class="hljs-number">1</span>).join(<span class="hljs-string">"../"</span>) + aPath.substr(aRoot.length + <span class="hljs-number">1</span>);
}
exports.relative = relative;
<span class="hljs-keyword">var</span> supportsNullProto = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">return</span> !(<span class="hljs-string">'__proto__'</span> <span class="hljs-keyword">in</span> obj);
}();
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">return</span> s;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<div class="dox">
<div class="summary">
<p>Because behavior goes wacky when you set <code>__proto__</code> on objects, we
have to prefix all the strings in our set with an arbitrary character.</p>
</div>
<div class="body">
<p>See https://github.com/mozilla/source-map/pull/31 and
https://github.com/mozilla/source-map/issues/30</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">String</span>
<span>aStr function toSetString(aStr) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (isProtoString(aStr)) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'$'</span> + aStr;
    }
    <span class="hljs-keyword">return</span> aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromSetString</span>(<span class="hljs-params">aStr</span>) </span>{
    <span class="hljs-keyword">if</span> (isProtoString(aStr)) {
        <span class="hljs-keyword">return</span> aStr.slice(<span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isProtoString</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">if</span> (!s) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">var</span> length = s.length;
    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">9</span> <span class="hljs-comment">/* "__proto__".length */</span> ) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span> (s.charCodeAt(length - <span class="hljs-number">1</span>) !== <span class="hljs-number">95</span> <span class="hljs-comment">/* '_' */</span>  || s.charCodeAt(length - <span class="hljs-number">2</span>) !== <span class="hljs-number">95</span> <span class="hljs-comment">/* '_' */</span>  || s.charCodeAt(length - <span class="hljs-number">3</span>) !== <span class="hljs-number">111</span> <span class="hljs-comment">/* 'o' */</span>  || s.charCodeAt(length - <span class="hljs-number">4</span>) !== <span class="hljs-number">116</span> <span class="hljs-comment">/* 't' */</span>  || s.charCodeAt(length - <span class="hljs-number">5</span>) !== <span class="hljs-number">111</span> <span class="hljs-comment">/* 'o' */</span>  || s.charCodeAt(length - <span class="hljs-number">6</span>) !== <span class="hljs-number">114</span> <span class="hljs-comment">/* 'r' */</span>  || s.charCodeAt(length - <span class="hljs-number">7</span>) !== <span class="hljs-number">112</span> <span class="hljs-comment">/* 'p' */</span>  || s.charCodeAt(length - <span class="hljs-number">8</span>) !== <span class="hljs-number">95</span> <span class="hljs-comment">/* '_' */</span>  || s.charCodeAt(length - <span class="hljs-number">9</span>) !== <span class="hljs-number">95</span> <span class="hljs-comment">/* '_' */</span> ) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = length - <span class="hljs-number">10</span>; i &gt;= <span class="hljs-number">0</span>; i--){
        <span class="hljs-keyword">if</span> (s.charCodeAt(i) !== <span class="hljs-number">36</span> <span class="hljs-comment">/* '$' */</span> ) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<div class="dox">
<div class="summary">
<p>Comparator between two mappings where the original positions are compared.</p>
</div>
<div class="body">
<p>Optionally pass in <code>true</code> as <code>onlyCompareGenerated</code> to consider two
mappings with the same original source/line/column, but different generated
line and column the same. Useful when searching for a mapping with a
stubbed out mapping.
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> cmp = strcmp(mappingA.source, mappingB.source);
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span> || onlyCompareOriginal) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    <span class="hljs-keyword">return</span> strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareByOriginalPositionsNoSource</span>(<span class="hljs-params">mappingA, mappingB, onlyCompareOriginal</span>) </span>{
    <span class="hljs-keyword">var</span> cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span> || onlyCompareOriginal) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    <span class="hljs-keyword">return</span> strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<div class="dox">
<div class="summary">
<p>Comparator between two mappings with deflated source and name indices where
the generated positions are compared.</p>
</div>
<div class="body">
<p>Optionally pass in <code>true</code> as <code>onlyCompareGenerated</code> to consider two
mappings with the same generated line and column, but different
source/name/original line and column the same. Useful when searching for a
mapping with a stubbed out mapping.
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> cmp = mappingA.generatedLine - mappingB.generatedLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span> || onlyCompareGenerated) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    <span class="hljs-keyword">return</span> strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareByGeneratedPositionsDeflatedNoLine</span>(<span class="hljs-params">mappingA, mappingB, onlyCompareGenerated</span>) </span>{
    <span class="hljs-keyword">var</span> cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span> || onlyCompareGenerated) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    <span class="hljs-keyword">return</span> strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strcmp</span>(<span class="hljs-params">aStr1, aStr2</span>) </span>{
    <span class="hljs-keyword">if</span> (aStr1 === aStr2) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span> (aStr1 === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// aStr2 !== null</span>
    }
    <span class="hljs-keyword">if</span> (aStr2 === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// aStr1 !== null</span>
    }
    <span class="hljs-keyword">if</span> (aStr1 &gt; aStr2) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<div class="dox">
<div class="summary">
<p>Comparator between two mappings with inflated source and name strings where
the generated positions are compared.
function compareByGeneratedPositionsInflated(mappingA, mappingB) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> cmp = mappingA.generatedLine - mappingB.generatedLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    <span class="hljs-keyword">if</span> (cmp !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> cmp;
    }
    <span class="hljs-keyword">return</span> strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<div class="dox">
<div class="summary">
<p>Strip any JSON XSSI avoidance prefix from the string (as documented
in the source maps specification), and then parse the string as
JSON.
function parseSourceMapInput(str) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(str.replace(<span class="hljs-regexp">/^\)]}'[^\n]*\n/</span>, <span class="hljs-string">''</span>));
}
exports.parseSourceMapInput = parseSourceMapInput;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<div class="dox">
<div class="summary">
<p>Compute the URL of a source given the the source root, the source's
URL, and the source map's URL.
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    sourceURL = sourceURL || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (sourceRoot) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>This follows what Chrome does.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (sourceRoot[sourceRoot.length - <span class="hljs-number">1</span>] !== <span class="hljs-string">'/'</span> &amp;&amp; sourceURL[<span class="hljs-number">0</span>] !== <span class="hljs-string">'/'</span>) {
            sourceRoot += <span class="hljs-string">'/'</span>;
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>The spec says:
Line 4: An optional source root, useful for relocating source
files on a server or removing repeated values in the
sources entry.  This value is prepended to the individual
entries in the source field.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        sourceURL = sourceRoot + sourceURL;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>Historically, SourceMapConsumer did not take the sourceMapURL as
a parameter.  This mode is still somewhat supported, which is why
this code block is conditional.  However, it's preferable to pass
the source map URL to SourceMapConsumer, so that this function
can implement the source URL resolution algorithm as outlined in
the spec.  This block is basically the equivalent of:
new URL(sourceURL, sourceMapURL).toString()
... except it avoids using URL, which wasn't available in the
older releases of node still supported by this library.</p>
<p>The spec says:
If the sources are not absolute URLs after prepending of the
sourceRoot, the sources are resolved relative to the
SourceMap (like resolving script src in a html document).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (sourceMapURL) {
        <span class="hljs-keyword">var</span> parsed = urlParse(sourceMapURL);
        <span class="hljs-keyword">if</span> (!parsed) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"sourceMapURL could not be parsed"</span>);
        }
        <span class="hljs-keyword">if</span> (parsed.path) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>Strip the last path component, but keep the &quot;/&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> index = parsed.path.lastIndexOf(<span class="hljs-string">'/'</span>);
            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
                parsed.path = parsed.path.substring(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>);
            }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    <span class="hljs-keyword">return</span> normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-keyword">var</span> util = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">var</span> has = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
<span class="hljs-keyword">var</span> hasNativeMap = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Map</span> !== <span class="hljs-string">"undefined"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<div class="dox">
<div class="summary">
<p>A data structure which is a combination of an array and a set. Adding a new
member is O(1), testing for membership is O(1), and finding the index of an
element is O(1). Removing elements from the set is not supported. Only
strings are supported for membership.
function ArraySet() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._array = [];
    <span class="hljs-keyword">this</span>._set = hasNativeMap ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>() : <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<div class="dox">
<div class="summary">
<p>Static method for creating ArraySet instances from an existing array.
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span> = new ArraySet();
    for(var i = 0, len = aArray.length; i &lt; len; i++){
        <span class="hljs-keyword">set</span>.add(aArray[i], aAllowDuplicates);
    }
    return <span class="hljs-keyword">set</span>;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return how many unique items are in this ArraySet. If duplicates have been
added, than those do not count towards the size.</p>
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> hasNativeMap ? <span class="hljs-keyword">this</span>._set.size : <span class="hljs-built_in">Object</span>.getOwnPropertyNames(<span class="hljs-keyword">this</span>._set).length;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<div class="dox">
<div class="summary">
<p>Add the given string to this set.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">String</span>
<span>aStr ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    <span class="hljs-keyword">var</span> isDuplicate = hasNativeMap ? <span class="hljs-keyword">this</span>.has(aStr) : has.call(<span class="hljs-keyword">this</span>._set, sStr);
    <span class="hljs-keyword">var</span> idx = <span class="hljs-keyword">this</span>._array.length;
    <span class="hljs-keyword">if</span> (!isDuplicate || aAllowDuplicates) {
        <span class="hljs-keyword">this</span>._array.push(aStr);
    }
    <span class="hljs-keyword">if</span> (!isDuplicate) {
        <span class="hljs-keyword">if</span> (hasNativeMap) {
            <span class="hljs-keyword">this</span>._set.set(aStr, idx);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._set[sStr] = idx;
        }
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<div class="dox">
<div class="summary">
<p>Is the given string a member of this set?</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">String</span>
<span>aStr ArraySet.prototype.has = function ArraySet_has(aStr) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (hasNativeMap) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._set.has(aStr);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> sStr = util.toSetString(aStr);
        <span class="hljs-keyword">return</span> has.call(<span class="hljs-keyword">this</span>._set, sStr);
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<div class="dox">
<div class="summary">
<p>What is the index of the given string in the array?</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">String</span>
<span>aStr ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (hasNativeMap) {
        <span class="hljs-keyword">var</span> idx = <span class="hljs-keyword">this</span>._set.get(aStr);
        <span class="hljs-keyword">if</span> (idx &gt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> idx;
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> sStr = util.toSetString(aStr);
        <span class="hljs-keyword">if</span> (has.call(<span class="hljs-keyword">this</span>._set, sStr)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._set[sStr];
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'"'</span> + aStr + <span class="hljs-string">'" is not in the set.'</span>);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<div class="dox">
<div class="summary">
<p>What is the element at the given index?</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">Number</span>
<span>aIdx ArraySet.prototype.at = function ArraySet_at(aIdx) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aIdx &gt;= <span class="hljs-number">0</span> &amp;&amp; aIdx &lt; <span class="hljs-keyword">this</span>._array.length) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._array[aIdx];
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No element indexed by '</span> + aIdx);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the array representation of this set (which has the proper indices
indicated by indexOf). Note that this is a copy of the internal array used
for storing the members so that no one can mess with internal state.
ArraySet.prototype.toArray = function ArraySet_toArray() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._array.slice();
};
exports.ArraySet = ArraySet;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-keyword">var</span> util = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)"</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<div class="dox">
<div class="summary">
<p>Determine whether mappingB is after mappingA with respect to generated
position.
function generatedPositionAfter(mappingA, mappingB) {</p>
</div>
<div class="body">
</div>
</div>
Optimized for most common case

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> lineA = mappingA.generatedLine;
    <span class="hljs-keyword">var</span> lineB = mappingB.generatedLine;
    <span class="hljs-keyword">var</span> columnA = mappingA.generatedColumn;
    <span class="hljs-keyword">var</span> columnB = mappingB.generatedColumn;
    <span class="hljs-keyword">return</span> lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) &lt;= <span class="hljs-number">0</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<div class="dox">
<div class="summary">
<p>A data structure to provide a sorted view of accumulated mappings in a
performance conscious manner. It trades a neglibable overhead in general
case for a large speedup in case of mappings being added in order.
function MappingList() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._array = [];
    <span class="hljs-keyword">this</span>._sorted = <span class="hljs-literal">true</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<p>Serves as infimum</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._last = {
        <span class="hljs-attr">generatedLine</span>: <span class="hljs-number">-1</span>,
        <span class="hljs-attr">generatedColumn</span>: <span class="hljs-number">0</span>
    };
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<div class="dox">
<div class="summary">
<p>Iterate through internal items. This method takes the same arguments that
<code>Array.prototype.forEach</code> takes.</p>
</div>
<div class="body">
<p>NOTE: The order of the mappings is NOT guaranteed.
MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._array.forEach(aCallback, aThisArg);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<div class="dox">
<div class="summary">
<p>Add the given source mapping.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">Object</span>
<span>aMapping MappingList.prototype.add = function MappingList_add(aMapping) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (generatedPositionAfter(<span class="hljs-keyword">this</span>._last, aMapping)) {
        <span class="hljs-keyword">this</span>._last = aMapping;
        <span class="hljs-keyword">this</span>._array.push(aMapping);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>._sorted = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>._array.push(aMapping);
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-58" id="section-58"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the flat, sorted array of mappings. The mappings are sorted by
generated position.</p>
</div>
<div class="body">
<p>WARNING: This method returns internal data without copying, for
performance. The return value must NOT be mutated, and should be treated as
an immutable borrow. If you want to take ownership, you must make your own
copy.
MappingList.prototype.toArray = function MappingList_toArray() {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._sorted) {
        <span class="hljs-keyword">this</span>._array.sort(util.compareByGeneratedPositionsInflated);
        <span class="hljs-keyword">this</span>._sorted = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._array;
};
exports.MappingList = MappingList;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-keyword">var</span> base64VLQ = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">var</span> util = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">var</span> ArraySet = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)"</span>).ArraySet;
<span class="hljs-keyword">var</span> MappingList = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)"</span>).MappingList;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-59" id="section-59"></a>
</div>
<div class="dox">
<div class="summary">
<p>An instance of the SourceMapGenerator represents a source map which is
being built incrementally. You may pass an object with the following
properties:</p>
</div>
<div class="body">
<ul>
<li>file: The filename of the generated source.
<ul>
<li>sourceRoot: A root for all relative URLs in this source map.
function SourceMapGenerator(aArgs) {</li>
</ul>
</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!aArgs) {
        aArgs = {};
    }
    <span class="hljs-keyword">this</span>._file = util.getArg(aArgs, <span class="hljs-string">'file'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">this</span>._sourceRoot = util.getArg(aArgs, <span class="hljs-string">'sourceRoot'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">this</span>._skipValidation = util.getArg(aArgs, <span class="hljs-string">'skipValidation'</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">this</span>._ignoreInvalidMapping = util.getArg(aArgs, <span class="hljs-string">'ignoreInvalidMapping'</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">this</span>._sources = <span class="hljs-keyword">new</span> ArraySet();
    <span class="hljs-keyword">this</span>._names = <span class="hljs-keyword">new</span> ArraySet();
    <span class="hljs-keyword">this</span>._mappings = <span class="hljs-keyword">new</span> MappingList();
    <span class="hljs-keyword">this</span>._sourcesContents = <span class="hljs-literal">null</span>;
}
SourceMapGenerator.prototype._version = <span class="hljs-number">3</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates a new SourceMapGenerator based on a SourceMapConsumer</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSourceMapConsumer</span>
<span>The SourceMap. SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> sourceRoot = aSourceMapConsumer.sourceRoot;
    <span class="hljs-keyword">var</span> generator = <span class="hljs-keyword">new</span> SourceMapGenerator(<span class="hljs-built_in">Object</span>.assign(generatorOps || {}, {
        <span class="hljs-attr">file</span>: aSourceMapConsumer.file,
        <span class="hljs-attr">sourceRoot</span>: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mapping</span>) </span>{
        <span class="hljs-keyword">var</span> newMapping = {
            <span class="hljs-attr">generated</span>: {
                <span class="hljs-attr">line</span>: mapping.generatedLine,
                <span class="hljs-attr">column</span>: mapping.generatedColumn
            }
        };
        <span class="hljs-keyword">if</span> (mapping.source != <span class="hljs-literal">null</span>) {
            newMapping.source = mapping.source;
            <span class="hljs-keyword">if</span> (sourceRoot != <span class="hljs-literal">null</span>) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
                <span class="hljs-attr">line</span>: mapping.originalLine,
                <span class="hljs-attr">column</span>: mapping.originalColumn
            };
            <span class="hljs-keyword">if</span> (mapping.name != <span class="hljs-literal">null</span>) {
                newMapping.name = mapping.name;
            }
        }
        generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sourceFile</span>) </span>{
        <span class="hljs-keyword">var</span> sourceRelative = sourceFile;
        <span class="hljs-keyword">if</span> (sourceRoot !== <span class="hljs-literal">null</span>) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        <span class="hljs-keyword">if</span> (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
        }
        <span class="hljs-keyword">var</span> content = aSourceMapConsumer.sourceContentFor(sourceFile);
        <span class="hljs-keyword">if</span> (content != <span class="hljs-literal">null</span>) {
            generator.setSourceContent(sourceFile, content);
        }
    });
    <span class="hljs-keyword">return</span> generator;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-61" id="section-61"></a>
</div>
<div class="dox">
<div class="summary">
<p>Add a single mapping from original source line and column to the generated
source's line and column for this source map being created. The mapping
object should have the following properties:</p>
</div>
<div class="body">
<ul>
<li>generated: An object with the generated line and column positions.
<ul>
<li>original: An object with the original line and column positions.</li>
<li>source: The original source file (relative to the sourceRoot).</li>
<li>name: An optional original token name for this mapping.
SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {</li>
</ul>
</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> generated = util.getArg(aArgs, <span class="hljs-string">'generated'</span>);
    <span class="hljs-keyword">var</span> original = util.getArg(aArgs, <span class="hljs-string">'original'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> source = util.getArg(aArgs, <span class="hljs-string">'source'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> name = util.getArg(aArgs, <span class="hljs-string">'name'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._skipValidation) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._validateMapping(generated, original, source, name) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-keyword">if</span> (source != <span class="hljs-literal">null</span>) {
        source = <span class="hljs-built_in">String</span>(source);
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._sources.has(source)) {
            <span class="hljs-keyword">this</span>._sources.add(source);
        }
    }
    <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span>) {
        name = <span class="hljs-built_in">String</span>(name);
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._names.has(name)) {
            <span class="hljs-keyword">this</span>._names.add(name);
        }
    }
    <span class="hljs-keyword">this</span>._mappings.add({
        <span class="hljs-attr">generatedLine</span>: generated.line,
        <span class="hljs-attr">generatedColumn</span>: generated.column,
        <span class="hljs-attr">originalLine</span>: original != <span class="hljs-literal">null</span> &amp;&amp; original.line,
        <span class="hljs-attr">originalColumn</span>: original != <span class="hljs-literal">null</span> &amp;&amp; original.column,
        <span class="hljs-attr">source</span>: source,
        <span class="hljs-attr">name</span>: name
    });
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-62" id="section-62"></a>
</div>
<div class="dox">
<div class="summary">
<p>Set the source content for a source file.
SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> source = aSourceFile;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._sourceRoot != <span class="hljs-literal">null</span>) {
        source = util.relative(<span class="hljs-keyword">this</span>._sourceRoot, source);
    }
    <span class="hljs-keyword">if</span> (aSourceContent != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-63" id="section-63"></a>
</div>
<p>Add the source content to the _sourcesContents map.
Create a new _sourcesContents map if the property is null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._sourcesContents) {
            <span class="hljs-keyword">this</span>._sourcesContents = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
        }
        <span class="hljs-keyword">this</span>._sourcesContents[util.toSetString(source)] = aSourceContent;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._sourcesContents) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-64" id="section-64"></a>
</div>
<p>Remove the source file from the _sourcesContents map.
If the _sourcesContents map is empty, set the property to null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._sourcesContents[util.toSetString(source)];
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>._sourcesContents).length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>._sourcesContents = <span class="hljs-literal">null</span>;
        }
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-65" id="section-65"></a>
</div>
<div class="dox">
<div class="summary">
<p>Applies the mappings of a sub-source-map for a specific source file to the
source map being generated. Each mapping to the supplied source file is
rewritten using the supplied source map. Note: The resolution for the
resulting mappings is the minimium of this map and the supplied map.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSourceMapConsumer</span>
<span>The source map to be applied.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSourceFile</span>
<span>Optional. The filename of the source file.        If omitted, SourceMapConsumer's file property will be used.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSourceMapPath</span>
<span>Optional. The dirname of the path to the source map        to be applied. If relative, it is relative to the SourceMapConsumer.
This parameter is needed when the two source maps aren't in the same
directory, and the source map to be applied contains relative source
paths. If so, those relative source paths need to be rewritten
relative to the SourceMapGenerator.
SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> sourceFile = aSourceFile;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-66" id="section-66"></a>
</div>
<p>If aSourceFile is omitted, we will use the file property of the SourceMap</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aSourceFile == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (aSourceMapConsumer.file == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, '</span> + <span class="hljs-string">'or the source map\'s "file" property. Both were omitted.'</span>);
        }
        sourceFile = aSourceMapConsumer.file;
    }
    <span class="hljs-keyword">var</span> sourceRoot = <span class="hljs-keyword">this</span>._sourceRoot;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-67" id="section-67"></a>
</div>
<p>Make &quot;sourceFile&quot; relative if an absolute Url is passed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (sourceRoot != <span class="hljs-literal">null</span>) {
        sourceFile = util.relative(sourceRoot, sourceFile);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-68" id="section-68"></a>
</div>
<p>Applying the SourceMap can add and remove items from the sources and
the names array.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> newSources = <span class="hljs-keyword">new</span> ArraySet();
    <span class="hljs-keyword">var</span> newNames = <span class="hljs-keyword">new</span> ArraySet();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-69" id="section-69"></a>
</div>
<p>Find mappings for the &quot;sourceFile&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._mappings.unsortedForEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mapping</span>) </span>{
        <span class="hljs-keyword">if</span> (mapping.source === sourceFile &amp;&amp; mapping.originalLine != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-70" id="section-70"></a>
</div>
<p>Check if it can be mapped by the source map, then update the mapping.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> original = aSourceMapConsumer.originalPositionFor({
                <span class="hljs-attr">line</span>: mapping.originalLine,
                <span class="hljs-attr">column</span>: mapping.originalColumn
            });
            <span class="hljs-keyword">if</span> (original.source != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-71" id="section-71"></a>
</div>
<p>Copy mapping</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                mapping.source = original.source;
                <span class="hljs-keyword">if</span> (aSourceMapPath != <span class="hljs-literal">null</span>) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                <span class="hljs-keyword">if</span> (sourceRoot != <span class="hljs-literal">null</span>) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                <span class="hljs-keyword">if</span> (original.name != <span class="hljs-literal">null</span>) {
                    mapping.name = original.name;
                }
            }
        }
        <span class="hljs-keyword">var</span> source = mapping.source;
        <span class="hljs-keyword">if</span> (source != <span class="hljs-literal">null</span> &amp;&amp; !newSources.has(source)) {
            newSources.add(source);
        }
        <span class="hljs-keyword">var</span> name = mapping.name;
        <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span> &amp;&amp; !newNames.has(name)) {
            newNames.add(name);
        }
    }, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>._sources = newSources;
    <span class="hljs-keyword">this</span>._names = newNames;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-72" id="section-72"></a>
</div>
<p>Copy sourcesContents of applied map.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    aSourceMapConsumer.sources.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sourceFile</span>) </span>{
        <span class="hljs-keyword">var</span> content = aSourceMapConsumer.sourceContentFor(sourceFile);
        <span class="hljs-keyword">if</span> (content != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (aSourceMapPath != <span class="hljs-literal">null</span>) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            <span class="hljs-keyword">if</span> (sourceRoot != <span class="hljs-literal">null</span>) {
                sourceFile = util.relative(sourceRoot, sourceFile);
            }
            <span class="hljs-keyword">this</span>.setSourceContent(sourceFile, content);
        }
    }, <span class="hljs-keyword">this</span>);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-73" id="section-73"></a>
</div>
<div class="dox">
<div class="summary">
<p>A mapping can have one of the three levels of data:</p>
</div>
<div class="body">
<ol>
<li>Just the generated position.</li>
<li>The Generated position, original position, and original source.</li>
<li>Generated and original position, original source, as well as a name
token.</li>
</ol>
<p>To maintain consistency, we validate that any new mapping being added falls
in to one of these categories.
SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {</p>
</div>
</div>
When aOriginal is truthy but has empty values for .line and .column,
it is most likely a programmer error. In this case we throw a very
specific error message to try to guide them the right way.
For example: https://github.com/Polymer/polymer-bundler/pull/519

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aOriginal &amp;&amp; <span class="hljs-keyword">typeof</span> aOriginal.line !== <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> aOriginal.column !== <span class="hljs-string">'number'</span>) {
        <span class="hljs-keyword">var</span> message = <span class="hljs-string">'original.line and original.column are not numbers -- you probably meant to omit '</span> + <span class="hljs-string">'the original mapping entirely and only map the generated position. If so, pass '</span> + <span class="hljs-string">'null for the original mapping instead of an object with empty or null values.'</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._ignoreInvalidMapping) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">console</span>.warn) {
                <span class="hljs-built_in">console</span>.warn(message);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
        }
    }
    <span class="hljs-keyword">if</span> (aGenerated &amp;&amp; <span class="hljs-string">'line'</span> <span class="hljs-keyword">in</span> aGenerated &amp;&amp; <span class="hljs-string">'column'</span> <span class="hljs-keyword">in</span> aGenerated &amp;&amp; aGenerated.line &gt; <span class="hljs-number">0</span> &amp;&amp; aGenerated.column &gt;= <span class="hljs-number">0</span> &amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-74" id="section-74"></a>
</div>
<p>Case 1.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aGenerated &amp;&amp; <span class="hljs-string">'line'</span> <span class="hljs-keyword">in</span> aGenerated &amp;&amp; <span class="hljs-string">'column'</span> <span class="hljs-keyword">in</span> aGenerated &amp;&amp; aOriginal &amp;&amp; <span class="hljs-string">'line'</span> <span class="hljs-keyword">in</span> aOriginal &amp;&amp; <span class="hljs-string">'column'</span> <span class="hljs-keyword">in</span> aOriginal &amp;&amp; aGenerated.line &gt; <span class="hljs-number">0</span> &amp;&amp; aGenerated.column &gt;= <span class="hljs-number">0</span> &amp;&amp; aOriginal.line &gt; <span class="hljs-number">0</span> &amp;&amp; aOriginal.column &gt;= <span class="hljs-number">0</span> &amp;&amp; aSource) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-75" id="section-75"></a>
</div>
<p>Cases 2 and 3.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> message = <span class="hljs-string">'Invalid mapping: '</span> + <span class="hljs-built_in">JSON</span>.stringify({
            <span class="hljs-attr">generated</span>: aGenerated,
            <span class="hljs-attr">source</span>: aSource,
            <span class="hljs-attr">original</span>: aOriginal,
            <span class="hljs-attr">name</span>: aName
        });
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._ignoreInvalidMapping) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">console</span>.warn) {
                <span class="hljs-built_in">console</span>.warn(message);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
        }
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-76" id="section-76"></a>
</div>
<div class="dox">
<div class="summary">
<p>Serialize the accumulated mappings in to the stream of base 64 VLQs
specified by the source map format.
SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> previousGeneratedColumn = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousGeneratedLine = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> previousOriginalColumn = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousOriginalLine = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousName = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousSource = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">var</span> next;
    <span class="hljs-keyword">var</span> mapping;
    <span class="hljs-keyword">var</span> nameIdx;
    <span class="hljs-keyword">var</span> sourceIdx;
    <span class="hljs-keyword">var</span> mappings = <span class="hljs-keyword">this</span>._mappings.toArray();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = mappings.length; i &lt; len; i++){
        mapping = mappings[i];
        next = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">if</span> (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span>(mapping.generatedLine !== previousGeneratedLine){
                next += <span class="hljs-string">';'</span>;
                previousGeneratedLine++;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - <span class="hljs-number">1</span>])) {
                    <span class="hljs-keyword">continue</span>;
                }
                next += <span class="hljs-string">','</span>;
            }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        <span class="hljs-keyword">if</span> (mapping.source != <span class="hljs-literal">null</span>) {
            sourceIdx = <span class="hljs-keyword">this</span>._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-77" id="section-77"></a>
</div>
<p>lines are stored 0-based in SourceMap spec version 3</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            next += base64VLQ.encode(mapping.originalLine - <span class="hljs-number">1</span> - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - <span class="hljs-number">1</span>;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            <span class="hljs-keyword">if</span> (mapping.name != <span class="hljs-literal">null</span>) {
                nameIdx = <span class="hljs-keyword">this</span>._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
            }
        }
        result += next;
    }
    <span class="hljs-keyword">return</span> result;
};
SourceMapGenerator.prototype._generateSourcesContent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapGenerator_generateSourcesContent</span>(<span class="hljs-params">aSources, aSourceRoot</span>) </span>{
    <span class="hljs-keyword">return</span> aSources.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._sourcesContents) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">if</span> (aSourceRoot != <span class="hljs-literal">null</span>) {
            source = util.relative(aSourceRoot, source);
        }
        <span class="hljs-keyword">var</span> key = util.toSetString(source);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(<span class="hljs-keyword">this</span>._sourcesContents, key) ? <span class="hljs-keyword">this</span>._sourcesContents[key] : <span class="hljs-literal">null</span>;
    }, <span class="hljs-keyword">this</span>);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-78" id="section-78"></a>
</div>
<div class="dox">
<div class="summary">
<p>Externalize the source map.
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> map = {
        <span class="hljs-attr">version</span>: <span class="hljs-keyword">this</span>._version,
        <span class="hljs-attr">sources</span>: <span class="hljs-keyword">this</span>._sources.toArray(),
        <span class="hljs-attr">names</span>: <span class="hljs-keyword">this</span>._names.toArray(),
        <span class="hljs-attr">mappings</span>: <span class="hljs-keyword">this</span>._serializeMappings()
    };
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._file != <span class="hljs-literal">null</span>) {
        map.file = <span class="hljs-keyword">this</span>._file;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._sourceRoot != <span class="hljs-literal">null</span>) {
        map.sourceRoot = <span class="hljs-keyword">this</span>._sourceRoot;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._sourcesContents) {
        map.sourcesContent = <span class="hljs-keyword">this</span>._generateSourcesContent(map.sources, map.sourceRoot);
    }
    <span class="hljs-keyword">return</span> map;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-79" id="section-79"></a>
</div>
<div class="dox">
<div class="summary">
<p>Render the source map being generated to a string.
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.toJSON());
};
exports.SourceMapGenerator = SourceMapGenerator;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> exports.GREATEST_LOWER_BOUND = <span class="hljs-number">1</span>;
exports.LEAST_UPPER_BOUND = <span class="hljs-number">2</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-80" id="section-80"></a>
</div>
<div class="dox">
<div class="summary">
<p>Recursive implementation of binary search.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aLow</span>
<span>Indices here and lower do not contain the needle.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aHigh</span>
<span>Indices here and higher do not contain the needle.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aNeedle</span>
<span>The element being searched for.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aHaystack</span>
<span>The non-empty array being searched.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aCompare</span>
<span>Function which takes two elements and returns -1, 0, or 1.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aBias</span>
<span>Either 'binarySearch.GREATEST_LOWER_BOUND' or     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
closest element that is smaller than or greater than the one we are
searching for, respectively, if the exact element cannot be found.
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
</span>
</div>
</div>
</div>
This function terminates when one of the following is true:
<ol>
<li>
<p>We find the exact element we are looking for.</p>
</li>
<li>
<p>We did not find the exact element, but we can return the index of
the next-closest element.</p>
</li>
<li>
<p>We did not find the exact element, and there is no next-closest
element than the one we are searching for, so we return -1.</p>
</li>
</ol>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> mid = <span class="hljs-built_in">Math</span>.floor((aHigh - aLow) / <span class="hljs-number">2</span>) + aLow;
    <span class="hljs-keyword">var</span> cmp = aCompare(aNeedle, aHaystack[mid], <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (cmp === <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-81" id="section-81"></a>
</div>
<p>Found the element we are looking for.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> mid;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-82" id="section-82"></a>
</div>
<p>Our needle is greater than aHaystack[mid].</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (aHigh - mid &gt; <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-83" id="section-83"></a>
</div>
<p>The element is in the upper half.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-84" id="section-84"></a>
</div>
<p>The exact needle element was not found in this haystack. Determine if
we are in termination case (3) or (2) and return the appropriate thing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (aBias == exports.LEAST_UPPER_BOUND) {
            <span class="hljs-keyword">return</span> aHigh &lt; aHaystack.length ? aHigh : <span class="hljs-number">-1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> mid;
        }
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-85" id="section-85"></a>
</div>
<p>Our needle is less than aHaystack[mid].</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (mid - aLow &gt; <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-86" id="section-86"></a>
</div>
<p>The element is in the lower half.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-87" id="section-87"></a>
</div>
<p>we are in termination case (3) or (2) and return the appropriate thing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (aBias == exports.LEAST_UPPER_BOUND) {
            <span class="hljs-keyword">return</span> mid;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> aLow &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : aLow;
        }
    }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-88" id="section-88"></a>
</div>
<div class="dox">
<div class="summary">
<p>This is an implementation of binary search which will always try and return
the index of the closest element if there is no exact hit. This is because
mappings between original and generated line/col pairs are single points,
and there is an implicit region between each of them, so a miss just means
that you aren't on the very start of a region.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aNeedle</span>
<span>The element you are looking for.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aHaystack</span>
<span>The array that is being searched.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aCompare</span>
<span>A function which takes the needle and an element in the     array and returns -1, 0, or 1 depending on whether the needle is less
than, equal to, or greater than the element, respectively.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aBias</span>
<span>Either 'binarySearch.GREATEST_LOWER_BOUND' or     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
closest element that is smaller than or greater than the one we are
searching for, respectively, if the exact element cannot be found.
Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aHaystack.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">var</span> index = recursiveSearch(<span class="hljs-number">-1</span>, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-89" id="section-89"></a>
</div>
<p>We have found either the exact element, or the next-closest element than
the one we are searching for. However, there may be more than one such
element. Make sure we always return the smallest of these.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">while</span>(index - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>){
        <span class="hljs-keyword">if</span> (aCompare(aHaystack[index], aHaystack[index - <span class="hljs-number">1</span>], <span class="hljs-literal">true</span>) !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">break</span>;
        }
        --index;
    }
    <span class="hljs-keyword">return</span> index;
};
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-comment">// It turns out that some (most?) JavaScript engines don't self-host</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-90" id="section-90"></a>
</div>
<p><code>Array.prototype.sort</code>. This makes sense because C++ will likely remain
faster than JS when doing raw CPU-intensive sorting. However, when using a
custom comparator function, calling back and forth between the VM's C++ and
JIT'd JS is rather slow <em>and</em> loses JIT type information, resulting in
worse generated code for the comparator function than would be optimal. In
fact, when sorting with a comparator, these costs outweigh the benefits of
sorting in C++. By using our own JS-implemented Quick Sort (below), we get
a ~3500ms mean speed-up in <code>bench/bench.html</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SortTemplate</span>(<span class="hljs-params">comparator</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-91" id="section-91"></a>
</div>
<div class="dox">
<div class="summary">
<p>Swap the elements indexed by <code>x</code> and <code>y</code> in the array <code>ary</code>.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">ary</span>
<span class="dox_type">Array</span>
<span>The array.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">x</span>
<span class="dox_type">Number</span>
<span>The index of the first item.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">y</span>
<span class="dox_type">Number</span>
<span>The index of the second item.
function swap(ary, x, y) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-92" id="section-92"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns a random integer within the range <code>low .. high</code> inclusive.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">low</span>
<span class="dox_type">Number</span>
<span>The lower bound on the range.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">high</span>
<span class="dox_type">Number</span>
<span>The upper bound on the range.
function randomIntInRange(low, high) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(low + <span class="hljs-built_in">Math</span>.random() * (high - low));
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-93" id="section-93"></a>
</div>
<div class="dox">
<div class="summary">
<p>The Quick Sort algorithm.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">ary</span>
<span class="dox_type">Array</span>
<span>An array to sort.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">comparator</span>
<span class="dox_type">function</span>
<span>Function to use to compare two items.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">p</span>
<span class="dox_type">Number</span>
<span>Start index of the array
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">r</span>
<span class="dox_type">Number</span>
<span>End index of the array
function doQuickSort(ary, comparator, p, r) {
</span>
</div>
</div>
</div>
If our lower bound is less than our upper bound, we (1) partition the
array into two pieces and (2) recurse on each half. If it is not, this is
the empty array and our base case.

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (p &lt; r) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-94" id="section-94"></a>
</div>
<p>(1) Partitioning.</p>
<p>The partitioning chooses a pivot between <code>p</code> and <code>r</code> and moves all
elements that are less than or equal to the pivot to the before it, and
all the elements that are greater than it after it. The effect is that
once partition is done, the pivot is in the exact place it will be when
the array is put in sorted order, and it will not need to be moved
again. This runs in O(n) time.
Always choose a random pivot so that an input array which is reverse
sorted does not cause O(n^2) running time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> pivotIndex = randomIntInRange(p, r);
            <span class="hljs-keyword">var</span> i = p - <span class="hljs-number">1</span>;
            swap(ary, pivotIndex, r);
            <span class="hljs-keyword">var</span> pivot = ary[r];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-95" id="section-95"></a>
</div>
<p>Immediately after <code>j</code> is incremented in this loop, the following hold
true:</p>
<ul>
<li>
<p>Every element in <code>ary[p .. i]</code> is less than or equal to the pivot.</p>
</li>
<li>
<p>Every element in <code>ary[i+1 .. j-1]</code> is greater than the pivot.</p>
</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = p; j &lt; r; j++){
                <span class="hljs-keyword">if</span> (comparator(ary[j], pivot, <span class="hljs-literal">false</span>) &lt;= <span class="hljs-number">0</span>) {
                    i += <span class="hljs-number">1</span>;
                    swap(ary, i, j);
                }
            }
            swap(ary, i + <span class="hljs-number">1</span>, j);
            <span class="hljs-keyword">var</span> q = i + <span class="hljs-number">1</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-96" id="section-96"></a>
</div>
<p>(2) Recurse on each half.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            doQuickSort(ary, comparator, p, q - <span class="hljs-number">1</span>);
            doQuickSort(ary, comparator, q + <span class="hljs-number">1</span>, r);
        }
    }
    <span class="hljs-keyword">return</span> doQuickSort;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneSort</span>(<span class="hljs-params">comparator</span>) </span>{
    <span class="hljs-keyword">let</span> template = SortTemplate.toString();
    <span class="hljs-keyword">let</span> templateFn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">`return <span class="hljs-subst">${template}</span>`</span>)();
    <span class="hljs-keyword">return</span> templateFn(comparator);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-97" id="section-97"></a>
</div>
<div class="dox">
<div class="summary">
<p>Sort the given array in-place with the given comparator function.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">ary</span>
<span class="dox_type">Array</span>
<span>An array to sort.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">comparator</span>
<span class="dox_type">function</span>
<span>Function to use to compare two items.
let sortCache = new WeakMap();
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ary, comparator, start = <span class="hljs-number">0</span></span>) </span>{
    <span class="hljs-keyword">let</span> doQuickSort = sortCache.get(comparator);
    <span class="hljs-keyword">if</span> (doQuickSort === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
    }
    doQuickSort(ary, comparator, start, ary.length - <span class="hljs-number">1</span>);
};
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-keyword">var</span> util = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">var</span> binarySearch = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">var</span> ArraySet = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)"</span>).ArraySet;
<span class="hljs-keyword">var</span> base64VLQ = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">var</span> quickSort = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)"</span>).quickSort;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer</span>(<span class="hljs-params">aSourceMap, aSourceMapURL</span>) </span>{
    <span class="hljs-keyword">var</span> sourceMap = aSourceMap;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> aSourceMap === <span class="hljs-string">'string'</span>) {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    <span class="hljs-keyword">return</span> sourceMap.sections != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : <span class="hljs-keyword">new</span> BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer.fromSourceMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aSourceMap, aSourceMapURL</span>) </span>{
    <span class="hljs-keyword">return</span> BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-98" id="section-98"></a>
</div>
<div class="dox">
<div class="summary">
<p>The version of the source mapping spec that we are consuming.
SourceMapConsumer.prototype._version = 3;</p>
</div>
<div class="body">
</div>
</div>
`__generatedMappings` and `__originalMappings` are arrays that hold the
parsed mapping coordinates from the source map's "mappings" attribute. They
are lazily instantiated, accessed via the `_generatedMappings` and
`_originalMappings` getters respectively, and we only parse the mappings
and create these arrays once queried for a source location. We jump through
these hoops because there can be many thousands of mappings, and parsing
them is expensive, so we only want to do it if we must.
<p>Each object in the arrays is of the form:</p>
<pre><code>{
  generatedLine: The line number in the generated code,
  generatedColumn: The column number in the generated code,
  source: The path to the original source file that generated this
          chunk of code,
  originalLine: The line number in the original source that
                corresponds to this chunk of generated code,
  originalColumn: The column number in the original source that
                  corresponds to this chunk of generated code,
  name: The name of the original symbol which generated this chunk of
        code.
}
</code></pre>
<p>All properties except for <code>generatedLine</code> and <code>generatedColumn</code> can be
<code>null</code>.</p>
<p><code>_generatedMappings</code> is ordered by the generated positions.</p>
<p><code>_originalMappings</code> is ordered by the original positions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">SourceMapConsumer.prototype.__generatedMappings = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">Object</span>.defineProperty(SourceMapConsumer.prototype, <span class="hljs-string">'_generatedMappings'</span>, {
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.__generatedMappings) {
            <span class="hljs-keyword">this</span>._parseMappings(<span class="hljs-keyword">this</span>._mappings, <span class="hljs-keyword">this</span>.sourceRoot);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__generatedMappings;
    }
});
SourceMapConsumer.prototype.__originalMappings = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">Object</span>.defineProperty(SourceMapConsumer.prototype, <span class="hljs-string">'_originalMappings'</span>, {
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.__originalMappings) {
            <span class="hljs-keyword">this</span>._parseMappings(<span class="hljs-keyword">this</span>._mappings, <span class="hljs-keyword">this</span>.sourceRoot);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__originalMappings;
    }
});
SourceMapConsumer.prototype._charIsMappingSeparator = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_charIsMappingSeparator</span>(<span class="hljs-params">aStr, index</span>) </span>{
    <span class="hljs-keyword">var</span> c = aStr.charAt(index);
    <span class="hljs-keyword">return</span> c === <span class="hljs-string">";"</span> || c === <span class="hljs-string">","</span>;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-99" id="section-99"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the <code>this.__generatedMappings</code> and
<code>this.__originalMappings</code> properties).
SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Subclasses must implement _parseMappings"</span>);
};
SourceMapConsumer.GENERATED_ORDER = <span class="hljs-number">1</span>;
SourceMapConsumer.ORIGINAL_ORDER = <span class="hljs-number">2</span>;
SourceMapConsumer.GREATEST_LOWER_BOUND = <span class="hljs-number">1</span>;
SourceMapConsumer.LEAST_UPPER_BOUND = <span class="hljs-number">2</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-100" id="section-100"></a>
</div>
<div class="dox">
<div class="summary">
<p>Iterate over each mapping between an original source/line/column and a
generated line/column in this source map.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">Function</span>
<span>aCallback        The function that is called with each mapping.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">Object</span>
<span>aContext        Optional. If specified, this object will be the value of <code>this</code> every
time that <code>aCallback</code> is called.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aOrder</span>
<span>Either <code>SourceMapConsumer.GENERATED_ORDER</code> or
<code>SourceMapConsumer.ORIGINAL_ORDER</code>. Specifies whether you want to
iterate over the mappings sorted by the generated file's line/column
order or the original's source/line/column order, respectively. Defaults to
<code>SourceMapConsumer.GENERATED_ORDER</code>.
SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> context = aContext || <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    <span class="hljs-keyword">var</span> mappings;
    <span class="hljs-keyword">switch</span>(order){
        <span class="hljs-keyword">case</span> SourceMapConsumer.GENERATED_ORDER:
            mappings = <span class="hljs-keyword">this</span>._generatedMappings;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> SourceMapConsumer.ORIGINAL_ORDER:
            mappings = <span class="hljs-keyword">this</span>._originalMappings;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown order of iteration."</span>);
    }
    <span class="hljs-keyword">var</span> sourceRoot = <span class="hljs-keyword">this</span>.sourceRoot;
    <span class="hljs-keyword">var</span> boundCallback = aCallback.bind(context);
    <span class="hljs-keyword">var</span> names = <span class="hljs-keyword">this</span>._names;
    <span class="hljs-keyword">var</span> sources = <span class="hljs-keyword">this</span>._sources;
    <span class="hljs-keyword">var</span> sourceMapURL = <span class="hljs-keyword">this</span>._sourceMapURL;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = mappings.length; i &lt; n; i++){
        <span class="hljs-keyword">var</span> mapping = mappings[i];
        <span class="hljs-keyword">var</span> source = mapping.source === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : sources.at(mapping.source);
        <span class="hljs-keyword">if</span> (source !== <span class="hljs-literal">null</span>) {
            source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
        }
        boundCallback({
            <span class="hljs-attr">source</span>: source,
            <span class="hljs-attr">generatedLine</span>: mapping.generatedLine,
            <span class="hljs-attr">generatedColumn</span>: mapping.generatedColumn,
            <span class="hljs-attr">originalLine</span>: mapping.originalLine,
            <span class="hljs-attr">originalColumn</span>: mapping.originalColumn,
            <span class="hljs-attr">name</span>: mapping.name === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : names.at(mapping.name)
        });
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-101" id="section-101"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns all generated line and column information for the original source,
line, and column provided. If no column is provided, returns all mappings
corresponding to a either the line we are searching for or the next
closest line that has any mappings. Otherwise, returns all mappings
corresponding to the given line and either the column we are searching for
or the next closest column that has any offsets.</p>
</div>
<div class="body">
<p>The only argument is an object with the following properties:</p>
<ul>
<li>source: The filename of the original source.</li>
<li>line: The line number in the original source.  The line number is 1-based.</li>
<li>column: Optional. the column number in the original source.
The column number is 0-based.</li>
</ul>
<p>and an array of objects is returned, each with the following properties:</p>
<ul>
<li>line: The line number in the generated source, or null.  The
line number is 1-based.</li>
<li>column: The column number in the generated source, or null.
The column number is 0-based.
SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> line = util.getArg(aArgs, <span class="hljs-string">'line'</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-102" id="section-102"></a>
</div>
<p>When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
returns the index of the closest mapping less than the needle. By
setting needle.originalColumn to 0, we thus find the last mapping for
the given line, provided such a mapping exists.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">source</span>: util.getArg(aArgs, <span class="hljs-string">'source'</span>),
        <span class="hljs-attr">originalLine</span>: line,
        <span class="hljs-attr">originalColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>, <span class="hljs-number">0</span>)
    };
    needle.source = <span class="hljs-keyword">this</span>._findSourceIndex(needle.source);
    <span class="hljs-keyword">if</span> (needle.source &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> [];
    }
    <span class="hljs-keyword">var</span> mappings = [];
    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>._findMapping(needle, <span class="hljs-keyword">this</span>._originalMappings, <span class="hljs-string">"originalLine"</span>, <span class="hljs-string">"originalColumn"</span>, util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._originalMappings[index];
        <span class="hljs-keyword">if</span> (aArgs.column === <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">var</span> originalLine = mapping.originalLine;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-103" id="section-103"></a>
</div>
<p>Iterate until either we run out of mappings, or we run into
a mapping for a different line than the one we found. Since
mappings are sorted, this is guaranteed to find all mappings for
the line we found.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">while</span>(mapping &amp;&amp; mapping.originalLine === originalLine){
                mappings.push({
                    <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'generatedLine'</span>, <span class="hljs-literal">null</span>),
                    <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'generatedColumn'</span>, <span class="hljs-literal">null</span>),
                    <span class="hljs-attr">lastColumn</span>: util.getArg(mapping, <span class="hljs-string">'lastGeneratedColumn'</span>, <span class="hljs-literal">null</span>)
                });
                mapping = <span class="hljs-keyword">this</span>._originalMappings[++index];
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> originalColumn = mapping.originalColumn;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-104" id="section-104"></a>
</div>
<p>Iterate until either we run out of mappings, or we run into
a mapping for a different line than the one we were searching for.
Since mappings are sorted, this is guaranteed to find all mappings for
the line we are searching for.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">while</span>(mapping &amp;&amp; mapping.originalLine === line &amp;&amp; mapping.originalColumn == originalColumn){
                mappings.push({
                    <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'generatedLine'</span>, <span class="hljs-literal">null</span>),
                    <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'generatedColumn'</span>, <span class="hljs-literal">null</span>),
                    <span class="hljs-attr">lastColumn</span>: util.getArg(mapping, <span class="hljs-string">'lastGeneratedColumn'</span>, <span class="hljs-literal">null</span>)
                });
                mapping = <span class="hljs-keyword">this</span>._originalMappings[++index];
            }
        }
    }
    <span class="hljs-keyword">return</span> mappings;
};
exports.SourceMapConsumer = SourceMapConsumer;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-105" id="section-105"></a>
</div>
<div class="dox">
<div class="summary">
<p>A BasicSourceMapConsumer instance represents a parsed source map which we can
query for information about the original file positions by giving it a file
position in the generated source.</p>
</div>
<div class="body">
<p>The first parameter is the raw source map (either as a JSON string, or
already parsed to an object). According to the spec, source maps have the
following attributes:</p>
<ul>
<li>version: Which version of the source map spec this map is following.</li>
<li>sources: An array of URLs to the original source files.</li>
<li>names: An array of identifiers which can be referrenced by individual mappings.</li>
<li>sourceRoot: Optional. The URL root from which all sources are relative.</li>
<li>sourcesContent: Optional. An array of contents of the original source files.</li>
<li>mappings: A string of base64 VLQs which contain the actual mappings.</li>
<li>file: Optional. The generated file this source map is associated with.</li>
</ul>
<p>Here is an example source map, taken from the source map spec<a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#">0</a>:</p>
<pre><code>{
  version : 3,
  file: &quot;out.js&quot;,
  sourceRoot : &quot;&quot;,
  sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],
  names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],
  mappings: &quot;AA,AB;;ABCDE;&quot;
}
</code></pre>
<p>The second parameter, if given, is a string whose value is the URL
at which the source map was found.  This URL is used to compute the
sources array.</p>
<p>function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> sourceMap = aSourceMap;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> aSourceMap === <span class="hljs-string">'string'</span>) {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    <span class="hljs-keyword">var</span> version = util.getArg(sourceMap, <span class="hljs-string">'version'</span>);
    <span class="hljs-keyword">var</span> sources = util.getArg(sourceMap, <span class="hljs-string">'sources'</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-106" id="section-106"></a>
</div>
<p>Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
requires the array) to play nice here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> names = util.getArg(sourceMap, <span class="hljs-string">'names'</span>, []);
    <span class="hljs-keyword">var</span> sourceRoot = util.getArg(sourceMap, <span class="hljs-string">'sourceRoot'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> sourcesContent = util.getArg(sourceMap, <span class="hljs-string">'sourcesContent'</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> mappings = util.getArg(sourceMap, <span class="hljs-string">'mappings'</span>);
    <span class="hljs-keyword">var</span> file = util.getArg(sourceMap, <span class="hljs-string">'file'</span>, <span class="hljs-literal">null</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-107" id="section-107"></a>
</div>
<p>Once again, Sass deviates from the spec and supplies the version as a
string rather than a number, so we use loose equality checking here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (version != <span class="hljs-keyword">this</span>._version) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported version: '</span> + version);
    }
    <span class="hljs-keyword">if</span> (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(<span class="hljs-built_in">String</span>)<span class="hljs-comment">// Some source maps produce relative source paths like "./foo.js" instead of</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-108" id="section-108"></a>
</div>
<p>&quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.
See bugzil.la/1090768.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    .map(util.normalize)<span class="hljs-comment">// Always ensure that absolute sources are internally stored relative to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-109" id="section-109"></a>
</div>
<p>the source root, if the source root is absolute. Not doing this would
be particularly problematic when the source root is a prefix of the
source (valid, but why??). See github issue #199 and bugzil.la/1188982.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    .map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) </span>{
        <span class="hljs-keyword">return</span> sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-110" id="section-110"></a>
</div>
<p>Pass <code>true</code> below to allow duplicate names and sources. While source maps
are intended to be compressed and deduplicated, the TypeScript compiler
sometimes generates source maps with duplicates in them. See Github issue
#72 and bugzil.la/889492.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>._names = ArraySet.fromArray(names.map(<span class="hljs-built_in">String</span>), <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">this</span>._sources = ArraySet.fromArray(sources, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">this</span>._absoluteSources = <span class="hljs-keyword">this</span>._sources.toArray().map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
        <span class="hljs-keyword">return</span> util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    <span class="hljs-keyword">this</span>.sourceRoot = sourceRoot;
    <span class="hljs-keyword">this</span>.sourcesContent = sourcesContent;
    <span class="hljs-keyword">this</span>._mappings = mappings;
    <span class="hljs-keyword">this</span>._sourceMapURL = aSourceMapURL;
    <span class="hljs-keyword">this</span>.file = file;
}
BasicSourceMapConsumer.prototype = <span class="hljs-built_in">Object</span>.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-111" id="section-111"></a>
</div>
<div class="dox">
<div class="summary">
<p>Utility function to find the index of a source.  Returns -1 if not
found.
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> relativeSource = aSource;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span>) {
        relativeSource = util.relative(<span class="hljs-keyword">this</span>.sourceRoot, relativeSource);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._sources.has(relativeSource)) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._sources.indexOf(relativeSource);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-112" id="section-112"></a>
</div>
<p>Maybe aSource is an absolute URL as returned by |sources|.  In
this case we can't simply undo the transform.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> i;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._absoluteSources.length; ++i){
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._absoluteSources[i] == aSource) {
            <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-113" id="section-113"></a>
</div>
<div class="dox">
<div class="summary">
<p>Create a BasicSourceMapConsumer from a SourceMapGenerator.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">SourceMapGenerator</span>
<span>aSourceMap        The source map that will be consumed.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">String</span>
<span>aSourceMapURL        The URL at which the source map can be found (optional)
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> smc = <span class="hljs-built_in">Object</span>.create(BasicSourceMapConsumer.prototype);
    <span class="hljs-keyword">var</span> names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">var</span> sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), <span class="hljs-literal">true</span>);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
        <span class="hljs-keyword">return</span> util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-114" id="section-114"></a>
</div>
<p>Because we are modifying the entries (by converting string sources and
names to indices into the sources and names ArraySets), we have to make
a copy of the entry or else bad things happen. Shared mutable state
strikes again! See github issue #191.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> generatedMappings = aSourceMap._mappings.toArray().slice();
    <span class="hljs-keyword">var</span> destGeneratedMappings = smc.__generatedMappings = [];
    <span class="hljs-keyword">var</span> destOriginalMappings = smc.__originalMappings = [];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, length = generatedMappings.length; i &lt; length; i++){
        <span class="hljs-keyword">var</span> srcMapping = generatedMappings[i];
        <span class="hljs-keyword">var</span> destMapping = <span class="hljs-keyword">new</span> Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        <span class="hljs-keyword">if</span> (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            <span class="hljs-keyword">if</span> (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    <span class="hljs-keyword">return</span> smc;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-115" id="section-115"></a>
</div>
<div class="dox">
<div class="summary">
<p>The version of the source mapping spec that we are consuming.
BasicSourceMapConsumer.prototype._version = 3;</p>
</div>
<div class="body">
</div>
</div>
<div class="dox">
<div class="summary">
<p>The list of original sources.
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">get</span>: function() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._absoluteSources.slice();
    }
});
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-116" id="section-116"></a>
</div>
<div class="dox">
<div class="summary">
<p>Provide the JIT with a nice shape / hidden class.
function Mapping() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.generatedLine = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.generatedColumn = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.source = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.originalLine = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.originalColumn = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.name = <span class="hljs-literal">null</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-117" id="section-117"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the <code>this.__generatedMappings</code> and
<code>this.__originalMappings</code> properties).
const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortGenerated</span>(<span class="hljs-params">array, start</span>) </span>{
    <span class="hljs-keyword">let</span> l = array.length;
    <span class="hljs-keyword">let</span> n = array.length - start;
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">let</span> a = array[start];
        <span class="hljs-keyword">let</span> b = array[start + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span> (compareGenerated(a, b) &gt; <span class="hljs-number">0</span>) {
            array[start] = b;
            array[start + <span class="hljs-number">1</span>] = a;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">20</span>) {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start; i &lt; l; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &gt; start; j--){
                <span class="hljs-keyword">let</span> a = array[j - <span class="hljs-number">1</span>];
                <span class="hljs-keyword">let</span> b = array[j];
                <span class="hljs-keyword">if</span> (compareGenerated(a, b) &lt;= <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">break</span>;
                }
                array[j - <span class="hljs-number">1</span>] = b;
                array[j] = a;
            }
        }
    } <span class="hljs-keyword">else</span> {
        quickSort(array, compareGenerated, start);
    }
}
BasicSourceMapConsumer.prototype._parseMappings = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SourceMapConsumer_parseMappings</span>(<span class="hljs-params">aStr, aSourceRoot</span>) </span>{
    <span class="hljs-keyword">var</span> generatedLine = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> previousGeneratedColumn = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousOriginalLine = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousOriginalColumn = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousSource = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousName = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> length = aStr.length;
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> cachedSegments = {};
    <span class="hljs-keyword">var</span> temp = {};
    <span class="hljs-keyword">var</span> originalMappings = [];
    <span class="hljs-keyword">var</span> generatedMappings = [];
    <span class="hljs-keyword">var</span> mapping, str, segment, end, value;
    <span class="hljs-keyword">let</span> subarrayStart = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(index &lt; length){
        <span class="hljs-keyword">if</span> (aStr.charAt(index) === <span class="hljs-string">';'</span>) {
            generatedLine++;
            index++;
            previousGeneratedColumn = <span class="hljs-number">0</span>;
            sortGenerated(generatedMappings, subarrayStart);
            subarrayStart = generatedMappings.length;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aStr.charAt(index) === <span class="hljs-string">','</span>) {
            index++;
        } <span class="hljs-keyword">else</span> {
            mapping = <span class="hljs-keyword">new</span> Mapping();
            mapping.generatedLine = generatedLine;
            <span class="hljs-keyword">for</span>(end = index; end &lt; length; end++){
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._charIsMappingSeparator(aStr, end)) {
                    <span class="hljs-keyword">break</span>;
                }
            }
            str = aStr.slice(index, end);
            segment = [];
            <span class="hljs-keyword">while</span>(index &lt; end){
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
            }
            <span class="hljs-keyword">if</span> (segment.length === <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Found a source, but no line and column'</span>);
            }
            <span class="hljs-keyword">if</span> (segment.length === <span class="hljs-number">3</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Found a source and line, but no column'</span>);
            }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-118" id="section-118"></a>
</div>
<p>Generated column.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            mapping.generatedColumn = previousGeneratedColumn + segment[<span class="hljs-number">0</span>];
            previousGeneratedColumn = mapping.generatedColumn;
            <span class="hljs-keyword">if</span> (segment.length &gt; <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-119" id="section-119"></a>
</div>
<p>Original source.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                mapping.source = previousSource + segment[<span class="hljs-number">1</span>];
                previousSource += segment[<span class="hljs-number">1</span>];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-120" id="section-120"></a>
</div>
<p>Original line.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                mapping.originalLine = previousOriginalLine + segment[<span class="hljs-number">2</span>];
                previousOriginalLine = mapping.originalLine;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-121" id="section-121"></a>
</div>
<p>Lines are stored 0-based</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                mapping.originalLine += <span class="hljs-number">1</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-122" id="section-122"></a>
</div>
<p>Original column.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                mapping.originalColumn = previousOriginalColumn + segment[<span class="hljs-number">3</span>];
                previousOriginalColumn = mapping.originalColumn;
                <span class="hljs-keyword">if</span> (segment.length &gt; <span class="hljs-number">4</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-123" id="section-123"></a>
</div>
<p>Original name.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    mapping.name = previousName + segment[<span class="hljs-number">4</span>];
                    previousName += segment[<span class="hljs-number">4</span>];
                }
            }
            generatedMappings.push(mapping);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mapping.originalLine === <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">let</span> currentSource = mapping.source;
                <span class="hljs-keyword">while</span>(originalMappings.length &lt;= currentSource){
                    originalMappings.push(<span class="hljs-literal">null</span>);
                }
                <span class="hljs-keyword">if</span> (originalMappings[currentSource] === <span class="hljs-literal">null</span>) {
                    originalMappings[currentSource] = [];
                }
                originalMappings[currentSource].push(mapping);
            }
        }
    }
    sortGenerated(generatedMappings, subarrayStart);
    <span class="hljs-keyword">this</span>.__generatedMappings = generatedMappings;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; originalMappings.length; i++){
        <span class="hljs-keyword">if</span> (originalMappings[i] != <span class="hljs-literal">null</span>) {
            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
        }
    }
    <span class="hljs-keyword">this</span>.__originalMappings = [].concat(...originalMappings);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-124" id="section-124"></a>
</div>
<div class="dox">
<div class="summary">
<p>Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that
we are searching for in the given &quot;haystack&quot; of mappings.
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {</p>
</div>
<div class="body">
</div>
</div>
To return the position we are searching for, we must first find the
mapping for the given position and then return the opposite position it
points to. Because the mappings are sorted, we can use binary search to
find the best mapping.

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (aNeedle[aLineName] &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Line must be greater than or equal to 1, got '</span> + aNeedle[aLineName]);
    }
    <span class="hljs-keyword">if</span> (aNeedle[aColumnName] &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Column must be greater than or equal to 0, got '</span> + aNeedle[aColumnName]);
    }
    <span class="hljs-keyword">return</span> binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-125" id="section-125"></a>
</div>
<div class="dox">
<div class="summary">
<p>Compute the last column for each generated mapping. The last column is
inclusive.
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-keyword">this</span>._generatedMappings.length; ++index){
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._generatedMappings[index];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-126" id="section-126"></a>
</div>
<p>Mappings do not contain a field for the last generated columnt. We
can come up with an optimistic estimate, however, by assuming that
mappings are contiguous (i.e. given two consecutive mappings, the
first mapping ends where the second one starts).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">this</span>._generatedMappings.length) {
            <span class="hljs-keyword">var</span> nextMapping = <span class="hljs-keyword">this</span>._generatedMappings[index + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">continue</span>;
            }
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-127" id="section-127"></a>
</div>
<p>The last mapping for each line spans the entire line.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        mapping.lastGeneratedColumn = <span class="hljs-literal">Infinity</span>;
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-128" id="section-128"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:</p>
</div>
<div class="body">
<ul>
<li>line: The line number in the generated source.  The line number
is 1-based.
<ul>
<li>column: The column number in the generated source.  The column
number is 0-based.</li>
<li>bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
closest element that is smaller than or greater than the one we are
searching for, respectively, if the exact element cannot be found.
Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>source: The original source file, or null.</li>
<li>line: The line number in the original source, or null.  The
line number is 1-based.</li>
<li>column: The column number in the original source, or null.  The
column number is 0-based.</li>
<li>name: The original identifier, or null.
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">generatedLine</span>: util.getArg(aArgs, <span class="hljs-string">'line'</span>),
        <span class="hljs-attr">generatedColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>)
    };
    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>._findMapping(needle, <span class="hljs-keyword">this</span>._generatedMappings, <span class="hljs-string">"generatedLine"</span>, <span class="hljs-string">"generatedColumn"</span>, util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, <span class="hljs-string">'bias'</span>, SourceMapConsumer.GREATEST_LOWER_BOUND));
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._generatedMappings[index];
        <span class="hljs-keyword">if</span> (mapping.generatedLine === needle.generatedLine) {
            <span class="hljs-keyword">var</span> source = util.getArg(mapping, <span class="hljs-string">'source'</span>, <span class="hljs-literal">null</span>);
            <span class="hljs-keyword">if</span> (source !== <span class="hljs-literal">null</span>) {
                source = <span class="hljs-keyword">this</span>._sources.at(source);
                source = util.computeSourceURL(<span class="hljs-keyword">this</span>.sourceRoot, source, <span class="hljs-keyword">this</span>._sourceMapURL);
            }
            <span class="hljs-keyword">var</span> name = util.getArg(mapping, <span class="hljs-string">'name'</span>, <span class="hljs-literal">null</span>);
            <span class="hljs-keyword">if</span> (name !== <span class="hljs-literal">null</span>) {
                name = <span class="hljs-keyword">this</span>._names.at(name);
            }
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">source</span>: source,
                <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'originalLine'</span>, <span class="hljs-literal">null</span>),
                <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'originalColumn'</span>, <span class="hljs-literal">null</span>),
                <span class="hljs-attr">name</span>: name
            };
        }
    }
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">source</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span>
    };
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-129" id="section-129"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return true if we have the source content for every source in the source
map, false otherwise.
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.sourcesContent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent.length &gt;= <span class="hljs-keyword">this</span>._sources.size() &amp;&amp; !<span class="hljs-keyword">this</span>.sourcesContent.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sc</span>) </span>{
        <span class="hljs-keyword">return</span> sc == <span class="hljs-literal">null</span>;
    });
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-130" id="section-130"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.sourcesContent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>._findSourceIndex(aSource);
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent[index];
    }
    <span class="hljs-keyword">var</span> relativeSource = aSource;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span>) {
        relativeSource = util.relative(<span class="hljs-keyword">this</span>.sourceRoot, relativeSource);
    }
    <span class="hljs-keyword">var</span> url;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sourceRoot != <span class="hljs-literal">null</span> &amp;&amp; (url = util.urlParse(<span class="hljs-keyword">this</span>.sourceRoot))) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-131" id="section-131"></a>
</div>
<p>XXX: file:// URIs and absolute paths lead to unexpected behavior for
many users. We can help them out when they expect file:// URIs to
behave like it would if they were running a local HTTP server. See
https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> fileUriAbsPath = relativeSource.replace(<span class="hljs-regexp">/^file:\/\//</span>, <span class="hljs-string">""</span>);
        <span class="hljs-keyword">if</span> (url.scheme == <span class="hljs-string">"file"</span> &amp;&amp; <span class="hljs-keyword">this</span>._sources.has(fileUriAbsPath)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent[<span class="hljs-keyword">this</span>._sources.indexOf(fileUriAbsPath)];
        }
        <span class="hljs-keyword">if</span> ((!url.path || url.path == <span class="hljs-string">"/"</span>) &amp;&amp; <span class="hljs-keyword">this</span>._sources.has(<span class="hljs-string">"/"</span> + relativeSource)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sourcesContent[<span class="hljs-keyword">this</span>._sources.indexOf(<span class="hljs-string">"/"</span> + relativeSource)];
        }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-132" id="section-132"></a>
</div>
<p>This function is used recursively from
IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
don't want to throw if we can't find the source - we just want to
return null, so we provide a flag to exit gracefully.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (nullOnMissing) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'"'</span> + relativeSource + <span class="hljs-string">'" is not in the SourceMap.'</span>);
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-133" id="section-133"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:</p>
</div>
<div class="body">
<ul>
<li>source: The filename of the original source.
<ul>
<li>line: The line number in the original source.  The line number
is 1-based.</li>
<li>column: The column number in the original source.  The column
number is 0-based.</li>
<li>bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
closest element that is smaller than or greater than the one we are
searching for, respectively, if the exact element cannot be found.
Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>line: The line number in the generated source, or null.  The
line number is 1-based.</li>
<li>column: The column number in the generated source, or null.
The column number is 0-based.
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> source = util.getArg(aArgs, <span class="hljs-string">'source'</span>);
    source = <span class="hljs-keyword">this</span>._findSourceIndex(source);
    <span class="hljs-keyword">if</span> (source &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">lastColumn</span>: <span class="hljs-literal">null</span>
        };
    }
    <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">source</span>: source,
        <span class="hljs-attr">originalLine</span>: util.getArg(aArgs, <span class="hljs-string">'line'</span>),
        <span class="hljs-attr">originalColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>)
    };
    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>._findMapping(needle, <span class="hljs-keyword">this</span>._originalMappings, <span class="hljs-string">"originalLine"</span>, <span class="hljs-string">"originalColumn"</span>, util.compareByOriginalPositions, util.getArg(aArgs, <span class="hljs-string">'bias'</span>, SourceMapConsumer.GREATEST_LOWER_BOUND));
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> mapping = <span class="hljs-keyword">this</span>._originalMappings[index];
        <span class="hljs-keyword">if</span> (mapping.source === needle.source) {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">line</span>: util.getArg(mapping, <span class="hljs-string">'generatedLine'</span>, <span class="hljs-literal">null</span>),
                <span class="hljs-attr">column</span>: util.getArg(mapping, <span class="hljs-string">'generatedColumn'</span>, <span class="hljs-literal">null</span>),
                <span class="hljs-attr">lastColumn</span>: util.getArg(mapping, <span class="hljs-string">'lastGeneratedColumn'</span>, <span class="hljs-literal">null</span>)
            };
        }
    }
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">lastColumn</span>: <span class="hljs-literal">null</span>
    };
};
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-134" id="section-134"></a>
</div>
<div class="dox">
<div class="summary">
<p>An IndexedSourceMapConsumer instance represents a parsed source map which
we can query for information. It differs from BasicSourceMapConsumer in
that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as
input.</p>
</div>
<div class="body">
<p>The first parameter is a raw source map (either as a JSON string, or already
parsed to an object). According to the spec for indexed source maps, they
have the following attributes:</p>
<ul>
<li>version: Which version of the source map spec this map is following.</li>
<li>file: Optional. The generated file this source map is associated with.</li>
<li>sections: A list of section definitions.</li>
</ul>
<p>Each value under the &quot;sections&quot; field has two fields:</p>
<ul>
<li>offset: The offset into the original specified at which this section
begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot;
field.</li>
<li>map: A source map definition. This source map could also be indexed,
but doesn't have to be.</li>
</ul>
<p>Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field
specifying a URL to retrieve a source map from, but that's currently
unsupported.</p>
<p>Here's an example source map, taken from the source map spec<a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt">0</a>, but
modified to omit a section which uses the &quot;url&quot; field.</p>
<p>{
version : 3,
file: &quot;app.js&quot;,
sections: [{
offset: {line:100, column:10},
map: {
version : 3,
file: &quot;section.js&quot;,
sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],
names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],
mappings: &quot;AAAA,E;;ABCDE;&quot;
}
}],
}</p>
<p>The second parameter, if given, is a string whose value is the URL
at which the source map was found.  This URL is used to compute the
sources array.</p>
<p>function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> sourceMap = aSourceMap;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> aSourceMap === <span class="hljs-string">'string'</span>) {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    <span class="hljs-keyword">var</span> version = util.getArg(sourceMap, <span class="hljs-string">'version'</span>);
    <span class="hljs-keyword">var</span> sections = util.getArg(sourceMap, <span class="hljs-string">'sections'</span>);
    <span class="hljs-keyword">if</span> (version != <span class="hljs-keyword">this</span>._version) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported version: '</span> + version);
    }
    <span class="hljs-keyword">this</span>._sources = <span class="hljs-keyword">new</span> ArraySet();
    <span class="hljs-keyword">this</span>._names = <span class="hljs-keyword">new</span> ArraySet();
    <span class="hljs-keyword">var</span> lastOffset = {
        <span class="hljs-attr">line</span>: <span class="hljs-number">-1</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>
    };
    <span class="hljs-keyword">this</span>._sections = sections.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
        <span class="hljs-keyword">if</span> (s.url) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-135" id="section-135"></a>
</div>
<p>The url field will require support for asynchronicity.
See https://github.com/mozilla/source-map/issues/16</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Support for url field in sections not implemented.'</span>);
        }
        <span class="hljs-keyword">var</span> offset = util.getArg(s, <span class="hljs-string">'offset'</span>);
        <span class="hljs-keyword">var</span> offsetLine = util.getArg(offset, <span class="hljs-string">'line'</span>);
        <span class="hljs-keyword">var</span> offsetColumn = util.getArg(offset, <span class="hljs-string">'column'</span>);
        <span class="hljs-keyword">if</span> (offsetLine &lt; lastOffset.line || offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Section offsets must be ordered and non-overlapping.'</span>);
        }
        lastOffset = offset;
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">generatedOffset</span>: {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-136" id="section-136"></a>
</div>
<p>The offset fields are 0-based, but we use 1-based indices when
encoding/decoding from VLQ.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                generatedLine: offsetLine + <span class="hljs-number">1</span>,
                <span class="hljs-attr">generatedColumn</span>: offsetColumn + <span class="hljs-number">1</span>
            },
            <span class="hljs-attr">consumer</span>: <span class="hljs-keyword">new</span> SourceMapConsumer(util.getArg(s, <span class="hljs-string">'map'</span>), aSourceMapURL)
        };
    });
}
IndexedSourceMapConsumer.prototype = <span class="hljs-built_in">Object</span>.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-137" id="section-137"></a>
</div>
<div class="dox">
<div class="summary">
<p>The version of the source mapping spec that we are consuming.
IndexedSourceMapConsumer.prototype._version = 3;</p>
</div>
<div class="body">
</div>
</div>
<div class="dox">
<div class="summary">
<p>The list of original sources.
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">get</span>: function() {
        <span class="hljs-keyword">var</span> sources = [];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">this</span>._sections[i].consumer.sources.length; j++){
                sources.push(<span class="hljs-keyword">this</span>._sections[i].consumer.sources[j]);
            }
        }
        <span class="hljs-keyword">return</span> sources;
    }
});
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-138" id="section-138"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:</p>
</div>
<div class="body">
<ul>
<li>line: The line number in the generated source.  The line number
is 1-based.
<ul>
<li>column: The column number in the generated source.  The column
number is 0-based.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>source: The original source file, or null.</li>
<li>line: The line number in the original source, or null.  The
line number is 1-based.</li>
<li>column: The column number in the original source, or null.  The
column number is 0-based.</li>
<li>name: The original identifier, or null.
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> needle = {
        <span class="hljs-attr">generatedLine</span>: util.getArg(aArgs, <span class="hljs-string">'line'</span>),
        <span class="hljs-attr">generatedColumn</span>: util.getArg(aArgs, <span class="hljs-string">'column'</span>)
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-139" id="section-139"></a>
</div>
<p>Find the section containing the generated position we're trying to map
to an original position.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> sectionIndex = binarySearch.search(needle, <span class="hljs-keyword">this</span>._sections, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">needle, section</span>) </span>{
        <span class="hljs-keyword">var</span> cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        <span class="hljs-keyword">if</span> (cmp) {
            <span class="hljs-keyword">return</span> cmp;
        }
        <span class="hljs-keyword">return</span> needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[sectionIndex];
    <span class="hljs-keyword">if</span> (!section) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">source</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span>
        };
    }
    <span class="hljs-keyword">return</span> section.consumer.originalPositionFor({
        <span class="hljs-attr">line</span>: needle.generatedLine - (section.generatedOffset.generatedLine - <span class="hljs-number">1</span>),
        <span class="hljs-attr">column</span>: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>),
        <span class="hljs-attr">bias</span>: aArgs.bias
    });
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-140" id="section-140"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return true if we have the source content for every source in the source
map, false otherwise.
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._sections.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
        <span class="hljs-keyword">return</span> s.consumer.hasContentsOfAllSources();
    });
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-141" id="section-141"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++){
        <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[i];
        <span class="hljs-keyword">var</span> content = section.consumer.sourceContentFor(aSource, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">if</span> (content || content === <span class="hljs-string">''</span>) {
            <span class="hljs-keyword">return</span> content;
        }
    }
    <span class="hljs-keyword">if</span> (nullOnMissing) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'"'</span> + aSource + <span class="hljs-string">'" is not in the SourceMap.'</span>);
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-142" id="section-142"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:</p>
</div>
<div class="body">
<ul>
<li>source: The filename of the original source.
<ul>
<li>line: The line number in the original source.  The line number
is 1-based.</li>
<li>column: The column number in the original source.  The column
number is 0-based.</li>
</ul>
</li>
</ul>
<p>and an object is returned with the following properties:</p>
<ul>
<li>line: The line number in the generated source, or null.  The
line number is 1-based.</li>
<li>column: The column number in the generated source, or null.
The column number is 0-based.
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++){
        <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[i];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-143" id="section-143"></a>
</div>
<p>Only consider this section if the requested source is in the list of
sources of the consumer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (section.consumer._findSourceIndex(util.getArg(aArgs, <span class="hljs-string">'source'</span>)) === <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">var</span> generatedPosition = section.consumer.generatedPositionFor(aArgs);
        <span class="hljs-keyword">if</span> (generatedPosition) {
            <span class="hljs-keyword">var</span> ret = {
                <span class="hljs-attr">line</span>: generatedPosition.line + (section.generatedOffset.generatedLine - <span class="hljs-number">1</span>),
                <span class="hljs-attr">column</span>: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)
            };
            <span class="hljs-keyword">return</span> ret;
        }
    }
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">line</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-literal">null</span>
    };
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-144" id="section-144"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the <code>this.__generatedMappings</code> and
<code>this.__originalMappings</code> properties).
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.__generatedMappings = [];
    <span class="hljs-keyword">this</span>.__originalMappings = [];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>._sections.length; i++){
        <span class="hljs-keyword">var</span> section = <span class="hljs-keyword">this</span>._sections[i];
        <span class="hljs-keyword">var</span> sectionMappings = section.consumer._generatedMappings;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; sectionMappings.length; j++){
            <span class="hljs-keyword">var</span> mapping = sectionMappings[j];
            <span class="hljs-keyword">var</span> source = section.consumer._sources.at(mapping.source);
            <span class="hljs-keyword">if</span> (source !== <span class="hljs-literal">null</span>) {
                source = util.computeSourceURL(section.consumer.sourceRoot, source, <span class="hljs-keyword">this</span>._sourceMapURL);
            }
            <span class="hljs-keyword">this</span>._sources.add(source);
            source = <span class="hljs-keyword">this</span>._sources.indexOf(source);
            <span class="hljs-keyword">var</span> name = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">if</span> (mapping.name) {
                name = section.consumer._names.at(mapping.name);
                <span class="hljs-keyword">this</span>._names.add(name);
                name = <span class="hljs-keyword">this</span>._names.indexOf(name);
            }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-145" id="section-145"></a>
</div>
<p>The mappings coming from the consumer for the section have
generated positions relative to the start of the section, so we
need to offset them to be relative to the start of the concatenated
generated file.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> adjustedMapping = {
                <span class="hljs-attr">source</span>: source,
                <span class="hljs-attr">generatedLine</span>: mapping.generatedLine + (section.generatedOffset.generatedLine - <span class="hljs-number">1</span>),
                <span class="hljs-attr">generatedColumn</span>: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>),
                <span class="hljs-attr">originalLine</span>: mapping.originalLine,
                <span class="hljs-attr">originalColumn</span>: mapping.originalColumn,
                <span class="hljs-attr">name</span>: name
            };
            <span class="hljs-keyword">this</span>.__generatedMappings.push(adjustedMapping);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> adjustedMapping.originalLine === <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">this</span>.__originalMappings.push(adjustedMapping);
            }
        }
    }
    quickSort(<span class="hljs-keyword">this</span>.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(<span class="hljs-keyword">this</span>.__originalMappings, util.compareByOriginalPositions);
};
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

<span class="hljs-comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span> <span class="hljs-comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span> <span class="hljs-keyword">var</span> SourceMapGenerator = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)"</span>).SourceMapGenerator;
<span class="hljs-keyword">var</span> util = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)"</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-146" id="section-146"></a>
</div>
<p>Matches a Windows-style <code>\r\n</code> newline or a <code>\n</code> newline used by all other
operating systems these days (capturing the result).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> REGEX_NEWLINE = <span class="hljs-regexp">/(\r?\n)/</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-147" id="section-147"></a>
</div>
<p>Newline character code for charCodeAt() comparisons</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> NEWLINE_CODE = <span class="hljs-number">10</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-148" id="section-148"></a>
</div>
<p>Private symbol for identifying <code>SourceNode</code>s when multiple versions of
the source-map library are loaded. This MUST NOT CHANGE across
versions!</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> isSourceNode = <span class="hljs-string">"$$$isSourceNode$$$"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-149" id="section-149"></a>
</div>
<div class="dox">
<div class="summary">
<p>SourceNodes provide a way to abstract over interpolating/concatenating
snippets of generated JavaScript source code while maintaining the line and
column information associated with the original source code.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aLine</span>
<span>The original line number.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aColumn</span>
<span>The original column number.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSource</span>
<span>The original source's filename.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aChunks</span>
<span>Optional. An array of strings which are snippets of        generated JS, or other SourceNodes.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aName</span>
<span>The original identifier. function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.children = [];
    <span class="hljs-keyword">this</span>.sourceContents = {};
    <span class="hljs-keyword">this</span>.line = aLine == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : aLine;
    <span class="hljs-keyword">this</span>.column = aColumn == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : aColumn;
    <span class="hljs-keyword">this</span>.source = aSource == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : aSource;
    <span class="hljs-keyword">this</span>.name = aName == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : aName;
    <span class="hljs-keyword">this</span>[isSourceNode] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (aChunks != <span class="hljs-literal">null</span>) <span class="hljs-keyword">this</span>.add(aChunks);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-150" id="section-150"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates a SourceNode from generated code and a SourceMapConsumer.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aGeneratedCode</span>
<span>The generated code
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSourceMapConsumer</span>
<span>The SourceMap for the generated code
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aRelativePath</span>
<span>Optional. The path that relative sources in the        SourceMapConsumer should be relative to.
SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
</span>
</div>
</div>
</div>
The SourceNode we want to fill with the generated code
and the SourceMap

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> SourceNode();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-151" id="section-151"></a>
</div>
<p>All even indices of this array are one line of the generated code,
while all odd indices are the newlines between two adjacent lines
(since <code>REGEX_NEWLINE</code> captures its match).
Processed fragments are accessed by calling <code>shiftNextLine</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    <span class="hljs-keyword">var</span> remainingLinesIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> shiftNextLine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> lineContents = getNextLine();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-152" id="section-152"></a>
</div>
<p>The last line of a file might not have a newline.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> newLine = getNextLine() || <span class="hljs-string">""</span>;
        <span class="hljs-keyword">return</span> lineContents + newLine;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-153" id="section-153"></a>
</div>
<p>TURBOPACK unreachable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        ;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextLine</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> remainingLinesIndex &lt; remainingLines.length ? remainingLines[remainingLinesIndex++] : <span class="hljs-literal">undefined</span>;
        }
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-154" id="section-154"></a>
</div>
<p>We need to remember the position of &quot;remainingLines&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> lastGeneratedLine = <span class="hljs-number">1</span>, lastGeneratedColumn = <span class="hljs-number">0</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-155" id="section-155"></a>
</div>
<p>The generate SourceNodes we need a code range.
To extract it current and last mapping is used.
Here we store the last mapping.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> lastMapping = <span class="hljs-literal">null</span>;
    aSourceMapConsumer.eachMapping(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mapping</span>) </span>{
        <span class="hljs-keyword">if</span> (lastMapping !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-156" id="section-156"></a>
</div>
<p>We add the code from &quot;lastMapping&quot; to &quot;mapping&quot;:
First check if there is a new line in between.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (lastGeneratedLine &lt; mapping.generatedLine) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-157" id="section-157"></a>
</div>
<p>Associate first line with &quot;lastMapping&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = <span class="hljs-number">0</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-158" id="section-158"></a>
</div>
<p>The remaining code is added without mapping</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-159" id="section-159"></a>
</div>
<p>There is no new line in between.
Associate the code between &quot;lastGeneratedColumn&quot; and
&quot;mapping.generatedColumn&quot; with &quot;lastMapping&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> nextLine = remainingLines[remainingLinesIndex] || <span class="hljs-string">''</span>;
                <span class="hljs-keyword">var</span> code = nextLine.substr(<span class="hljs-number">0</span>, mapping.generatedColumn - lastGeneratedColumn);
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-160" id="section-160"></a>
</div>
<p>No more remaining code, continue</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                lastMapping = mapping;
                <span class="hljs-keyword">return</span>;
            }
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-161" id="section-161"></a>
</div>
<p>We add the generated code until the first mapping
to the SourceNode without any mapping.
Each line is added as separate string.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">while</span>(lastGeneratedLine &lt; mapping.generatedLine){
            node.add(shiftNextLine());
            lastGeneratedLine++;
        }
        <span class="hljs-keyword">if</span> (lastGeneratedColumn &lt; mapping.generatedColumn) {
            <span class="hljs-keyword">var</span> nextLine = remainingLines[remainingLinesIndex] || <span class="hljs-string">''</span>;
            node.add(nextLine.substr(<span class="hljs-number">0</span>, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
    }, <span class="hljs-keyword">this</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-162" id="section-162"></a>
</div>
<p>We have processed all mappings.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (remainingLinesIndex &lt; remainingLines.length) {
        <span class="hljs-keyword">if</span> (lastMapping) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-163" id="section-163"></a>
</div>
<p>Associate the remaining code in the current line with &quot;lastMapping&quot;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            addMappingWithCode(lastMapping, shiftNextLine());
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-164" id="section-164"></a>
</div>
<p>and add the remaining lines without any mapping</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        node.add(remainingLines.splice(remainingLinesIndex).join(<span class="hljs-string">""</span>));
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-165" id="section-165"></a>
</div>
<p>Copy sourcesContent into SourceNode</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    aSourceMapConsumer.sources.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sourceFile</span>) </span>{
        <span class="hljs-keyword">var</span> content = aSourceMapConsumer.sourceContentFor(sourceFile);
        <span class="hljs-keyword">if</span> (content != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (aRelativePath != <span class="hljs-literal">null</span>) {
                sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
        }
    });
    <span class="hljs-keyword">return</span> node;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-166" id="section-166"></a>
</div>
<p>TURBOPACK unreachable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    ;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addMappingWithCode</span>(<span class="hljs-params">mapping, code</span>) </span>{
        <span class="hljs-keyword">if</span> (mapping === <span class="hljs-literal">null</span> || mapping.source === <span class="hljs-literal">undefined</span>) {
            node.add(code);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(<span class="hljs-keyword">new</span> SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-167" id="section-167"></a>
</div>
<div class="dox">
<div class="summary">
<p>Add a chunk of generated JS to this source node.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aChunk</span>
<span>A string snippet of generated JS code, another instance of        SourceNode, or an array where each member is one of those things.
SourceNode.prototype.add = function SourceNode_add(aChunk) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(aChunk)) {
        aChunk.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>) </span>{
            <span class="hljs-keyword">this</span>.add(chunk);
        }, <span class="hljs-keyword">this</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aChunk[isSourceNode] || <span class="hljs-keyword">typeof</span> aChunk === <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">if</span> (aChunk) {
            <span class="hljs-keyword">this</span>.children.push(aChunk);
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Expected a SourceNode, string, or an array of SourceNodes and strings. Got "</span> + aChunk);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-168" id="section-168"></a>
</div>
<div class="dox">
<div class="summary">
<p>Add a chunk of generated JS to the beginning of this source node.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aChunk</span>
<span>A string snippet of generated JS code, another instance of        SourceNode, or an array where each member is one of those things.
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(aChunk)) {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = aChunk.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
            <span class="hljs-keyword">this</span>.prepend(aChunk[i]);
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aChunk[isSourceNode] || <span class="hljs-keyword">typeof</span> aChunk === <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">this</span>.children.unshift(aChunk);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Expected a SourceNode, string, or an array of SourceNodes and strings. Got "</span> + aChunk);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-169" id="section-169"></a>
</div>
<div class="dox">
<div class="summary">
<p>Walk over the tree of JS snippets in this node and its children. The
walking function is called once for each snippet of JS and is passed that
snippet and the its original associated source's line/column location.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aFn</span>
<span>The traversal function. SourceNode.prototype.walk = function SourceNode_walk(aFn) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> chunk;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-keyword">this</span>.children.length; i &lt; len; i++){
        chunk = <span class="hljs-keyword">this</span>.children[i];
        <span class="hljs-keyword">if</span> (chunk[isSourceNode]) {
            chunk.walk(aFn);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (chunk !== <span class="hljs-string">''</span>) {
                aFn(chunk, {
                    <span class="hljs-attr">source</span>: <span class="hljs-keyword">this</span>.source,
                    <span class="hljs-attr">line</span>: <span class="hljs-keyword">this</span>.line,
                    <span class="hljs-attr">column</span>: <span class="hljs-keyword">this</span>.column,
                    <span class="hljs-attr">name</span>: <span class="hljs-keyword">this</span>.name
                });
            }
        }
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-170" id="section-170"></a>
</div>
<div class="dox">
<div class="summary">
<p>Like <code>String.prototype.join</code> except for SourceNodes. Inserts <code>aStr</code> between
each of <code>this.children</code>.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSep</span>
<span>The separator. SourceNode.prototype.join = function SourceNode_join(aSep) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> newChildren;
    <span class="hljs-keyword">var</span> i;
    <span class="hljs-keyword">var</span> len = <span class="hljs-keyword">this</span>.children.length;
    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) {
        newChildren = [];
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++){
            newChildren.push(<span class="hljs-keyword">this</span>.children[i]);
            newChildren.push(aSep);
        }
        newChildren.push(<span class="hljs-keyword">this</span>.children[i]);
        <span class="hljs-keyword">this</span>.children = newChildren;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-171" id="section-171"></a>
</div>
<div class="dox">
<div class="summary">
<p>Call String.prototype.replace on the very right-most source snippet. Useful
for trimming whitespace from the end of a source node, etc.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aPattern</span>
<span>The pattern to replace.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aReplacement</span>
<span>The thing to replace the pattern with. SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> lastChild = <span class="hljs-keyword">this</span>.children[<span class="hljs-keyword">this</span>.children.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> lastChild === <span class="hljs-string">'string'</span>) {
        <span class="hljs-keyword">this</span>.children[<span class="hljs-keyword">this</span>.children.length - <span class="hljs-number">1</span>] = lastChild.replace(aPattern, aReplacement);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.children.push(<span class="hljs-string">''</span>.replace(aPattern, aReplacement));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-172" id="section-172"></a>
</div>
<div class="dox">
<div class="summary">
<p>Set the source content for a source file. This will be added to the SourceMapGenerator
in the sourcesContent field.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSourceFile</span>
<span>The filename of the source file
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aSourceContent</span>
<span>The content of the source file SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-173" id="section-173"></a>
</div>
<div class="dox">
<div class="summary">
<p>Walk over the tree of SourceNodes. The walking function is called for each
source file content and is passed the filename and source content.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">aFn</span>
<span>The traversal function. SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-keyword">this</span>.children.length; i &lt; len; i++){
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.children[i][isSourceNode]) {
            <span class="hljs-keyword">this</span>.children[i].walkSourceContents(aFn);
        }
    }
    <span class="hljs-keyword">var</span> sources = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.sourceContents);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = sources.length; i &lt; len; i++){
        aFn(util.fromSetString(sources[i]), <span class="hljs-keyword">this</span>.sourceContents[sources[i]]);
    }
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-174" id="section-174"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return the string representation of this source node. Walks over the tree
and concatenates all the various snippets together to one string.
SourceNode.prototype.toString = function SourceNode_toString() {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> str = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">this</span>.walk(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>) </span>{
        str += chunk;
    });
    <span class="hljs-keyword">return</span> str;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-175" id="section-175"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the string representation of this source node along with a source
map.
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> generated = {
        <span class="hljs-attr">code</span>: <span class="hljs-string">""</span>,
        <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>
    };
    <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> SourceMapGenerator(aArgs);
    <span class="hljs-keyword">var</span> sourceMappingActive = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> lastOriginalSource = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> lastOriginalLine = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> lastOriginalColumn = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> lastOriginalName = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.walk(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chunk, original</span>) </span>{
        generated.code += chunk;
        <span class="hljs-keyword">if</span> (original.source !== <span class="hljs-literal">null</span> &amp;&amp; original.line !== <span class="hljs-literal">null</span> &amp;&amp; original.column !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                map.addMapping({
                    <span class="hljs-attr">source</span>: original.source,
                    <span class="hljs-attr">original</span>: {
                        <span class="hljs-attr">line</span>: original.line,
                        <span class="hljs-attr">column</span>: original.column
                    },
                    <span class="hljs-attr">generated</span>: {
                        <span class="hljs-attr">line</span>: generated.line,
                        <span class="hljs-attr">column</span>: generated.column
                    },
                    <span class="hljs-attr">name</span>: original.name
                });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sourceMappingActive) {
            map.addMapping({
                <span class="hljs-attr">generated</span>: {
                    <span class="hljs-attr">line</span>: generated.line,
                    <span class="hljs-attr">column</span>: generated.column
                }
            });
            lastOriginalSource = <span class="hljs-literal">null</span>;
            sourceMappingActive = <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, length = chunk.length; idx &lt; length; idx++){
            <span class="hljs-keyword">if</span> (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = <span class="hljs-number">0</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-176" id="section-176"></a>
</div>
<p>Mappings end at eol</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">if</span> (idx + <span class="hljs-number">1</span> === length) {
                    lastOriginalSource = <span class="hljs-literal">null</span>;
                    sourceMappingActive = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sourceMappingActive) {
                    map.addMapping({
                        <span class="hljs-attr">source</span>: original.source,
                        <span class="hljs-attr">original</span>: {
                            <span class="hljs-attr">line</span>: original.line,
                            <span class="hljs-attr">column</span>: original.column
                        },
                        <span class="hljs-attr">generated</span>: {
                            <span class="hljs-attr">line</span>: generated.line,
                            <span class="hljs-attr">column</span>: generated.column
                        },
                        <span class="hljs-attr">name</span>: original.name
                    });
                }
            } <span class="hljs-keyword">else</span> {
                generated.column++;
            }
        }
    });
    <span class="hljs-keyword">this</span>.walkSourceContents(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sourceFile, sourceContent</span>) </span>{
        map.setSourceContent(sourceFile, sourceContent);
    });
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: generated.code,
        <span class="hljs-attr">map</span>: map
    };
};
exports.SourceNode = SourceNode;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-177" id="section-177"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright 2009-2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE.txt or:
http://opensource.org/licenses/BSD-3-Clause
exports.SourceMapGenerator = <strong>turbopack_context</strong>.r(&quot;[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)&quot;).SourceMapGenerator;</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.SourceMapConsumer = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)"</span>).SourceMapConsumer;
exports.SourceNode = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)"</span>).SourceNode;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-178" id="section-178"></a>
</div>
<p>This alphabet uses <code>A-Za-z0-9_-</code> symbols.
The order of characters is optimized for better gzip and brotli compression.
References to the same file (works both for gzip and brotli):
<code>'use</code>, <code>andom</code>, and <code>rict'</code>
References to the brotli default dictionary:
<code>-26T</code>, <code>1983</code>, <code>40px</code>, <code>75px</code>, <code>bush</code>, <code>jack</code>, <code>mind</code>, <code>very</code>, and <code>wolf</code></p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">let</span> urlAlphabet = <span class="hljs-string">'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'</span>;
<span class="hljs-keyword">let</span> customAlphabet = <span class="hljs-function">(<span class="hljs-params">alphabet, defaultSize = <span class="hljs-number">21</span></span>)=&gt;</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">size = defaultSize</span>)=&gt;</span>{
        <span class="hljs-keyword">let</span> id = <span class="hljs-string">''</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-179" id="section-179"></a>
</div>
<p>A compact alternative for <code>for (var i = 0; i &lt; step; i++)</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">let</span> i = size | <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(i--){
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-180" id="section-180"></a>
</div>
<p><code>| 0</code> is more compact and faster than <code>Math.floor()</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            id += alphabet[<span class="hljs-built_in">Math</span>.random() * alphabet.length | <span class="hljs-number">0</span>];
        }
        <span class="hljs-keyword">return</span> id;
    };
};
<span class="hljs-keyword">let</span> nanoid = <span class="hljs-function">(<span class="hljs-params">size = <span class="hljs-number">21</span></span>)=&gt;</span>{
    <span class="hljs-keyword">let</span> id = <span class="hljs-string">''</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-181" id="section-181"></a>
</div>
<p>A compact alternative for <code>for (var i = 0; i &lt; step; i++)</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">let</span> i = size | <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(i--){
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-182" id="section-182"></a>
</div>
<p><code>| 0</code> is more compact and faster than <code>Math.floor()</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        id += urlAlphabet[<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">64</span> | <span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">return</span> id;
};
<span class="hljs-built_in">module</span>.exports = {
    nanoid,
    customAlphabet
};
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> { SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> { existsSync, readFileSync } = __turbopack_context__.r(<span class="hljs-string">"[externals]/fs [external] (fs, cjs)"</span>);
<span class="hljs-keyword">let</span> { dirname, join } = __turbopack_context__.r(<span class="hljs-string">"[externals]/path [external] (path, cjs)"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromBase64</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time truthy"</span>, <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> Buffer.from(str, <span class="hljs-string">'base64'</span>).toString();
    } <span class="hljs-keyword">else</span> <span class="hljs-comment">//TURBOPACK unreachable</span>
    ;
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreviousMap</span> </span>{
    <span class="hljs-keyword">constructor</span>(css, opts){
        <span class="hljs-keyword">if</span> (opts.map === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">this</span>.loadAnnotation(css);
        <span class="hljs-keyword">this</span>.inline = <span class="hljs-keyword">this</span>.startWith(<span class="hljs-keyword">this</span>.annotation, <span class="hljs-string">'data:'</span>);
        <span class="hljs-keyword">let</span> prev = opts.map ? opts.map.prev : <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">let</span> text = <span class="hljs-keyword">this</span>.loadMap(opts.from, prev);
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.mapFile &amp;&amp; opts.from) {
            <span class="hljs-keyword">this</span>.mapFile = opts.from;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mapFile) <span class="hljs-keyword">this</span>.root = dirname(<span class="hljs-keyword">this</span>.mapFile);
        <span class="hljs-keyword">if</span> (text) <span class="hljs-keyword">this</span>.text = text;
    }
    consumer() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.consumerCache) {
            <span class="hljs-keyword">this</span>.consumerCache = <span class="hljs-keyword">new</span> SourceMapConsumer(<span class="hljs-keyword">this</span>.text);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.consumerCache;
    }
    decodeInline(text) {
        <span class="hljs-keyword">let</span> baseCharsetUri = <span class="hljs-regexp">/^data:application\/json;charset=utf-?8;base64,/</span>;
        <span class="hljs-keyword">let</span> baseUri = <span class="hljs-regexp">/^data:application\/json;base64,/</span>;
        <span class="hljs-keyword">let</span> charsetUri = <span class="hljs-regexp">/^data:application\/json;charset=utf-?8,/</span>;
        <span class="hljs-keyword">let</span> uri = <span class="hljs-regexp">/^data:application\/json,/</span>;
        <span class="hljs-keyword">if</span> (charsetUri.test(text) || uri.test(text)) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">decodeURIComponent</span>(text.substr(<span class="hljs-built_in">RegExp</span>.lastMatch.length));
        }
        <span class="hljs-keyword">if</span> (baseCharsetUri.test(text) || baseUri.test(text)) {
            <span class="hljs-keyword">return</span> fromBase64(text.substr(<span class="hljs-built_in">RegExp</span>.lastMatch.length));
        }
        <span class="hljs-keyword">let</span> encoding = text.match(<span class="hljs-regexp">/data:application\/json;([^,]+),/</span>)[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported source map encoding '</span> + encoding);
    }
    getAnnotationURL(sourceMapString) {
        <span class="hljs-keyword">return</span> sourceMapString.replace(<span class="hljs-regexp">/^\/\*\s*# sourceMappingURL=/</span>, <span class="hljs-string">''</span>).trim();
    }
    isMap(map) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> map !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> map.mappings === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> map._mappings === <span class="hljs-string">'string'</span> || <span class="hljs-built_in">Array</span>.isArray(map.sections);
    }
    loadAnnotation(css) {
        <span class="hljs-keyword">let</span> comments = css.match(<span class="hljs-regexp">/\/\*\s*# sourceMappingURL=/gm</span>);
        <span class="hljs-keyword">if</span> (!comments) <span class="hljs-keyword">return</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-183" id="section-183"></a>
</div>
<p>sourceMappingURLs from comments, strings, etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">let</span> start = css.lastIndexOf(comments.pop());
        <span class="hljs-keyword">let</span> end = css.indexOf(<span class="hljs-string">'*/'</span>, start);
        <span class="hljs-keyword">if</span> (start &gt; <span class="hljs-number">-1</span> &amp;&amp; end &gt; <span class="hljs-number">-1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-184" id="section-184"></a>
</div>
<p>Locate the last sourceMappingURL to avoid pickin</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">this</span>.annotation = <span class="hljs-keyword">this</span>.getAnnotationURL(css.substring(start, end));
        }
    }
    loadFile(path) {
        <span class="hljs-keyword">this</span>.root = dirname(path);
        <span class="hljs-keyword">if</span> (existsSync(path)) {
            <span class="hljs-keyword">this</span>.mapFile = path;
            <span class="hljs-keyword">return</span> readFileSync(path, <span class="hljs-string">'utf-8'</span>).toString().trim();
        }
    }
    loadMap(file, prev) {
        <span class="hljs-keyword">if</span> (prev === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (prev) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> prev === <span class="hljs-string">'string'</span>) {
                <span class="hljs-keyword">return</span> prev;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> prev === <span class="hljs-string">'function'</span>) {
                <span class="hljs-keyword">let</span> prevPath = prev(file);
                <span class="hljs-keyword">if</span> (prevPath) {
                    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">this</span>.loadFile(prevPath);
                    <span class="hljs-keyword">if</span> (!map) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unable to load previous source map: '</span> + prevPath.toString());
                    }
                    <span class="hljs-keyword">return</span> map;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prev <span class="hljs-keyword">instanceof</span> SourceMapConsumer) {
                <span class="hljs-keyword">return</span> SourceMapGenerator.fromSourceMap(prev).toString();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prev <span class="hljs-keyword">instanceof</span> SourceMapGenerator) {
                <span class="hljs-keyword">return</span> prev.toString();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isMap(prev)) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(prev);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported previous source map format: '</span> + prev.toString());
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.inline) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.decodeInline(<span class="hljs-keyword">this</span>.annotation);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.annotation) {
            <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">this</span>.annotation;
            <span class="hljs-keyword">if</span> (file) map = join(dirname(file), map);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadFile(map);
        }
    }
    startWith(string, start) {
        <span class="hljs-keyword">if</span> (!string) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> string.substr(<span class="hljs-number">0</span>, start.length) === start;
    }
    withContent() {
        <span class="hljs-keyword">return</span> !!(<span class="hljs-keyword">this</span>.consumer().sourcesContent &amp;&amp; <span class="hljs-keyword">this</span>.consumer().sourcesContent.length &gt; <span class="hljs-number">0</span>);
    }
}
<span class="hljs-built_in">module</span>.exports = PreviousMap;
PreviousMap.default = PreviousMap;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/input.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> { SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> { fileURLToPath, pathToFileURL } = __turbopack_context__.r(<span class="hljs-string">"[externals]/url [external] (url, cjs)"</span>);
<span class="hljs-keyword">let</span> { isAbsolute, resolve } = __turbopack_context__.r(<span class="hljs-string">"[externals]/path [external] (path, cjs)"</span>);
<span class="hljs-keyword">let</span> { nanoid } = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> terminalHighlight = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> CssSyntaxError = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> PreviousMap = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> fromOffsetCache = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fromOffsetCache'</span>);
<span class="hljs-keyword">let</span> sourceMapAvailable = <span class="hljs-built_in">Boolean</span>(SourceMapConsumer &amp;&amp; SourceMapGenerator);
<span class="hljs-keyword">let</span> pathAvailable = <span class="hljs-built_in">Boolean</span>(resolve &amp;&amp; isAbsolute);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> </span>{
    <span class="hljs-keyword">constructor</span>(css, opts = {}){
        <span class="hljs-keyword">if</span> (css === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> css === <span class="hljs-string">'undefined'</span> || <span class="hljs-keyword">typeof</span> css === <span class="hljs-string">'object'</span> &amp;&amp; !css.toString) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`PostCSS received <span class="hljs-subst">${css}</span> instead of CSS string`</span>);
        }
        <span class="hljs-keyword">this</span>.css = css.toString();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.css[<span class="hljs-number">0</span>] === <span class="hljs-string">'\uFEFF'</span> || <span class="hljs-keyword">this</span>.css[<span class="hljs-number">0</span>] === <span class="hljs-string">'\uFFFE'</span>) {
            <span class="hljs-keyword">this</span>.hasBOM = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">this</span>.css = <span class="hljs-keyword">this</span>.css.slice(<span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.hasBOM = <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> (opts.from) {
            <span class="hljs-keyword">if</span> (!pathAvailable || <span class="hljs-regexp">/^\w+:\/\//</span>.test(opts.from) || isAbsolute(opts.from)) {
                <span class="hljs-keyword">this</span>.file = opts.from;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.file = resolve(opts.from);
            }
        }
        <span class="hljs-keyword">if</span> (pathAvailable &amp;&amp; sourceMapAvailable) {
            <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> PreviousMap(<span class="hljs-keyword">this</span>.css, opts);
            <span class="hljs-keyword">if</span> (map.text) {
                <span class="hljs-keyword">this</span>.map = map;
                <span class="hljs-keyword">let</span> file = map.consumer().file;
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.file &amp;&amp; file) <span class="hljs-keyword">this</span>.file = <span class="hljs-keyword">this</span>.mapResolve(file);
            }
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.file) {
            <span class="hljs-keyword">this</span>.id = <span class="hljs-string">'&lt;input css '</span> + nanoid(<span class="hljs-number">6</span>) + <span class="hljs-string">'&gt;'</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.map) <span class="hljs-keyword">this</span>.map.file = <span class="hljs-keyword">this</span>.from;
    }
    error(message, line, column, opts = {}) {
        <span class="hljs-keyword">let</span> result, endLine, endColumn;
        <span class="hljs-keyword">if</span> (line &amp;&amp; <span class="hljs-keyword">typeof</span> line === <span class="hljs-string">'object'</span>) {
            <span class="hljs-keyword">let</span> start = line;
            <span class="hljs-keyword">let</span> end = column;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> start.offset === <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.fromOffset(start.offset);
                line = pos.line;
                column = pos.col;
            } <span class="hljs-keyword">else</span> {
                line = start.line;
                column = start.column;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> end.offset === <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.fromOffset(end.offset);
                endLine = pos.line;
                endColumn = pos.col;
            } <span class="hljs-keyword">else</span> {
                endLine = end.line;
                endColumn = end.column;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!column) {
            <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.fromOffset(line);
            line = pos.line;
            column = pos.col;
        }
        <span class="hljs-keyword">let</span> origin = <span class="hljs-keyword">this</span>.origin(line, column, endLine, endColumn);
        <span class="hljs-keyword">if</span> (origin) {
            result = <span class="hljs-keyword">new</span> CssSyntaxError(message, origin.endLine === <span class="hljs-literal">undefined</span> ? origin.line : {
                <span class="hljs-attr">column</span>: origin.column,
                <span class="hljs-attr">line</span>: origin.line
            }, origin.endLine === <span class="hljs-literal">undefined</span> ? origin.column : {
                <span class="hljs-attr">column</span>: origin.endColumn,
                <span class="hljs-attr">line</span>: origin.endLine
            }, origin.source, origin.file, opts.plugin);
        } <span class="hljs-keyword">else</span> {
            result = <span class="hljs-keyword">new</span> CssSyntaxError(message, endLine === <span class="hljs-literal">undefined</span> ? line : {
                column,
                line
            }, endLine === <span class="hljs-literal">undefined</span> ? column : {
                <span class="hljs-attr">column</span>: endColumn,
                <span class="hljs-attr">line</span>: endLine
            }, <span class="hljs-keyword">this</span>.css, <span class="hljs-keyword">this</span>.file, opts.plugin);
        }
        result.input = {
            column,
            endColumn,
            endLine,
            line,
            <span class="hljs-attr">source</span>: <span class="hljs-keyword">this</span>.css
        };
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.file) {
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time truthy"</span>, <span class="hljs-number">1</span>) {
                result.input.url = pathToFileURL(<span class="hljs-keyword">this</span>.file).toString();
            }
            result.input.file = <span class="hljs-keyword">this</span>.file;
        }
        <span class="hljs-keyword">return</span> result;
    }
    fromOffset(offset) {
        <span class="hljs-keyword">let</span> lastLine, lineToIndex;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>[fromOffsetCache]) {
            <span class="hljs-keyword">let</span> lines = <span class="hljs-keyword">this</span>.css.split(<span class="hljs-string">'\n'</span>);
            lineToIndex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(lines.length);
            <span class="hljs-keyword">let</span> prevIndex = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = lines.length; i &lt; l; i++){
                lineToIndex[i] = prevIndex;
                prevIndex += lines[i].length + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">this</span>[fromOffsetCache] = lineToIndex;
        } <span class="hljs-keyword">else</span> {
            lineToIndex = <span class="hljs-keyword">this</span>[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> min = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (offset &gt;= lastLine) {
            min = lineToIndex.length - <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> max = lineToIndex.length - <span class="hljs-number">2</span>;
            <span class="hljs-keyword">let</span> mid;
            <span class="hljs-keyword">while</span>(min &lt; max){
                mid = min + (max - min &gt;&gt; <span class="hljs-number">1</span>);
                <span class="hljs-keyword">if</span> (offset &lt; lineToIndex[mid]) {
                    max = mid - <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset &gt;= lineToIndex[mid + <span class="hljs-number">1</span>]) {
                    min = mid + <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> {
                    min = mid;
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">col</span>: offset - lineToIndex[min] + <span class="hljs-number">1</span>,
            <span class="hljs-attr">line</span>: min + <span class="hljs-number">1</span>
        };
    }
    mapResolve(file) {
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\w+:\/\//</span>.test(file)) {
            <span class="hljs-keyword">return</span> file;
        }
        <span class="hljs-keyword">return</span> resolve(<span class="hljs-keyword">this</span>.map.consumer().sourceRoot || <span class="hljs-keyword">this</span>.map.root || <span class="hljs-string">'.'</span>, file);
    }
    origin(line, column, endLine, endColumn) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.map) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> consumer = <span class="hljs-keyword">this</span>.map.consumer();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span> = consumer.originalPositionFor({
            column,
            line
        });
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>.source) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> to;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> endLine === <span class="hljs-string">'number'</span>) {
            to = consumer.originalPositionFor({
                <span class="hljs-attr">column</span>: endColumn,
                <span class="hljs-attr">line</span>: endLine
            });
        }
        <span class="hljs-keyword">let</span> fromUrl;
        <span class="hljs-keyword">if</span> (isAbsolute(<span class="hljs-keyword">from</span>.source)) {
            fromUrl = pathToFileURL(<span class="hljs-keyword">from</span>.source);
        } <span class="hljs-keyword">else</span> {
            fromUrl = <span class="hljs-keyword">new</span> URL(<span class="hljs-keyword">from</span>.source, <span class="hljs-keyword">this</span>.map.consumer().sourceRoot || pathToFileURL(<span class="hljs-keyword">this</span>.map.mapFile));
        }
        <span class="hljs-keyword">let</span> result = {
            <span class="hljs-attr">column</span>: <span class="hljs-keyword">from</span>.column,
            <span class="hljs-attr">endColumn</span>: to &amp;&amp; to.column,
            <span class="hljs-attr">endLine</span>: to &amp;&amp; to.line,
            <span class="hljs-attr">line</span>: <span class="hljs-keyword">from</span>.line,
            <span class="hljs-attr">url</span>: fromUrl.toString()
        };
        <span class="hljs-keyword">if</span> (fromUrl.protocol === <span class="hljs-string">'file:'</span>) {
            <span class="hljs-keyword">if</span> (fileURLToPath) {
                result.file = fileURLToPath(fromUrl);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* c8 ignore next 2 */</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`file: protocol is not available in this PostCSS build`</span>);
            }
        }
        <span class="hljs-keyword">let</span> source = consumer.sourceContentFor(<span class="hljs-keyword">from</span>.source);
        <span class="hljs-keyword">if</span> (source) result.source = source;
        <span class="hljs-keyword">return</span> result;
    }
    toJSON() {
        <span class="hljs-keyword">let</span> json = {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> name <span class="hljs-keyword">of</span> [
            <span class="hljs-string">'hasBOM'</span>,
            <span class="hljs-string">'css'</span>,
            <span class="hljs-string">'file'</span>,
            <span class="hljs-string">'id'</span>
        ]){
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[name] != <span class="hljs-literal">null</span>) {
                json[name] = <span class="hljs-keyword">this</span>[name];
            }
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.map) {
            json.map = {
                ...this.map
            };
            <span class="hljs-keyword">if</span> (json.map.consumerCache) {
                json.map.consumerCache = <span class="hljs-literal">undefined</span>;
            }
        }
        <span class="hljs-keyword">return</span> json;
    }
    <span class="hljs-keyword">get</span> from() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.file || <span class="hljs-keyword">this</span>.id;
    }
}
<span class="hljs-built_in">module</span>.exports = Input;
Input.default = Input;
<span class="hljs-keyword">if</span> (terminalHighlight &amp;&amp; terminalHighlight.registerInput) {
    terminalHighlight.registerInput(Input);
}
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> { SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> { dirname, relative, resolve, sep } = __turbopack_context__.r(<span class="hljs-string">"[externals]/path [external] (path, cjs)"</span>);
<span class="hljs-keyword">let</span> { pathToFileURL } = __turbopack_context__.r(<span class="hljs-string">"[externals]/url [external] (url, cjs)"</span>);
<span class="hljs-keyword">let</span> Input = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/input.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> sourceMapAvailable = <span class="hljs-built_in">Boolean</span>(SourceMapConsumer &amp;&amp; SourceMapGenerator);
<span class="hljs-keyword">let</span> pathAvailable = <span class="hljs-built_in">Boolean</span>(dirname &amp;&amp; resolve &amp;&amp; relative &amp;&amp; sep);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapGenerator</span> </span>{
    <span class="hljs-keyword">constructor</span>(stringify, root, opts, cssString){
        <span class="hljs-keyword">this</span>.stringify = stringify;
        <span class="hljs-keyword">this</span>.mapOpts = opts.map || {};
        <span class="hljs-keyword">this</span>.root = root;
        <span class="hljs-keyword">this</span>.opts = opts;
        <span class="hljs-keyword">this</span>.css = cssString;
        <span class="hljs-keyword">this</span>.usesFileUrls = !<span class="hljs-keyword">this</span>.mapOpts.from &amp;&amp; <span class="hljs-keyword">this</span>.mapOpts.absolute;
        <span class="hljs-keyword">this</span>.memoizedFileURLs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
        <span class="hljs-keyword">this</span>.memoizedPaths = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
        <span class="hljs-keyword">this</span>.memoizedURLs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    }
    addAnnotation() {
        <span class="hljs-keyword">let</span> content;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isInline()) {
            content = <span class="hljs-string">'data:application/json;base64,'</span> + <span class="hljs-keyword">this</span>.toBase64(<span class="hljs-keyword">this</span>.map.toString());
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.mapOpts.annotation === <span class="hljs-string">'string'</span>) {
            content = <span class="hljs-keyword">this</span>.mapOpts.annotation;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.mapOpts.annotation === <span class="hljs-string">'function'</span>) {
            content = <span class="hljs-keyword">this</span>.mapOpts.annotation(<span class="hljs-keyword">this</span>.opts.to, <span class="hljs-keyword">this</span>.root);
        } <span class="hljs-keyword">else</span> {
            content = <span class="hljs-keyword">this</span>.outputFile() + <span class="hljs-string">'.map'</span>;
        }
        <span class="hljs-keyword">let</span> eol = <span class="hljs-string">'\n'</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.css.includes(<span class="hljs-string">'\r\n'</span>)) eol = <span class="hljs-string">'\r\n'</span>;
        <span class="hljs-keyword">this</span>.css += eol + <span class="hljs-string">'/*# sourceMappingURL='</span> + content + <span class="hljs-string">' */'</span>;
    }
    applyPrevMaps() {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prev <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.previous()){
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span> = <span class="hljs-keyword">this</span>.toUrl(<span class="hljs-keyword">this</span>.path(prev.file));
            <span class="hljs-keyword">let</span> root = prev.root || dirname(prev.file);
            <span class="hljs-keyword">let</span> map;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mapOpts.sourcesContent === <span class="hljs-literal">false</span>) {
                map = <span class="hljs-keyword">new</span> SourceMapConsumer(prev.text);
                <span class="hljs-keyword">if</span> (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-literal">null</span>);
                }
            } <span class="hljs-keyword">else</span> {
                map = prev.consumer();
            }
            <span class="hljs-keyword">this</span>.map.applySourceMap(map, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">this</span>.toUrl(<span class="hljs-keyword">this</span>.path(root)));
        }
    }
    clearAnnotation() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mapOpts.annotation === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root) {
            <span class="hljs-keyword">let</span> node;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-keyword">this</span>.root.nodes.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
                node = <span class="hljs-keyword">this</span>.root.nodes[i];
                <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'comment'</span>) <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">if</span> (node.text.indexOf(<span class="hljs-string">'# sourceMappingURL='</span>) === <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">this</span>.root.removeChild(i);
                }
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.css) {
            <span class="hljs-keyword">this</span>.css = <span class="hljs-keyword">this</span>.css.replace(<span class="hljs-regexp">/(\n)?\/\*#[\S\s]*?\*\/$/gm</span>, <span class="hljs-string">''</span>);
        }
    }
    generate() {
        <span class="hljs-keyword">this</span>.clearAnnotation();
        <span class="hljs-keyword">if</span> (pathAvailable &amp;&amp; sourceMapAvailable &amp;&amp; <span class="hljs-keyword">this</span>.isMap()) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.generateMap();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;
            <span class="hljs-keyword">this</span>.stringify(<span class="hljs-keyword">this</span>.root, (i)=&gt;{
                result += i;
            });
            <span class="hljs-keyword">return</span> [
                result
            ];
        }
    }
    generateMap() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root) {
            <span class="hljs-keyword">this</span>.generateString();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.previous().length === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">this</span>.previous()[<span class="hljs-number">0</span>].consumer();
            prev.file = <span class="hljs-keyword">this</span>.outputFile();
            <span class="hljs-keyword">this</span>.map = SourceMapGenerator.fromSourceMap(prev);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> SourceMapGenerator({
                <span class="hljs-attr">file</span>: <span class="hljs-keyword">this</span>.outputFile()
            });
            <span class="hljs-keyword">this</span>.map.addMapping({
                <span class="hljs-attr">generated</span>: {
                    <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>
                },
                <span class="hljs-attr">original</span>: {
                    <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>
                },
                <span class="hljs-attr">source</span>: <span class="hljs-keyword">this</span>.opts.from ? <span class="hljs-keyword">this</span>.toUrl(<span class="hljs-keyword">this</span>.path(<span class="hljs-keyword">this</span>.opts.from)) : <span class="hljs-string">'&lt;no source&gt;'</span>
            });
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isSourcesContent()) <span class="hljs-keyword">this</span>.setSourcesContent();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root &amp;&amp; <span class="hljs-keyword">this</span>.previous().length &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.applyPrevMaps();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isAnnotation()) <span class="hljs-keyword">this</span>.addAnnotation();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isInline()) {
            <span class="hljs-keyword">return</span> [
                <span class="hljs-keyword">this</span>.css
            ];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> [
                <span class="hljs-keyword">this</span>.css,
                <span class="hljs-keyword">this</span>.map
            ];
        }
    }
    generateString() {
        <span class="hljs-keyword">this</span>.css = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> SourceMapGenerator({
            <span class="hljs-attr">file</span>: <span class="hljs-keyword">this</span>.outputFile()
        });
        <span class="hljs-keyword">let</span> line = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">let</span> column = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">let</span> noSource = <span class="hljs-string">'&lt;no source&gt;'</span>;
        <span class="hljs-keyword">let</span> mapping = {
            <span class="hljs-attr">generated</span>: {
                <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">line</span>: <span class="hljs-number">0</span>
            },
            <span class="hljs-attr">original</span>: {
                <span class="hljs-attr">column</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">line</span>: <span class="hljs-number">0</span>
            },
            <span class="hljs-attr">source</span>: <span class="hljs-string">''</span>
        };
        <span class="hljs-keyword">let</span> lines, last;
        <span class="hljs-keyword">this</span>.stringify(<span class="hljs-keyword">this</span>.root, (str, node, type)=&gt;{
            <span class="hljs-keyword">this</span>.css += str;
            <span class="hljs-keyword">if</span> (node &amp;&amp; type !== <span class="hljs-string">'end'</span>) {
                mapping.generated.line = line;
                mapping.generated.column = column - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (node.source &amp;&amp; node.source.start) {
                    mapping.source = <span class="hljs-keyword">this</span>.sourcePath(node);
                    mapping.original.line = node.source.start.line;
                    mapping.original.column = node.source.start.column - <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">this</span>.map.addMapping(mapping);
                } <span class="hljs-keyword">else</span> {
                    mapping.source = noSource;
                    mapping.original.line = <span class="hljs-number">1</span>;
                    mapping.original.column = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">this</span>.map.addMapping(mapping);
                }
            }
            lines = str.match(<span class="hljs-regexp">/\n/g</span>);
            <span class="hljs-keyword">if</span> (lines) {
                line += lines.length;
                last = str.lastIndexOf(<span class="hljs-string">'\n'</span>);
                column = str.length - last;
            } <span class="hljs-keyword">else</span> {
                column += str.length;
            }
            <span class="hljs-keyword">if</span> (node &amp;&amp; type !== <span class="hljs-string">'start'</span>) {
                <span class="hljs-keyword">let</span> p = node.parent || {
                    <span class="hljs-attr">raws</span>: {}
                };
                <span class="hljs-keyword">let</span> childless = node.type === <span class="hljs-string">'decl'</span> || node.type === <span class="hljs-string">'atrule'</span> &amp;&amp; !node.nodes;
                <span class="hljs-keyword">if</span> (!childless || node !== p.last || p.raws.semicolon) {
                    <span class="hljs-keyword">if</span> (node.source &amp;&amp; node.source.end) {
                        mapping.source = <span class="hljs-keyword">this</span>.sourcePath(node);
                        mapping.original.line = node.source.end.line;
                        mapping.original.column = node.source.end.column - <span class="hljs-number">1</span>;
                        mapping.generated.line = line;
                        mapping.generated.column = column - <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">this</span>.map.addMapping(mapping);
                    } <span class="hljs-keyword">else</span> {
                        mapping.source = noSource;
                        mapping.original.line = <span class="hljs-number">1</span>;
                        mapping.original.column = <span class="hljs-number">0</span>;
                        mapping.generated.line = line;
                        mapping.generated.column = column - <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">this</span>.map.addMapping(mapping);
                    }
                }
            }
        });
    }
    isAnnotation() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isInline()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.mapOpts.annotation !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mapOpts.annotation;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.previous().length) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.previous().some(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i.annotation);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    isInline() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.mapOpts.inline !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mapOpts.inline;
        }
        <span class="hljs-keyword">let</span> annotation = <span class="hljs-keyword">this</span>.mapOpts.annotation;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> annotation !== <span class="hljs-string">'undefined'</span> &amp;&amp; annotation !== <span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.previous().length) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.previous().some(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i.inline);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    isMap() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.opts.map !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.opts.map;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.previous().length &gt; <span class="hljs-number">0</span>;
    }
    isSourcesContent() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.mapOpts.sourcesContent !== <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mapOpts.sourcesContent;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.previous().length) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.previous().some(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i.withContent());
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    outputFile() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.opts.to) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.path(<span class="hljs-keyword">this</span>.opts.to);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.opts.from) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.path(<span class="hljs-keyword">this</span>.opts.from);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'to.css'</span>;
        }
    }
    path(file) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mapOpts.absolute) <span class="hljs-keyword">return</span> file;
        <span class="hljs-keyword">if</span> (file.charCodeAt(<span class="hljs-number">0</span>) === <span class="hljs-number">60</span> <span class="hljs-comment">/* `&lt;` */</span> ) <span class="hljs-keyword">return</span> file;
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\w+:\/\//</span>.test(file)) <span class="hljs-keyword">return</span> file;
        <span class="hljs-keyword">let</span> cached = <span class="hljs-keyword">this</span>.memoizedPaths.get(file);
        <span class="hljs-keyword">if</span> (cached) <span class="hljs-keyword">return</span> cached;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span> = <span class="hljs-keyword">this</span>.opts.to ? dirname(<span class="hljs-keyword">this</span>.opts.to) : <span class="hljs-string">'.'</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.mapOpts.annotation === <span class="hljs-string">'string'</span>) {
            <span class="hljs-keyword">from</span> = dirname(resolve(<span class="hljs-keyword">from</span>, <span class="hljs-keyword">this</span>.mapOpts.annotation));
        }
        <span class="hljs-keyword">let</span> path = relative(<span class="hljs-keyword">from</span>, file);
        <span class="hljs-keyword">this</span>.memoizedPaths.set(file, path);
        <span class="hljs-keyword">return</span> path;
    }
    previous() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.previousMaps) {
            <span class="hljs-keyword">this</span>.previousMaps = [];
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root) {
                <span class="hljs-keyword">this</span>.root.walk(<span class="hljs-function">(<span class="hljs-params">node</span>)=&gt;</span>{
                    <span class="hljs-keyword">if</span> (node.source &amp;&amp; node.source.input.map) {
                        <span class="hljs-keyword">let</span> map = node.source.input.map;
                        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.previousMaps.includes(map)) {
                            <span class="hljs-keyword">this</span>.previousMaps.push(map);
                        }
                    }
                });
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> input = <span class="hljs-keyword">new</span> Input(<span class="hljs-keyword">this</span>.css, <span class="hljs-keyword">this</span>.opts);
                <span class="hljs-keyword">if</span> (input.map) <span class="hljs-keyword">this</span>.previousMaps.push(input.map);
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.previousMaps;
    }
    setSourcesContent() {
        <span class="hljs-keyword">let</span> already = {};
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root) {
            <span class="hljs-keyword">this</span>.root.walk(<span class="hljs-function">(<span class="hljs-params">node</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (node.source) {
                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span> = node.source.input.from;
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> &amp;&amp; !already[<span class="hljs-keyword">from</span>]) {
                        already[<span class="hljs-keyword">from</span>] = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">let</span> fromUrl = <span class="hljs-keyword">this</span>.usesFileUrls ? <span class="hljs-keyword">this</span>.toFileUrl(<span class="hljs-keyword">from</span>) : <span class="hljs-keyword">this</span>.toUrl(<span class="hljs-keyword">this</span>.path(<span class="hljs-keyword">from</span>));
                        <span class="hljs-keyword">this</span>.map.setSourceContent(fromUrl, node.source.input.css);
                    }
                }
            });
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.css) {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span> = <span class="hljs-keyword">this</span>.opts.from ? <span class="hljs-keyword">this</span>.toUrl(<span class="hljs-keyword">this</span>.path(<span class="hljs-keyword">this</span>.opts.from)) : <span class="hljs-string">'&lt;no source&gt;'</span>;
            <span class="hljs-keyword">this</span>.map.setSourceContent(<span class="hljs-keyword">from</span>, <span class="hljs-keyword">this</span>.css);
        }
    }
    sourcePath(node) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mapOpts.from) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toUrl(<span class="hljs-keyword">this</span>.mapOpts.from);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.usesFileUrls) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toFileUrl(node.source.input.from);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toUrl(<span class="hljs-keyword">this</span>.path(node.source.input.from));
        }
    }
    toBase64(str) {
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time truthy"</span>, <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> Buffer.from(str).toString(<span class="hljs-string">'base64'</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-comment">//TURBOPACK unreachable</span>
        ;
    }
    toFileUrl(path) {
        <span class="hljs-keyword">let</span> cached = <span class="hljs-keyword">this</span>.memoizedFileURLs.get(path);
        <span class="hljs-keyword">if</span> (cached) <span class="hljs-keyword">return</span> cached;
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time truthy"</span>, <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">let</span> fileURL = pathToFileURL(path).toString();
            <span class="hljs-keyword">this</span>.memoizedFileURLs.set(path, fileURL);
            <span class="hljs-keyword">return</span> fileURL;
        } <span class="hljs-keyword">else</span> <span class="hljs-comment">//TURBOPACK unreachable</span>
        ;
    }
    toUrl(path) {
        <span class="hljs-keyword">let</span> cached = <span class="hljs-keyword">this</span>.memoizedURLs.get(path);
        <span class="hljs-keyword">if</span> (cached) <span class="hljs-keyword">return</span> cached;
        <span class="hljs-keyword">if</span> (sep === <span class="hljs-string">'\\'</span>) {
            path = path.replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>);
        }
        <span class="hljs-keyword">let</span> url = <span class="hljs-built_in">encodeURI</span>(path).replace(<span class="hljs-regexp">/[#?]/g</span>, <span class="hljs-built_in">encodeURIComponent</span>);
        <span class="hljs-keyword">this</span>.memoizedURLs.set(path, url);
        <span class="hljs-keyword">return</span> url;
    }
}
<span class="hljs-built_in">module</span>.exports = MapGenerator;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/comment.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Node = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/node.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>{
    <span class="hljs-keyword">constructor</span>(defaults){
        <span class="hljs-keyword">super</span>(defaults);
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'comment'</span>;
    }
}
<span class="hljs-built_in">module</span>.exports = Comment;
Comment.default = Comment;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> { isClean, my } = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Declaration = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Comment = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/comment.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Node = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/node.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> parse, Rule, AtRule, Root;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanSource</span>(<span class="hljs-params">nodes</span>) </span>{
    <span class="hljs-keyword">return</span> nodes.map(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
        <span class="hljs-keyword">if</span> (i.nodes) i.nodes = cleanSource(i.nodes);
        <span class="hljs-keyword">delete</span> i.source;
        <span class="hljs-keyword">return</span> i;
    });
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markDirtyUp</span>(<span class="hljs-params">node</span>) </span>{
    node[isClean] = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (node.proxyOf.nodes) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> node.proxyOf.nodes){
            markDirtyUp(i);
        }
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>{
    append(...children) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> child <span class="hljs-keyword">of</span> children){
            <span class="hljs-keyword">let</span> nodes = <span class="hljs-keyword">this</span>.normalize(child, <span class="hljs-keyword">this</span>.last);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> nodes)<span class="hljs-keyword">this</span>.proxyOf.nodes.push(node);
        }
        <span class="hljs-keyword">this</span>.markDirty();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    cleanRaws(keepBetween) {
        <span class="hljs-keyword">super</span>.cleanRaws(keepBetween);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodes) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.nodes)node.cleanRaws(keepBetween);
        }
    }
    each(callback) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.proxyOf.nodes) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">let</span> iterator = <span class="hljs-keyword">this</span>.getIterator();
        <span class="hljs-keyword">let</span> index, result;
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.indexes[iterator] &lt; <span class="hljs-keyword">this</span>.proxyOf.nodes.length){
            index = <span class="hljs-keyword">this</span>.indexes[iterator];
            result = callback(<span class="hljs-keyword">this</span>.proxyOf.nodes[index], index);
            <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">this</span>.indexes[iterator] += <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.indexes[iterator];
        <span class="hljs-keyword">return</span> result;
    }
    every(condition) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nodes.every(condition);
    }
    getIterator() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.lastEach) <span class="hljs-keyword">this</span>.lastEach = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.indexes) <span class="hljs-keyword">this</span>.indexes = {};
        <span class="hljs-keyword">this</span>.lastEach += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">let</span> iterator = <span class="hljs-keyword">this</span>.lastEach;
        <span class="hljs-keyword">this</span>.indexes[iterator] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> iterator;
    }
    getProxyProcessor() {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-keyword">get</span> (node, prop) {
                <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'proxyOf'</span>) {
                    <span class="hljs-keyword">return</span> node;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!node[prop]) {
                    <span class="hljs-keyword">return</span> node[prop];
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'each'</span> || <span class="hljs-keyword">typeof</span> prop === <span class="hljs-string">'string'</span> &amp;&amp; prop.startsWith(<span class="hljs-string">'walk'</span>)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>)=&gt;</span>{
                        <span class="hljs-keyword">return</span> node[prop](...args.map(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
                            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i === <span class="hljs-string">'function'</span>) {
                                <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">child, index</span>)=&gt;</span>i(child.toProxy(), index);
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">return</span> i;
                            }
                        }));
                    };
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'every'</span> || prop === <span class="hljs-string">'some'</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">cb</span>)=&gt;</span>{
                        <span class="hljs-keyword">return</span> node[prop](<span class="hljs-function">(<span class="hljs-params">child, ...other</span>)=&gt;</span>cb(child.toProxy(), ...other));
                    };
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'root'</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>node.root().toProxy();
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'nodes'</span>) {
                    <span class="hljs-keyword">return</span> node.nodes.map(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i.toProxy());
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'first'</span> || prop === <span class="hljs-string">'last'</span>) {
                    <span class="hljs-keyword">return</span> node[prop].toProxy();
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> node[prop];
                }
            },
            <span class="hljs-keyword">set</span> (node, prop, value) {
                <span class="hljs-keyword">if</span> (node[prop] === value) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                node[prop] = value;
                <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'name'</span> || prop === <span class="hljs-string">'params'</span> || prop === <span class="hljs-string">'selector'</span>) {
                    node.markDirty();
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        };
    }
    index(child) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child === <span class="hljs-string">'number'</span>) <span class="hljs-keyword">return</span> child;
        <span class="hljs-keyword">if</span> (child.proxyOf) child = child.proxyOf;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxyOf.nodes.indexOf(child);
    }
    insertAfter(exist, add) {
        <span class="hljs-keyword">let</span> existIndex = <span class="hljs-keyword">this</span>.index(exist);
        <span class="hljs-keyword">let</span> nodes = <span class="hljs-keyword">this</span>.normalize(add, <span class="hljs-keyword">this</span>.proxyOf.nodes[existIndex]).reverse();
        existIndex = <span class="hljs-keyword">this</span>.index(exist);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> nodes)<span class="hljs-keyword">this</span>.proxyOf.nodes.splice(existIndex + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, node);
        <span class="hljs-keyword">let</span> index;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.indexes){
            index = <span class="hljs-keyword">this</span>.indexes[id];
            <span class="hljs-keyword">if</span> (existIndex &lt; index) {
                <span class="hljs-keyword">this</span>.indexes[id] = index + nodes.length;
            }
        }
        <span class="hljs-keyword">this</span>.markDirty();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    insertBefore(exist, add) {
        <span class="hljs-keyword">let</span> existIndex = <span class="hljs-keyword">this</span>.index(exist);
        <span class="hljs-keyword">let</span> type = existIndex === <span class="hljs-number">0</span> ? <span class="hljs-string">'prepend'</span> : <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> nodes = <span class="hljs-keyword">this</span>.normalize(add, <span class="hljs-keyword">this</span>.proxyOf.nodes[existIndex], type).reverse();
        existIndex = <span class="hljs-keyword">this</span>.index(exist);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> nodes)<span class="hljs-keyword">this</span>.proxyOf.nodes.splice(existIndex, <span class="hljs-number">0</span>, node);
        <span class="hljs-keyword">let</span> index;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.indexes){
            index = <span class="hljs-keyword">this</span>.indexes[id];
            <span class="hljs-keyword">if</span> (existIndex &lt;= index) {
                <span class="hljs-keyword">this</span>.indexes[id] = index + nodes.length;
            }
        }
        <span class="hljs-keyword">this</span>.markDirty();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    normalize(nodes, sample) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nodes === <span class="hljs-string">'string'</span>) {
            nodes = cleanSource(parse(nodes).nodes);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(nodes)) {
            nodes = nodes.slice(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> nodes){
                <span class="hljs-keyword">if</span> (i.parent) i.parent.removeChild(i, <span class="hljs-string">'ignore'</span>);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.type === <span class="hljs-string">'root'</span> &amp;&amp; <span class="hljs-keyword">this</span>.type !== <span class="hljs-string">'document'</span>) {
            nodes = nodes.nodes.slice(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> nodes){
                <span class="hljs-keyword">if</span> (i.parent) i.parent.removeChild(i, <span class="hljs-string">'ignore'</span>);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.type) {
            nodes = [
                nodes
            ];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.prop) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nodes.value === <span class="hljs-string">'undefined'</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Value field is missed in node creation'</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nodes.value !== <span class="hljs-string">'string'</span>) {
                nodes.value = <span class="hljs-built_in">String</span>(nodes.value);
            }
            nodes = [
                <span class="hljs-keyword">new</span> Declaration(nodes)
            ];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.selector) {
            nodes = [
                <span class="hljs-keyword">new</span> Rule(nodes)
            ];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.name) {
            nodes = [
                <span class="hljs-keyword">new</span> AtRule(nodes)
            ];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.text) {
            nodes = [
                <span class="hljs-keyword">new</span> Comment(nodes)
            ];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unknown node type in node creation'</span>);
        }
        <span class="hljs-keyword">let</span> processed = nodes.map(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>{
            <span class="hljs-comment">/* c8 ignore next */</span> <span class="hljs-keyword">if</span> (!i[my]) Container.rebuild(i);
            i = i.proxyOf;
            <span class="hljs-keyword">if</span> (i.parent) i.parent.removeChild(i);
            <span class="hljs-keyword">if</span> (i[isClean]) markDirtyUp(i);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i.raws.before === <span class="hljs-string">'undefined'</span>) {
                <span class="hljs-keyword">if</span> (sample &amp;&amp; <span class="hljs-keyword">typeof</span> sample.raws.before !== <span class="hljs-string">'undefined'</span>) {
                    i.raws.before = sample.raws.before.replace(<span class="hljs-regexp">/\S/g</span>, <span class="hljs-string">''</span>);
                }
            }
            i.parent = <span class="hljs-keyword">this</span>.proxyOf;
            <span class="hljs-keyword">return</span> i;
        });
        <span class="hljs-keyword">return</span> processed;
    }
    prepend(...children) {
        children = children.reverse();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> child <span class="hljs-keyword">of</span> children){
            <span class="hljs-keyword">let</span> nodes = <span class="hljs-keyword">this</span>.normalize(child, <span class="hljs-keyword">this</span>.first, <span class="hljs-string">'prepend'</span>).reverse();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> nodes)<span class="hljs-keyword">this</span>.proxyOf.nodes.unshift(node);
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.indexes){
                <span class="hljs-keyword">this</span>.indexes[id] = <span class="hljs-keyword">this</span>.indexes[id] + nodes.length;
            }
        }
        <span class="hljs-keyword">this</span>.markDirty();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    push(child) {
        child.parent = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">this</span>.proxyOf.nodes.push(child);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    removeAll() {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.proxyOf.nodes)node.parent = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>.proxyOf.nodes = [];
        <span class="hljs-keyword">this</span>.markDirty();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    removeChild(child) {
        child = <span class="hljs-keyword">this</span>.index(child);
        <span class="hljs-keyword">this</span>.proxyOf.nodes[child].parent = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>.proxyOf.nodes.splice(child, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">let</span> index;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.indexes){
            index = <span class="hljs-keyword">this</span>.indexes[id];
            <span class="hljs-keyword">if</span> (index &gt;= child) {
                <span class="hljs-keyword">this</span>.indexes[id] = index - <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">this</span>.markDirty();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    replaceValues(pattern, opts, callback) {
        <span class="hljs-keyword">if</span> (!callback) {
            callback = opts;
            opts = {};
        }
        <span class="hljs-keyword">this</span>.walkDecls(<span class="hljs-function">(<span class="hljs-params">decl</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (opts.props &amp;&amp; !opts.props.includes(decl.prop)) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">if</span> (opts.fast &amp;&amp; !decl.value.includes(opts.fast)) <span class="hljs-keyword">return</span>;
            decl.value = decl.value.replace(pattern, callback);
        });
        <span class="hljs-keyword">this</span>.markDirty();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    some(condition) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nodes.some(condition);
    }
    walk(callback) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.each(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
            <span class="hljs-keyword">let</span> result;
            <span class="hljs-keyword">try</span> {
                result = callback(child, i);
            } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-keyword">throw</span> child.addToError(e);
            }
            <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">false</span> &amp;&amp; child.walk) {
                result = child.walk(callback);
            }
            <span class="hljs-keyword">return</span> result;
        });
    }
    walkAtRules(name, callback) {
        <span class="hljs-keyword">if</span> (!callback) {
            callback = name;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'atrule'</span>) {
                    <span class="hljs-keyword">return</span> callback(child, i);
                }
            });
        }
        <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'atrule'</span> &amp;&amp; name.test(child.name)) {
                    <span class="hljs-keyword">return</span> callback(child, i);
                }
            });
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'atrule'</span> &amp;&amp; child.name === name) {
                <span class="hljs-keyword">return</span> callback(child, i);
            }
        });
    }
    walkComments(callback) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'comment'</span>) {
                <span class="hljs-keyword">return</span> callback(child, i);
            }
        });
    }
    walkDecls(prop, callback) {
        <span class="hljs-keyword">if</span> (!callback) {
            callback = prop;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'decl'</span>) {
                    <span class="hljs-keyword">return</span> callback(child, i);
                }
            });
        }
        <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'decl'</span> &amp;&amp; prop.test(child.prop)) {
                    <span class="hljs-keyword">return</span> callback(child, i);
                }
            });
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'decl'</span> &amp;&amp; child.prop === prop) {
                <span class="hljs-keyword">return</span> callback(child, i);
            }
        });
    }
    walkRules(selector, callback) {
        <span class="hljs-keyword">if</span> (!callback) {
            callback = selector;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'rule'</span>) {
                    <span class="hljs-keyword">return</span> callback(child, i);
                }
            });
        }
        <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
                <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'rule'</span> &amp;&amp; selector.test(child.selector)) {
                    <span class="hljs-keyword">return</span> callback(child, i);
                }
            });
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.walk(<span class="hljs-function">(<span class="hljs-params">child, i</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (child.type === <span class="hljs-string">'rule'</span> &amp;&amp; child.selector === selector) {
                <span class="hljs-keyword">return</span> callback(child, i);
            }
        });
    }
    <span class="hljs-keyword">get</span> first() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.proxyOf.nodes) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxyOf.nodes[<span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">get</span> last() {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.proxyOf.nodes) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxyOf.nodes[<span class="hljs-keyword">this</span>.proxyOf.nodes.length - <span class="hljs-number">1</span>];
    }
}
Container.registerParse = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    parse = dependant;
};
Container.registerRule = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    Rule = dependant;
};
Container.registerAtRule = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    AtRule = dependant;
};
Container.registerRoot = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    Root = dependant;
};
<span class="hljs-built_in">module</span>.exports = Container;
Container.default = Container;
<span class="hljs-comment">/* c8 ignore start */</span> Container.rebuild = <span class="hljs-function">(<span class="hljs-params">node</span>)=&gt;</span>{
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'atrule'</span>) {
        <span class="hljs-built_in">Object</span>.setPrototypeOf(node, AtRule.prototype);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'rule'</span>) {
        <span class="hljs-built_in">Object</span>.setPrototypeOf(node, Rule.prototype);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'decl'</span>) {
        <span class="hljs-built_in">Object</span>.setPrototypeOf(node, Declaration.prototype);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'comment'</span>) {
        <span class="hljs-built_in">Object</span>.setPrototypeOf(node, Comment.prototype);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'root'</span>) {
        <span class="hljs-built_in">Object</span>.setPrototypeOf(node, Root.prototype);
    }
    node[my] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (node.nodes) {
        node.nodes.forEach(<span class="hljs-function">(<span class="hljs-params">child</span>)=&gt;</span>{
            Container.rebuild(child);
        });
    }
}; <span class="hljs-comment">/* c8 ignore stop */</span> 
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/document.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Container = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> LazyResult, Processor;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Document</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Container</span> </span>{
    <span class="hljs-keyword">constructor</span>(defaults){
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-185" id="section-185"></a>
</div>
<p>type needs to be passed to super, otherwise child roots won't be normalized correctly</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">super</span>({
            <span class="hljs-attr">type</span>: <span class="hljs-string">'document'</span>,
            ...defaults
        });
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.nodes) {
            <span class="hljs-keyword">this</span>.nodes = [];
        }
    }
    toResult(opts = {}) {
        <span class="hljs-keyword">let</span> lazy = <span class="hljs-keyword">new</span> LazyResult(<span class="hljs-keyword">new</span> Processor(), <span class="hljs-keyword">this</span>, opts);
        <span class="hljs-keyword">return</span> lazy.stringify();
    }
}
Document.registerLazyResult = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    LazyResult = dependant;
};
Document.registerProcessor = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    Processor = dependant;
};
<span class="hljs-built_in">module</span>.exports = Document;
Document.default = Document;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-comment">/* eslint-disable no-console */</span> <span class="hljs-keyword">let</span> printed = {};
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnOnce</span>(<span class="hljs-params">message</span>) </span>{
    <span class="hljs-keyword">if</span> (printed[message]) <span class="hljs-keyword">return</span>;
    printed[message] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">console</span>.warn) {
        <span class="hljs-built_in">console</span>.warn(message);
    }
};
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/warning.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Warning</span> </span>{
    <span class="hljs-keyword">constructor</span>(text, opts = {}){
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'warning'</span>;
        <span class="hljs-keyword">this</span>.text = text;
        <span class="hljs-keyword">if</span> (opts.node &amp;&amp; opts.node.source) {
            <span class="hljs-keyword">let</span> range = opts.node.rangeBy(opts);
            <span class="hljs-keyword">this</span>.line = range.start.line;
            <span class="hljs-keyword">this</span>.column = range.start.column;
            <span class="hljs-keyword">this</span>.endLine = range.end.line;
            <span class="hljs-keyword">this</span>.endColumn = range.end.column;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> opt <span class="hljs-keyword">in</span> opts)<span class="hljs-keyword">this</span>[opt] = opts[opt];
    }
    toString() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.node) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.node.error(<span class="hljs-keyword">this</span>.text, {
                <span class="hljs-attr">index</span>: <span class="hljs-keyword">this</span>.index,
                <span class="hljs-attr">plugin</span>: <span class="hljs-keyword">this</span>.plugin,
                <span class="hljs-attr">word</span>: <span class="hljs-keyword">this</span>.word
            }).message;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.plugin) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.plugin + <span class="hljs-string">': '</span> + <span class="hljs-keyword">this</span>.text;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.text;
    }
}
<span class="hljs-built_in">module</span>.exports = Warning;
Warning.default = Warning;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/result.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Warning = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/warning.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Result</span> </span>{
    <span class="hljs-keyword">constructor</span>(processor, root, opts){
        <span class="hljs-keyword">this</span>.processor = processor;
        <span class="hljs-keyword">this</span>.messages = [];
        <span class="hljs-keyword">this</span>.root = root;
        <span class="hljs-keyword">this</span>.opts = opts;
        <span class="hljs-keyword">this</span>.css = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>.map = <span class="hljs-literal">undefined</span>;
    }
    toString() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.css;
    }
    warn(text, opts = {}) {
        <span class="hljs-keyword">if</span> (!opts.plugin) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lastPlugin &amp;&amp; <span class="hljs-keyword">this</span>.lastPlugin.postcssPlugin) {
                opts.plugin = <span class="hljs-keyword">this</span>.lastPlugin.postcssPlugin;
            }
        }
        <span class="hljs-keyword">let</span> warning = <span class="hljs-keyword">new</span> Warning(text, opts);
        <span class="hljs-keyword">this</span>.messages.push(warning);
        <span class="hljs-keyword">return</span> warning;
    }
    warnings() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.messages.filter(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i.type === <span class="hljs-string">'warning'</span>);
    }
    <span class="hljs-keyword">get</span> content() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.css;
    }
}
<span class="hljs-built_in">module</span>.exports = Result;
Result.default = Result;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Container = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtRule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Container</span> </span>{
    <span class="hljs-keyword">constructor</span>(defaults){
        <span class="hljs-keyword">super</span>(defaults);
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'atrule'</span>;
    }
    append(...children) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.proxyOf.nodes) <span class="hljs-keyword">this</span>.nodes = [];
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.append(...children);
    }
    prepend(...children) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.proxyOf.nodes) <span class="hljs-keyword">this</span>.nodes = [];
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.prepend(...children);
    }
}
<span class="hljs-built_in">module</span>.exports = AtRule;
AtRule.default = AtRule;
Container.registerAtRule(AtRule);
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/root.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Container = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> LazyResult, Processor;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Container</span> </span>{
    <span class="hljs-keyword">constructor</span>(defaults){
        <span class="hljs-keyword">super</span>(defaults);
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'root'</span>;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.nodes) <span class="hljs-keyword">this</span>.nodes = [];
    }
    normalize(child, sample, type) {
        <span class="hljs-keyword">let</span> nodes = <span class="hljs-keyword">super</span>.normalize(child);
        <span class="hljs-keyword">if</span> (sample) {
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'prepend'</span>) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nodes.length &gt; <span class="hljs-number">1</span>) {
                    sample.raws.before = <span class="hljs-keyword">this</span>.nodes[<span class="hljs-number">1</span>].raws.before;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">delete</span> sample.raws.before;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.first !== sample) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> nodes){
                    node.raws.before = sample.raws.before;
                }
            }
        }
        <span class="hljs-keyword">return</span> nodes;
    }
    removeChild(child, ignore) {
        <span class="hljs-keyword">let</span> index = <span class="hljs-keyword">this</span>.index(child);
        <span class="hljs-keyword">if</span> (!ignore &amp;&amp; index === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.nodes.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">this</span>.nodes[<span class="hljs-number">1</span>].raws.before = <span class="hljs-keyword">this</span>.nodes[index].raws.before;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.removeChild(child);
    }
    toResult(opts = {}) {
        <span class="hljs-keyword">let</span> lazy = <span class="hljs-keyword">new</span> LazyResult(<span class="hljs-keyword">new</span> Processor(), <span class="hljs-keyword">this</span>, opts);
        <span class="hljs-keyword">return</span> lazy.stringify();
    }
}
Root.registerLazyResult = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    LazyResult = dependant;
};
Root.registerProcessor = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    Processor = dependant;
};
<span class="hljs-built_in">module</span>.exports = Root;
Root.default = Root;
Container.registerRoot(Root);
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/list.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> list = {
    comma (string) {
        <span class="hljs-keyword">return</span> list.split(string, [
            <span class="hljs-string">','</span>
        ], <span class="hljs-literal">true</span>);
    },
    space (string) {
        <span class="hljs-keyword">let</span> spaces = [
            <span class="hljs-string">' '</span>,
            <span class="hljs-string">'\n'</span>,
            <span class="hljs-string">'\t'</span>
        ];
        <span class="hljs-keyword">return</span> list.split(string, spaces);
    },
    split (string, separators, last) {
        <span class="hljs-keyword">let</span> array = [];
        <span class="hljs-keyword">let</span> current = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">let</span> split = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> func = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">let</span> inQuote = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> prevQuote = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">let</span> <span class="hljs-built_in">escape</span> = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> letter <span class="hljs-keyword">of</span> string){
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">escape</span>) {
                <span class="hljs-built_in">escape</span> = <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (letter === <span class="hljs-string">'\\'</span>) {
                <span class="hljs-built_in">escape</span> = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inQuote) {
                <span class="hljs-keyword">if</span> (letter === prevQuote) {
                    inQuote = <span class="hljs-literal">false</span>;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (letter === <span class="hljs-string">'"'</span> || letter === <span class="hljs-string">"'"</span>) {
                inQuote = <span class="hljs-literal">true</span>;
                prevQuote = letter;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (letter === <span class="hljs-string">'('</span>) {
                func += <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (letter === <span class="hljs-string">')'</span>) {
                <span class="hljs-keyword">if</span> (func &gt; <span class="hljs-number">0</span>) func -= <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (func === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (separators.includes(letter)) split = <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">if</span> (split) {
                <span class="hljs-keyword">if</span> (current !== <span class="hljs-string">''</span>) array.push(current.trim());
                current = <span class="hljs-string">''</span>;
                split = <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> {
                current += letter;
            }
        }
        <span class="hljs-keyword">if</span> (last || current !== <span class="hljs-string">''</span>) array.push(current.trim());
        <span class="hljs-keyword">return</span> array;
    }
};
<span class="hljs-built_in">module</span>.exports = list;
list.default = list;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/rule.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Container = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> list = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/list.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Container</span> </span>{
    <span class="hljs-keyword">constructor</span>(defaults){
        <span class="hljs-keyword">super</span>(defaults);
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'rule'</span>;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.nodes) <span class="hljs-keyword">this</span>.nodes = [];
    }
    <span class="hljs-keyword">get</span> selectors() {
        <span class="hljs-keyword">return</span> list.comma(<span class="hljs-keyword">this</span>.selector);
    }
    <span class="hljs-keyword">set</span> selectors(values) {
        <span class="hljs-keyword">let</span> match = <span class="hljs-keyword">this</span>.selector ? <span class="hljs-keyword">this</span>.selector.match(<span class="hljs-regexp">/,\s*/</span>) : <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">let</span> sep = match ? match[<span class="hljs-number">0</span>] : <span class="hljs-string">','</span> + <span class="hljs-keyword">this</span>.raw(<span class="hljs-string">'between'</span>, <span class="hljs-string">'beforeOpen'</span>);
        <span class="hljs-keyword">this</span>.selector = values.join(sep);
    }
}
<span class="hljs-built_in">module</span>.exports = Rule;
Rule.default = Rule;
Container.registerRule(Rule);
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/parser.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Declaration = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> tokenizer = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Comment = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/comment.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> AtRule = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Root = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/root.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Rule = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/rule.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">const</span> SAFE_COMMENT_NEIGHBOR = {
    <span class="hljs-attr">empty</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">space</span>: <span class="hljs-literal">true</span>
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLastWithPosition</span>(<span class="hljs-params">tokens</span>) </span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = tokens.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
        <span class="hljs-keyword">let</span> token = tokens[i];
        <span class="hljs-keyword">let</span> pos = token[<span class="hljs-number">3</span>] || token[<span class="hljs-number">2</span>];
        <span class="hljs-keyword">if</span> (pos) <span class="hljs-keyword">return</span> pos;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parser</span> </span>{
    <span class="hljs-keyword">constructor</span>(input){
        <span class="hljs-keyword">this</span>.input = input;
        <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> Root();
        <span class="hljs-keyword">this</span>.current = <span class="hljs-keyword">this</span>.root;
        <span class="hljs-keyword">this</span>.spaces = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">this</span>.semicolon = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.customProperty = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.createTokenizer();
        <span class="hljs-keyword">this</span>.root.source = {
            input,
            <span class="hljs-attr">start</span>: {
                <span class="hljs-attr">column</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">offset</span>: <span class="hljs-number">0</span>
            }
        };
    }
    atrule(token) {
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> AtRule();
        node.name = token[<span class="hljs-number">1</span>].slice(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (node.name === <span class="hljs-string">''</span>) {
            <span class="hljs-keyword">this</span>.unnamedAtrule(node, token);
        }
        <span class="hljs-keyword">this</span>.init(node, token[<span class="hljs-number">2</span>]);
        <span class="hljs-keyword">let</span> type;
        <span class="hljs-keyword">let</span> prev;
        <span class="hljs-keyword">let</span> shift;
        <span class="hljs-keyword">let</span> last = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> open = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> params = [];
        <span class="hljs-keyword">let</span> brackets = [];
        <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.tokenizer.endOfFile()){
            token = <span class="hljs-keyword">this</span>.tokenizer.nextToken();
            type = token[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'('</span> || type === <span class="hljs-string">'['</span>) {
                brackets.push(type === <span class="hljs-string">'('</span> ? <span class="hljs-string">')'</span> : <span class="hljs-string">']'</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'{'</span> &amp;&amp; brackets.length &gt; <span class="hljs-number">0</span>) {
                brackets.push(<span class="hljs-string">'}'</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === brackets[brackets.length - <span class="hljs-number">1</span>]) {
                brackets.pop();
            }
            <span class="hljs-keyword">if</span> (brackets.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (type === <span class="hljs-string">';'</span>) {
                    node.source.end = <span class="hljs-keyword">this</span>.getPosition(token[<span class="hljs-number">2</span>]);
                    node.source.end.offset++;
                    <span class="hljs-keyword">this</span>.semicolon = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'{'</span>) {
                    open = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'}'</span>) {
                    <span class="hljs-keyword">if</span> (params.length &gt; <span class="hljs-number">0</span>) {
                        shift = params.length - <span class="hljs-number">1</span>;
                        prev = params[shift];
                        <span class="hljs-keyword">while</span>(prev &amp;&amp; prev[<span class="hljs-number">0</span>] === <span class="hljs-string">'space'</span>){
                            prev = params[--shift];
                        }
                        <span class="hljs-keyword">if</span> (prev) {
                            node.source.end = <span class="hljs-keyword">this</span>.getPosition(prev[<span class="hljs-number">3</span>] || prev[<span class="hljs-number">2</span>]);
                            node.source.end.offset++;
                        }
                    }
                    <span class="hljs-keyword">this</span>.end(token);
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> {
                    params.push(token);
                }
            } <span class="hljs-keyword">else</span> {
                params.push(token);
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tokenizer.endOfFile()) {
                last = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        node.raws.between = <span class="hljs-keyword">this</span>.spacesAndCommentsFromEnd(params);
        <span class="hljs-keyword">if</span> (params.length) {
            node.raws.afterName = <span class="hljs-keyword">this</span>.spacesAndCommentsFromStart(params);
            <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'params'</span>, params);
            <span class="hljs-keyword">if</span> (last) {
                token = params[params.length - <span class="hljs-number">1</span>];
                node.source.end = <span class="hljs-keyword">this</span>.getPosition(token[<span class="hljs-number">3</span>] || token[<span class="hljs-number">2</span>]);
                node.source.end.offset++;
                <span class="hljs-keyword">this</span>.spaces = node.raws.between;
                node.raws.between = <span class="hljs-string">''</span>;
            }
        } <span class="hljs-keyword">else</span> {
            node.raws.afterName = <span class="hljs-string">''</span>;
            node.params = <span class="hljs-string">''</span>;
        }
        <span class="hljs-keyword">if</span> (open) {
            node.nodes = [];
            <span class="hljs-keyword">this</span>.current = node;
        }
    }
    checkMissedSemicolon(tokens) {
        <span class="hljs-keyword">let</span> colon = <span class="hljs-keyword">this</span>.colon(tokens);
        <span class="hljs-keyword">if</span> (colon === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">let</span> founded = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">let</span> token;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = colon - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--){
            token = tokens[j];
            <span class="hljs-keyword">if</span> (token[<span class="hljs-number">0</span>] !== <span class="hljs-string">'space'</span>) {
                founded += <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (founded === <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;
            }
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-186" id="section-186"></a>
</div>
<p>If the token is a word, e.g. <code>!important</code>, <code>red</code> or any other valid property's value.
Then we need to return the colon after that word token. [3] is the &quot;end&quot; colon of that word.
And because we need it after that one we do +1 to get the next one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.input.error(<span class="hljs-string">'Missed semicolon'</span>, token[<span class="hljs-number">0</span>] === <span class="hljs-string">'word'</span> ? token[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span> : token[<span class="hljs-number">2</span>]);
    }
    colon(tokens) {
        <span class="hljs-keyword">let</span> brackets = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">let</span> token, type, prev;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [i, element] <span class="hljs-keyword">of</span> tokens.entries()){
            token = element;
            type = token[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'('</span>) {
                brackets += <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">')'</span>) {
                brackets -= <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">if</span> (brackets === <span class="hljs-number">0</span> &amp;&amp; type === <span class="hljs-string">':'</span>) {
                <span class="hljs-keyword">if</span> (!prev) {
                    <span class="hljs-keyword">this</span>.doubleColon(token);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prev[<span class="hljs-number">0</span>] === <span class="hljs-string">'word'</span> &amp;&amp; prev[<span class="hljs-number">1</span>] === <span class="hljs-string">'progid'</span>) {
                    <span class="hljs-keyword">continue</span>;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> i;
                }
            }
            prev = token;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    comment(token) {
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> Comment();
        <span class="hljs-keyword">this</span>.init(node, token[<span class="hljs-number">2</span>]);
        node.source.end = <span class="hljs-keyword">this</span>.getPosition(token[<span class="hljs-number">3</span>] || token[<span class="hljs-number">2</span>]);
        node.source.end.offset++;
        <span class="hljs-keyword">let</span> text = token[<span class="hljs-number">1</span>].slice(<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\s*$/</span>.test(text)) {
            node.text = <span class="hljs-string">''</span>;
            node.raws.left = text;
            node.raws.right = <span class="hljs-string">''</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> match = text.match(<span class="hljs-regexp">/^(\s*)([^]*\S)(\s*)$/</span>);
            node.text = match[<span class="hljs-number">2</span>];
            node.raws.left = match[<span class="hljs-number">1</span>];
            node.raws.right = match[<span class="hljs-number">3</span>];
        }
    }
    createTokenizer() {
        <span class="hljs-keyword">this</span>.tokenizer = tokenizer(<span class="hljs-keyword">this</span>.input);
    }
    decl(tokens, customProperty) {
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> Declaration();
        <span class="hljs-keyword">this</span>.init(node, tokens[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);
        <span class="hljs-keyword">let</span> last = tokens[tokens.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span> (last[<span class="hljs-number">0</span>] === <span class="hljs-string">';'</span>) {
            <span class="hljs-keyword">this</span>.semicolon = <span class="hljs-literal">true</span>;
            tokens.pop();
        }
        node.source.end = <span class="hljs-keyword">this</span>.getPosition(last[<span class="hljs-number">3</span>] || last[<span class="hljs-number">2</span>] || findLastWithPosition(tokens));
        node.source.end.offset++;
        <span class="hljs-keyword">while</span>(tokens[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] !== <span class="hljs-string">'word'</span>){
            <span class="hljs-keyword">if</span> (tokens.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">this</span>.unknownWord(tokens);
            node.raws.before += tokens.shift()[<span class="hljs-number">1</span>];
        }
        node.source.start = <span class="hljs-keyword">this</span>.getPosition(tokens[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);
        node.prop = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">while</span>(tokens.length){
            <span class="hljs-keyword">let</span> type = tokens[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">':'</span> || type === <span class="hljs-string">'space'</span> || type === <span class="hljs-string">'comment'</span>) {
                <span class="hljs-keyword">break</span>;
            }
            node.prop += tokens.shift()[<span class="hljs-number">1</span>];
        }
        node.raws.between = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">let</span> token;
        <span class="hljs-keyword">while</span>(tokens.length){
            token = tokens.shift();
            <span class="hljs-keyword">if</span> (token[<span class="hljs-number">0</span>] === <span class="hljs-string">':'</span>) {
                node.raws.between += token[<span class="hljs-number">1</span>];
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (token[<span class="hljs-number">0</span>] === <span class="hljs-string">'word'</span> &amp;&amp; <span class="hljs-regexp">/\w/</span>.test(token[<span class="hljs-number">1</span>])) {
                    <span class="hljs-keyword">this</span>.unknownWord([
                        token
                    ]);
                }
                node.raws.between += token[<span class="hljs-number">1</span>];
            }
        }
        <span class="hljs-keyword">if</span> (node.prop[<span class="hljs-number">0</span>] === <span class="hljs-string">'_'</span> || node.prop[<span class="hljs-number">0</span>] === <span class="hljs-string">'*'</span>) {
            node.raws.before += node.prop[<span class="hljs-number">0</span>];
            node.prop = node.prop.slice(<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">let</span> firstSpaces = [];
        <span class="hljs-keyword">let</span> next;
        <span class="hljs-keyword">while</span>(tokens.length){
            next = tokens[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (next !== <span class="hljs-string">'space'</span> &amp;&amp; next !== <span class="hljs-string">'comment'</span>) <span class="hljs-keyword">break</span>;
            firstSpaces.push(tokens.shift());
        }
        <span class="hljs-keyword">this</span>.precheckMissedSemicolon(tokens);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = tokens.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
            token = tokens[i];
            <span class="hljs-keyword">if</span> (token[<span class="hljs-number">1</span>].toLowerCase() === <span class="hljs-string">'!important'</span>) {
                node.important = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">let</span> string = <span class="hljs-keyword">this</span>.stringFrom(tokens, i);
                string = <span class="hljs-keyword">this</span>.spacesFromEnd(tokens) + string;
                <span class="hljs-keyword">if</span> (string !== <span class="hljs-string">' !important'</span>) node.raws.important = string;
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token[<span class="hljs-number">1</span>].toLowerCase() === <span class="hljs-string">'important'</span>) {
                <span class="hljs-keyword">let</span> cache = tokens.slice(<span class="hljs-number">0</span>);
                <span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &gt; <span class="hljs-number">0</span>; j--){
                    <span class="hljs-keyword">let</span> type = cache[j][<span class="hljs-number">0</span>];
                    <span class="hljs-keyword">if</span> (str.trim().indexOf(<span class="hljs-string">'!'</span>) === <span class="hljs-number">0</span> &amp;&amp; type !== <span class="hljs-string">'space'</span>) {
                        <span class="hljs-keyword">break</span>;
                    }
                    str = cache.pop()[<span class="hljs-number">1</span>] + str;
                }
                <span class="hljs-keyword">if</span> (str.trim().indexOf(<span class="hljs-string">'!'</span>) === <span class="hljs-number">0</span>) {
                    node.important = <span class="hljs-literal">true</span>;
                    node.raws.important = str;
                    tokens = cache;
                }
            }
            <span class="hljs-keyword">if</span> (token[<span class="hljs-number">0</span>] !== <span class="hljs-string">'space'</span> &amp;&amp; token[<span class="hljs-number">0</span>] !== <span class="hljs-string">'comment'</span>) {
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">let</span> hasWord = tokens.some(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i[<span class="hljs-number">0</span>] !== <span class="hljs-string">'space'</span> &amp;&amp; i[<span class="hljs-number">0</span>] !== <span class="hljs-string">'comment'</span>);
        <span class="hljs-keyword">if</span> (hasWord) {
            node.raws.between += firstSpaces.map(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i[<span class="hljs-number">1</span>]).join(<span class="hljs-string">''</span>);
            firstSpaces = [];
        }
        <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'value'</span>, firstSpaces.concat(tokens), customProperty);
        <span class="hljs-keyword">if</span> (node.value.includes(<span class="hljs-string">':'</span>) &amp;&amp; !customProperty) {
            <span class="hljs-keyword">this</span>.checkMissedSemicolon(tokens);
        }
    }
    doubleColon(token) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.input.error(<span class="hljs-string">'Double colon'</span>, {
            <span class="hljs-attr">offset</span>: token[<span class="hljs-number">2</span>]
        }, {
            <span class="hljs-attr">offset</span>: token[<span class="hljs-number">2</span>] + token[<span class="hljs-number">1</span>].length
        });
    }
    emptyRule(token) {
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> Rule();
        <span class="hljs-keyword">this</span>.init(node, token[<span class="hljs-number">2</span>]);
        node.selector = <span class="hljs-string">''</span>;
        node.raws.between = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">this</span>.current = node;
    }
    end(token) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.current.nodes &amp;&amp; <span class="hljs-keyword">this</span>.current.nodes.length) {
            <span class="hljs-keyword">this</span>.current.raws.semicolon = <span class="hljs-keyword">this</span>.semicolon;
        }
        <span class="hljs-keyword">this</span>.semicolon = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.current.raws.after = (<span class="hljs-keyword">this</span>.current.raws.after || <span class="hljs-string">''</span>) + <span class="hljs-keyword">this</span>.spaces;
        <span class="hljs-keyword">this</span>.spaces = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.current.parent) {
            <span class="hljs-keyword">this</span>.current.source.end = <span class="hljs-keyword">this</span>.getPosition(token[<span class="hljs-number">2</span>]);
            <span class="hljs-keyword">this</span>.current.source.end.offset++;
            <span class="hljs-keyword">this</span>.current = <span class="hljs-keyword">this</span>.current.parent;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.unexpectedClose(token);
        }
    }
    endFile() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.current.parent) <span class="hljs-keyword">this</span>.unclosedBlock();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.current.nodes &amp;&amp; <span class="hljs-keyword">this</span>.current.nodes.length) {
            <span class="hljs-keyword">this</span>.current.raws.semicolon = <span class="hljs-keyword">this</span>.semicolon;
        }
        <span class="hljs-keyword">this</span>.current.raws.after = (<span class="hljs-keyword">this</span>.current.raws.after || <span class="hljs-string">''</span>) + <span class="hljs-keyword">this</span>.spaces;
        <span class="hljs-keyword">this</span>.root.source.end = <span class="hljs-keyword">this</span>.getPosition(<span class="hljs-keyword">this</span>.tokenizer.position());
    }
    freeSemicolon(token) {
        <span class="hljs-keyword">this</span>.spaces += token[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.current.nodes) {
            <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">this</span>.current.nodes[<span class="hljs-keyword">this</span>.current.nodes.length - <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (prev &amp;&amp; prev.type === <span class="hljs-string">'rule'</span> &amp;&amp; !prev.raws.ownSemicolon) {
                prev.raws.ownSemicolon = <span class="hljs-keyword">this</span>.spaces;
                <span class="hljs-keyword">this</span>.spaces = <span class="hljs-string">''</span>;
            }
        }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-187" id="section-187"></a>
</div>
<p>Helpers</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    getPosition(offset) {
        <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.input.fromOffset(offset);
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">column</span>: pos.col,
            <span class="hljs-attr">line</span>: pos.line,
            offset
        };
    }
    init(node, offset) {
        <span class="hljs-keyword">this</span>.current.push(node);
        node.source = {
            <span class="hljs-attr">input</span>: <span class="hljs-keyword">this</span>.input,
            <span class="hljs-attr">start</span>: <span class="hljs-keyword">this</span>.getPosition(offset)
        };
        node.raws.before = <span class="hljs-keyword">this</span>.spaces;
        <span class="hljs-keyword">this</span>.spaces = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'comment'</span>) <span class="hljs-keyword">this</span>.semicolon = <span class="hljs-literal">false</span>;
    }
    other(start) {
        <span class="hljs-keyword">let</span> end = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> type = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">let</span> colon = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> bracket = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">let</span> brackets = [];
        <span class="hljs-keyword">let</span> customProperty = start[<span class="hljs-number">1</span>].startsWith(<span class="hljs-string">'--'</span>);
        <span class="hljs-keyword">let</span> tokens = [];
        <span class="hljs-keyword">let</span> token = start;
        <span class="hljs-keyword">while</span>(token){
            type = token[<span class="hljs-number">0</span>];
            tokens.push(token);
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'('</span> || type === <span class="hljs-string">'['</span>) {
                <span class="hljs-keyword">if</span> (!bracket) bracket = token;
                brackets.push(type === <span class="hljs-string">'('</span> ? <span class="hljs-string">')'</span> : <span class="hljs-string">']'</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (customProperty &amp;&amp; colon &amp;&amp; type === <span class="hljs-string">'{'</span>) {
                <span class="hljs-keyword">if</span> (!bracket) bracket = token;
                brackets.push(<span class="hljs-string">'}'</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (brackets.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (type === <span class="hljs-string">';'</span>) {
                    <span class="hljs-keyword">if</span> (colon) {
                        <span class="hljs-keyword">this</span>.decl(tokens, customProperty);
                        <span class="hljs-keyword">return</span>;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">break</span>;
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'{'</span>) {
                    <span class="hljs-keyword">this</span>.rule(tokens);
                    <span class="hljs-keyword">return</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'}'</span>) {
                    <span class="hljs-keyword">this</span>.tokenizer.back(tokens.pop());
                    end = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">':'</span>) {
                    colon = <span class="hljs-literal">true</span>;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === brackets[brackets.length - <span class="hljs-number">1</span>]) {
                brackets.pop();
                <span class="hljs-keyword">if</span> (brackets.length === <span class="hljs-number">0</span>) bracket = <span class="hljs-literal">null</span>;
            }
            token = <span class="hljs-keyword">this</span>.tokenizer.nextToken();
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tokenizer.endOfFile()) end = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (brackets.length &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.unclosedBracket(bracket);
        <span class="hljs-keyword">if</span> (end &amp;&amp; colon) {
            <span class="hljs-keyword">if</span> (!customProperty) {
                <span class="hljs-keyword">while</span>(tokens.length){
                    token = tokens[tokens.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
                    <span class="hljs-keyword">if</span> (token !== <span class="hljs-string">'space'</span> &amp;&amp; token !== <span class="hljs-string">'comment'</span>) <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">this</span>.tokenizer.back(tokens.pop());
                }
            }
            <span class="hljs-keyword">this</span>.decl(tokens, customProperty);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.unknownWord(tokens);
        }
    }
    parse() {
        <span class="hljs-keyword">let</span> token;
        <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.tokenizer.endOfFile()){
            token = <span class="hljs-keyword">this</span>.tokenizer.nextToken();
            <span class="hljs-keyword">switch</span>(token[<span class="hljs-number">0</span>]){
                <span class="hljs-keyword">case</span> <span class="hljs-string">'space'</span>:
                    <span class="hljs-keyword">this</span>.spaces += token[<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">';'</span>:
                    <span class="hljs-keyword">this</span>.freeSemicolon(token);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'}'</span>:
                    <span class="hljs-keyword">this</span>.end(token);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'comment'</span>:
                    <span class="hljs-keyword">this</span>.comment(token);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'at-word'</span>:
                    <span class="hljs-keyword">this</span>.atrule(token);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'{'</span>:
                    <span class="hljs-keyword">this</span>.emptyRule(token);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">this</span>.other(token);
                    <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">this</span>.endFile();
    }
    precheckMissedSemicolon() {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-188" id="section-188"></a>
</div>
<p>Hook for Safe Parser</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    }
    raw(node, prop, tokens, customProperty) {
        <span class="hljs-keyword">let</span> token, type;
        <span class="hljs-keyword">let</span> length = tokens.length;
        <span class="hljs-keyword">let</span> value = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">let</span> clean = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">let</span> next, prev;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i += <span class="hljs-number">1</span>){
            token = tokens[i];
            type = token[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'space'</span> &amp;&amp; i === length - <span class="hljs-number">1</span> &amp;&amp; !customProperty) {
                clean = <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'comment'</span>) {
                prev = tokens[i - <span class="hljs-number">1</span>] ? tokens[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] : <span class="hljs-string">'empty'</span>;
                next = tokens[i + <span class="hljs-number">1</span>] ? tokens[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] : <span class="hljs-string">'empty'</span>;
                <span class="hljs-keyword">if</span> (!SAFE_COMMENT_NEIGHBOR[prev] &amp;&amp; !SAFE_COMMENT_NEIGHBOR[next]) {
                    <span class="hljs-keyword">if</span> (value.slice(<span class="hljs-number">-1</span>) === <span class="hljs-string">','</span>) {
                        clean = <span class="hljs-literal">false</span>;
                    } <span class="hljs-keyword">else</span> {
                        value += token[<span class="hljs-number">1</span>];
                    }
                } <span class="hljs-keyword">else</span> {
                    clean = <span class="hljs-literal">false</span>;
                }
            } <span class="hljs-keyword">else</span> {
                value += token[<span class="hljs-number">1</span>];
            }
        }
        <span class="hljs-keyword">if</span> (!clean) {
            <span class="hljs-keyword">let</span> raw = tokens.reduce(<span class="hljs-function">(<span class="hljs-params">all, i</span>)=&gt;</span>all + i[<span class="hljs-number">1</span>], <span class="hljs-string">''</span>);
            node.raws[prop] = {
                raw,
                value
            };
        }
        node[prop] = value;
    }
    rule(tokens) {
        tokens.pop();
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> Rule();
        <span class="hljs-keyword">this</span>.init(node, tokens[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);
        node.raws.between = <span class="hljs-keyword">this</span>.spacesAndCommentsFromEnd(tokens);
        <span class="hljs-keyword">this</span>.raw(node, <span class="hljs-string">'selector'</span>, tokens);
        <span class="hljs-keyword">this</span>.current = node;
    }
    spacesAndCommentsFromEnd(tokens) {
        <span class="hljs-keyword">let</span> lastTokenType;
        <span class="hljs-keyword">let</span> spaces = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">while</span>(tokens.length){
            lastTokenType = tokens[tokens.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (lastTokenType !== <span class="hljs-string">'space'</span> &amp;&amp; lastTokenType !== <span class="hljs-string">'comment'</span>) <span class="hljs-keyword">break</span>;
            spaces = tokens.pop()[<span class="hljs-number">1</span>] + spaces;
        }
        <span class="hljs-keyword">return</span> spaces;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-189" id="section-189"></a>
</div>
<p>Errors</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    spacesAndCommentsFromStart(tokens) {
        <span class="hljs-keyword">let</span> next;
        <span class="hljs-keyword">let</span> spaces = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">while</span>(tokens.length){
            next = tokens[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (next !== <span class="hljs-string">'space'</span> &amp;&amp; next !== <span class="hljs-string">'comment'</span>) <span class="hljs-keyword">break</span>;
            spaces += tokens.shift()[<span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">return</span> spaces;
    }
    spacesFromEnd(tokens) {
        <span class="hljs-keyword">let</span> lastTokenType;
        <span class="hljs-keyword">let</span> spaces = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">while</span>(tokens.length){
            lastTokenType = tokens[tokens.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (lastTokenType !== <span class="hljs-string">'space'</span>) <span class="hljs-keyword">break</span>;
            spaces = tokens.pop()[<span class="hljs-number">1</span>] + spaces;
        }
        <span class="hljs-keyword">return</span> spaces;
    }
    stringFrom(tokens, <span class="hljs-keyword">from</span>) {
        <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-keyword">from</span>; i &lt; tokens.length; i++){
            result += tokens[i][<span class="hljs-number">1</span>];
        }
        tokens.splice(<span class="hljs-keyword">from</span>, tokens.length - <span class="hljs-keyword">from</span>);
        <span class="hljs-keyword">return</span> result;
    }
    unclosedBlock() {
        <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.current.source.start;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.input.error(<span class="hljs-string">'Unclosed block'</span>, pos.line, pos.column);
    }
    unclosedBracket(bracket) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.input.error(<span class="hljs-string">'Unclosed bracket'</span>, {
            <span class="hljs-attr">offset</span>: bracket[<span class="hljs-number">2</span>]
        }, {
            <span class="hljs-attr">offset</span>: bracket[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>
        });
    }
    unexpectedClose(token) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.input.error(<span class="hljs-string">'Unexpected }'</span>, {
            <span class="hljs-attr">offset</span>: token[<span class="hljs-number">2</span>]
        }, {
            <span class="hljs-attr">offset</span>: token[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>
        });
    }
    unknownWord(tokens) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.input.error(<span class="hljs-string">'Unknown word'</span>, {
            <span class="hljs-attr">offset</span>: tokens[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]
        }, {
            <span class="hljs-attr">offset</span>: tokens[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] + tokens[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].length
        });
    }
    unnamedAtrule(node, token) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.input.error(<span class="hljs-string">'At-rule without name'</span>, {
            <span class="hljs-attr">offset</span>: token[<span class="hljs-number">2</span>]
        }, {
            <span class="hljs-attr">offset</span>: token[<span class="hljs-number">2</span>] + token[<span class="hljs-number">1</span>].length
        });
    }
}
<span class="hljs-built_in">module</span>.exports = Parser;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/parse.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Container = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Parser = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/parser.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Input = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/input.js [postcss] (ecmascript)"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">css, opts</span>) </span>{
    <span class="hljs-keyword">let</span> input = <span class="hljs-keyword">new</span> Input(css, opts);
    <span class="hljs-keyword">let</span> parser = <span class="hljs-keyword">new</span> Parser(input);
    <span class="hljs-keyword">try</span> {
        parser.parse();
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time falsy"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//TURBOPACK unreachable</span>
        ;
        <span class="hljs-keyword">throw</span> e;
    }
    <span class="hljs-keyword">return</span> parser.root;
}
<span class="hljs-built_in">module</span>.exports = parse;
parse.default = parse;
Container.registerParse(parse);
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> { isClean, my } = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> MapGenerator = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> stringify = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Container = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Document = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/document.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> warnOnce = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Result = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/result.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> parse = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/parse.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Root = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/root.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">const</span> TYPE_TO_CLASS_NAME = {
    <span class="hljs-attr">atrule</span>: <span class="hljs-string">'AtRule'</span>,
    <span class="hljs-attr">comment</span>: <span class="hljs-string">'Comment'</span>,
    <span class="hljs-attr">decl</span>: <span class="hljs-string">'Declaration'</span>,
    <span class="hljs-attr">document</span>: <span class="hljs-string">'Document'</span>,
    <span class="hljs-attr">root</span>: <span class="hljs-string">'Root'</span>,
    <span class="hljs-attr">rule</span>: <span class="hljs-string">'Rule'</span>
};
<span class="hljs-keyword">const</span> PLUGIN_PROPS = {
    <span class="hljs-attr">AtRule</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">AtRuleExit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">Comment</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">CommentExit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">Declaration</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">DeclarationExit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">Document</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">DocumentExit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">Once</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">OnceExit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">postcssPlugin</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">prepare</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">Root</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">RootExit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">Rule</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">RuleExit</span>: <span class="hljs-literal">true</span>
};
<span class="hljs-keyword">const</span> NOT_VISITORS = {
    <span class="hljs-attr">Once</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">postcssPlugin</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">prepare</span>: <span class="hljs-literal">true</span>
};
<span class="hljs-keyword">const</span> CHILDREN = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPromise</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj.then === <span class="hljs-string">'function'</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEvents</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">let</span> key = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> type = TYPE_TO_CLASS_NAME[node.type];
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'decl'</span>) {
        key = node.prop.toLowerCase();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'atrule'</span>) {
        key = node.name.toLowerCase();
    }
    <span class="hljs-keyword">if</span> (key &amp;&amp; node.append) {
        <span class="hljs-keyword">return</span> [
            type,
            type + <span class="hljs-string">'-'</span> + key,
            CHILDREN,
            type + <span class="hljs-string">'Exit'</span>,
            type + <span class="hljs-string">'Exit-'</span> + key
        ];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key) {
        <span class="hljs-keyword">return</span> [
            type,
            type + <span class="hljs-string">'-'</span> + key,
            type + <span class="hljs-string">'Exit'</span>,
            type + <span class="hljs-string">'Exit-'</span> + key
        ];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.append) {
        <span class="hljs-keyword">return</span> [
            type,
            CHILDREN,
            type + <span class="hljs-string">'Exit'</span>
        ];
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> [
            type,
            type + <span class="hljs-string">'Exit'</span>
        ];
    }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toStack</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">let</span> events;
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'document'</span>) {
        events = [
            <span class="hljs-string">'Document'</span>,
            CHILDREN,
            <span class="hljs-string">'DocumentExit'</span>
        ];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'root'</span>) {
        events = [
            <span class="hljs-string">'Root'</span>,
            CHILDREN,
            <span class="hljs-string">'RootExit'</span>
        ];
    } <span class="hljs-keyword">else</span> {
        events = getEvents(node);
    }
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">eventIndex</span>: <span class="hljs-number">0</span>,
        events,
        <span class="hljs-attr">iterator</span>: <span class="hljs-number">0</span>,
        node,
        <span class="hljs-attr">visitorIndex</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">visitors</span>: []
    };
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanMarks</span>(<span class="hljs-params">node</span>) </span>{
    node[isClean] = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (node.nodes) node.nodes.forEach(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>cleanMarks(i));
    <span class="hljs-keyword">return</span> node;
}
<span class="hljs-keyword">let</span> postcss = {};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyResult</span> </span>{
    <span class="hljs-keyword">constructor</span>(processor, css, opts){
        <span class="hljs-keyword">this</span>.stringified = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.processed = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> root;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> css === <span class="hljs-string">'object'</span> &amp;&amp; css !== <span class="hljs-literal">null</span> &amp;&amp; (css.type === <span class="hljs-string">'root'</span> || css.type === <span class="hljs-string">'document'</span>)) {
            root = cleanMarks(css);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (css <span class="hljs-keyword">instanceof</span> LazyResult || css <span class="hljs-keyword">instanceof</span> Result) {
            root = cleanMarks(css.root);
            <span class="hljs-keyword">if</span> (css.map) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> opts.map === <span class="hljs-string">'undefined'</span>) opts.map = {};
                <span class="hljs-keyword">if</span> (!opts.map.inline) opts.map.inline = <span class="hljs-literal">false</span>;
                opts.map.prev = css.map;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> parser = parse;
            <span class="hljs-keyword">if</span> (opts.syntax) parser = opts.syntax.parse;
            <span class="hljs-keyword">if</span> (opts.parser) parser = opts.parser;
            <span class="hljs-keyword">if</span> (parser.parse) parser = parser.parse;
            <span class="hljs-keyword">try</span> {
                root = parser(css, opts);
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">this</span>.processed = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">this</span>.error = error;
            }
            <span class="hljs-keyword">if</span> (root &amp;&amp; !root[my]) {
                <span class="hljs-comment">/* c8 ignore next 2 */</span> Container.rebuild(root);
            }
        }
        <span class="hljs-keyword">this</span>.result = <span class="hljs-keyword">new</span> Result(processor, root, opts);
        <span class="hljs-keyword">this</span>.helpers = {
            ...postcss,
            postcss,
            <span class="hljs-attr">result</span>: <span class="hljs-keyword">this</span>.result
        };
        <span class="hljs-keyword">this</span>.plugins = <span class="hljs-keyword">this</span>.processor.plugins.map(<span class="hljs-function">(<span class="hljs-params">plugin</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">'object'</span> &amp;&amp; plugin.prepare) {
                <span class="hljs-keyword">return</span> {
                    ...plugin,
                    ...plugin.prepare(<span class="hljs-keyword">this</span>.result)
                };
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> plugin;
            }
        });
    }
    <span class="hljs-keyword">async</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.error) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">this</span>.error);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.processed) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-keyword">this</span>.result);
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.processing) {
            <span class="hljs-keyword">this</span>.processing = <span class="hljs-keyword">this</span>.runAsync();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.processing;
    }
    <span class="hljs-keyword">catch</span>(onRejected) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.async().catch(onRejected);
    }
    <span class="hljs-keyword">finally</span>(onFinally) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.async().then(onFinally, onFinally);
    }
    getAsyncError() {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Use process(css).then(cb) to work with async plugins'</span>);
    }
    handleError(error, node) {
        <span class="hljs-keyword">let</span> plugin = <span class="hljs-keyword">this</span>.result.lastPlugin;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (node) node.addToError(error);
            <span class="hljs-keyword">this</span>.error = error;
            <span class="hljs-keyword">if</span> (error.name === <span class="hljs-string">'CssSyntaxError'</span> &amp;&amp; !error.plugin) {
                error.plugin = plugin.postcssPlugin;
                error.setMessage();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (plugin.postcssVersion) {
                <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time falsy"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//TURBOPACK unreachable</span>
                ;
            }
        } <span class="hljs-keyword">catch</span> (err) {
            <span class="hljs-comment">/* c8 ignore next 3 */</span> <span class="hljs-comment">// eslint-disable-next-line no-console</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> &amp;&amp; <span class="hljs-built_in">console</span>.error) <span class="hljs-built_in">console</span>.error(err);
        }
        <span class="hljs-keyword">return</span> error;
    }
    prepareVisitors() {
        <span class="hljs-keyword">this</span>.listeners = {};
        <span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">plugin, type, cb</span>)=&gt;</span>{
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.listeners[type]) <span class="hljs-keyword">this</span>.listeners[type] = [];
            <span class="hljs-keyword">this</span>.listeners[type].push([
                plugin,
                cb
            ]);
        };
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> plugin <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.plugins){
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">'object'</span>) {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> event <span class="hljs-keyword">in</span> plugin){
                    <span class="hljs-keyword">if</span> (!PLUGIN_PROPS[event] &amp;&amp; <span class="hljs-regexp">/^[A-Z]/</span>.test(event)) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unknown event <span class="hljs-subst">${event}</span> in <span class="hljs-subst">${plugin.postcssPlugin}</span>. `</span> + <span class="hljs-string">`Try to update PostCSS (<span class="hljs-subst">${<span class="hljs-keyword">this</span>.processor.version}</span> now).`</span>);
                    }
                    <span class="hljs-keyword">if</span> (!NOT_VISITORS[event]) {
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin[event] === <span class="hljs-string">'object'</span>) {
                            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> filter <span class="hljs-keyword">in</span> plugin[event]){
                                <span class="hljs-keyword">if</span> (filter === <span class="hljs-string">'*'</span>) {
                                    add(plugin, event, plugin[event][filter]);
                                } <span class="hljs-keyword">else</span> {
                                    add(plugin, event + <span class="hljs-string">'-'</span> + filter.toLowerCase(), plugin[event][filter]);
                                }
                            }
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin[event] === <span class="hljs-string">'function'</span>) {
                            add(plugin, event, plugin[event]);
                        }
                    }
                }
            }
        }
        <span class="hljs-keyword">this</span>.hasListener = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.listeners).length &gt; <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">async</span> runAsync() {
        <span class="hljs-keyword">this</span>.plugin = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.plugins.length; i++){
            <span class="hljs-keyword">let</span> plugin = <span class="hljs-keyword">this</span>.plugins[i];
            <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">this</span>.runOnRoot(plugin);
            <span class="hljs-keyword">if</span> (isPromise(promise)) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">await</span> promise;
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.handleError(error);
                }
            }
        }
        <span class="hljs-keyword">this</span>.prepareVisitors();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasListener) {
            <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">this</span>.result.root;
            <span class="hljs-keyword">while</span>(!root[isClean]){
                root[isClean] = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">let</span> stack = [
                    toStack(root)
                ];
                <span class="hljs-keyword">while</span>(stack.length &gt; <span class="hljs-number">0</span>){
                    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">this</span>.visitTick(stack);
                    <span class="hljs-keyword">if</span> (isPromise(promise)) {
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-keyword">await</span> promise;
                        } <span class="hljs-keyword">catch</span> (e) {
                            <span class="hljs-keyword">let</span> node = stack[stack.length - <span class="hljs-number">1</span>].node;
                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.handleError(e, node);
                        }
                    }
                }
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.listeners.OnceExit) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [plugin, visitor] <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.listeners.OnceExit){
                    <span class="hljs-keyword">this</span>.result.lastPlugin = plugin;
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">if</span> (root.type === <span class="hljs-string">'document'</span>) {
                            <span class="hljs-keyword">let</span> roots = root.nodes.map(<span class="hljs-function">(<span class="hljs-params">subRoot</span>)=&gt;</span>visitor(subRoot, <span class="hljs-keyword">this</span>.helpers));
                            <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(roots);
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-keyword">await</span> visitor(root, <span class="hljs-keyword">this</span>.helpers);
                        }
                    } <span class="hljs-keyword">catch</span> (e) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.handleError(e);
                    }
                }
            }
        }
        <span class="hljs-keyword">this</span>.processed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stringify();
    }
    runOnRoot(plugin) {
        <span class="hljs-keyword">this</span>.result.lastPlugin = plugin;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">'object'</span> &amp;&amp; plugin.Once) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.result.root.type === <span class="hljs-string">'document'</span>) {
                    <span class="hljs-keyword">let</span> roots = <span class="hljs-keyword">this</span>.result.root.nodes.map(<span class="hljs-function">(<span class="hljs-params">root</span>)=&gt;</span>plugin.Once(root, <span class="hljs-keyword">this</span>.helpers));
                    <span class="hljs-keyword">if</span> (isPromise(roots[<span class="hljs-number">0</span>])) {
                        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(roots);
                    }
                    <span class="hljs-keyword">return</span> roots;
                }
                <span class="hljs-keyword">return</span> plugin.Once(<span class="hljs-keyword">this</span>.result.root, <span class="hljs-keyword">this</span>.helpers);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">'function'</span>) {
                <span class="hljs-keyword">return</span> plugin(<span class="hljs-keyword">this</span>.result.root, <span class="hljs-keyword">this</span>.result);
            }
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.handleError(error);
        }
    }
    stringify() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.error) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.error;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stringified) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result;
        <span class="hljs-keyword">this</span>.stringified = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.sync();
        <span class="hljs-keyword">let</span> opts = <span class="hljs-keyword">this</span>.result.opts;
        <span class="hljs-keyword">let</span> str = stringify;
        <span class="hljs-keyword">if</span> (opts.syntax) str = opts.syntax.stringify;
        <span class="hljs-keyword">if</span> (opts.stringifier) str = opts.stringifier;
        <span class="hljs-keyword">if</span> (str.stringify) str = str.stringify;
        <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> MapGenerator(str, <span class="hljs-keyword">this</span>.result.root, <span class="hljs-keyword">this</span>.result.opts);
        <span class="hljs-keyword">let</span> data = map.generate();
        <span class="hljs-keyword">this</span>.result.css = data[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">this</span>.result.map = data[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result;
    }
    sync() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.error) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.error;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.processed) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result;
        <span class="hljs-keyword">this</span>.processed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.processing) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.getAsyncError();
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> plugin <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.plugins){
            <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">this</span>.runOnRoot(plugin);
            <span class="hljs-keyword">if</span> (isPromise(promise)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.getAsyncError();
            }
        }
        <span class="hljs-keyword">this</span>.prepareVisitors();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasListener) {
            <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">this</span>.result.root;
            <span class="hljs-keyword">while</span>(!root[isClean]){
                root[isClean] = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">this</span>.walkSync(root);
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.listeners.OnceExit) {
                <span class="hljs-keyword">if</span> (root.type === <span class="hljs-string">'document'</span>) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> subRoot <span class="hljs-keyword">of</span> root.nodes){
                        <span class="hljs-keyword">this</span>.visitSync(<span class="hljs-keyword">this</span>.listeners.OnceExit, subRoot);
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.visitSync(<span class="hljs-keyword">this</span>.listeners.OnceExit, root);
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result;
    }
    then(onFulfilled, onRejected) {
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time falsy"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//TURBOPACK unreachable</span>
        ;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.async().then(onFulfilled, onRejected);
    }
    toString() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.css;
    }
    visitSync(visitors, node) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [plugin, visitor] <span class="hljs-keyword">of</span> visitors){
            <span class="hljs-keyword">this</span>.result.lastPlugin = plugin;
            <span class="hljs-keyword">let</span> promise;
            <span class="hljs-keyword">try</span> {
                promise = visitor(node, <span class="hljs-keyword">this</span>.helpers);
            } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.handleError(e, node.proxyOf);
            }
            <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'root'</span> &amp;&amp; node.type !== <span class="hljs-string">'document'</span> &amp;&amp; !node.parent) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">if</span> (isPromise(promise)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.getAsyncError();
            }
        }
    }
    visitTick(stack) {
        <span class="hljs-keyword">let</span> visit = stack[stack.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> { node, visitors } = visit;
        <span class="hljs-keyword">if</span> (node.type !== <span class="hljs-string">'root'</span> &amp;&amp; node.type !== <span class="hljs-string">'document'</span> &amp;&amp; !node.parent) {
            stack.pop();
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (visitors.length &gt; <span class="hljs-number">0</span> &amp;&amp; visit.visitorIndex &lt; visitors.length) {
            <span class="hljs-keyword">let</span> [plugin, visitor] = visitors[visit.visitorIndex];
            visit.visitorIndex += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (visit.visitorIndex === visitors.length) {
                visit.visitors = [];
                visit.visitorIndex = <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">this</span>.result.lastPlugin = plugin;
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> visitor(node.toProxy(), <span class="hljs-keyword">this</span>.helpers);
            } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.handleError(e, node);
            }
        }
        <span class="hljs-keyword">if</span> (visit.iterator !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">let</span> iterator = visit.iterator;
            <span class="hljs-keyword">let</span> child;
            <span class="hljs-keyword">while</span>(child = node.nodes[node.indexes[iterator]]){
                node.indexes[iterator] += <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (!child[isClean]) {
                    child[isClean] = <span class="hljs-literal">true</span>;
                    stack.push(toStack(child));
                    <span class="hljs-keyword">return</span>;
                }
            }
            visit.iterator = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">delete</span> node.indexes[iterator];
        }
        <span class="hljs-keyword">let</span> events = visit.events;
        <span class="hljs-keyword">while</span>(visit.eventIndex &lt; events.length){
            <span class="hljs-keyword">let</span> event = events[visit.eventIndex];
            visit.eventIndex += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (event === CHILDREN) {
                <span class="hljs-keyword">if</span> (node.nodes &amp;&amp; node.nodes.length) {
                    node[isClean] = <span class="hljs-literal">true</span>;
                    visit.iterator = node.getIterator();
                }
                <span class="hljs-keyword">return</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.listeners[event]) {
                visit.visitors = <span class="hljs-keyword">this</span>.listeners[event];
                <span class="hljs-keyword">return</span>;
            }
        }
        stack.pop();
    }
    walkSync(node) {
        node[isClean] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">let</span> events = getEvents(node);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> event <span class="hljs-keyword">of</span> events){
            <span class="hljs-keyword">if</span> (event === CHILDREN) {
                <span class="hljs-keyword">if</span> (node.nodes) {
                    node.each(<span class="hljs-function">(<span class="hljs-params">child</span>)=&gt;</span>{
                        <span class="hljs-keyword">if</span> (!child[isClean]) <span class="hljs-keyword">this</span>.walkSync(child);
                    });
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> visitors = <span class="hljs-keyword">this</span>.listeners[event];
                <span class="hljs-keyword">if</span> (visitors) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.visitSync(visitors, node.toProxy())) <span class="hljs-keyword">return</span>;
                }
            }
        }
    }
    warnings() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sync().warnings();
    }
    <span class="hljs-keyword">get</span> content() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stringify().content;
    }
    <span class="hljs-keyword">get</span> css() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stringify().css;
    }
    <span class="hljs-keyword">get</span> map() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stringify().map;
    }
    <span class="hljs-keyword">get</span> messages() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sync().messages;
    }
    <span class="hljs-keyword">get</span> opts() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result.opts;
    }
    <span class="hljs-keyword">get</span> processor() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result.processor;
    }
    <span class="hljs-keyword">get</span> root() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sync().root;
    }
    <span class="hljs-keyword">get</span> [Symbol.toStringTag]() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'LazyResult'</span>;
    }
}
LazyResult.registerPostcss = <span class="hljs-function">(<span class="hljs-params">dependant</span>)=&gt;</span>{
    postcss = dependant;
};
<span class="hljs-built_in">module</span>.exports = LazyResult;
LazyResult.default = LazyResult;
Root.registerLazyResult(LazyResult);
Document.registerLazyResult(LazyResult);
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/no-work-result.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> MapGenerator = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> stringify = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> warnOnce = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> parse = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/parse.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">const</span> Result = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/result.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoWorkResult</span> </span>{
    <span class="hljs-keyword">constructor</span>(processor, css, opts){
        css = css.toString();
        <span class="hljs-keyword">this</span>.stringified = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>._processor = processor;
        <span class="hljs-keyword">this</span>._css = css;
        <span class="hljs-keyword">this</span>._opts = opts;
        <span class="hljs-keyword">this</span>._map = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">let</span> root;
        <span class="hljs-keyword">let</span> str = stringify;
        <span class="hljs-keyword">this</span>.result = <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">this</span>._processor, root, <span class="hljs-keyword">this</span>._opts);
        <span class="hljs-keyword">this</span>.result.css = css;
        <span class="hljs-keyword">let</span> self = <span class="hljs-keyword">this</span>;
        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>.result, <span class="hljs-string">'root'</span>, {
            <span class="hljs-keyword">get</span> () {
                <span class="hljs-keyword">return</span> self.root;
            }
        });
        <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> MapGenerator(str, root, <span class="hljs-keyword">this</span>._opts, css);
        <span class="hljs-keyword">if</span> (map.isMap()) {
            <span class="hljs-keyword">let</span> [generatedCSS, generatedMap] = map.generate();
            <span class="hljs-keyword">if</span> (generatedCSS) {
                <span class="hljs-keyword">this</span>.result.css = generatedCSS;
            }
            <span class="hljs-keyword">if</span> (generatedMap) {
                <span class="hljs-keyword">this</span>.result.map = generatedMap;
            }
        }
    }
    <span class="hljs-keyword">async</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.error) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">this</span>.error);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-keyword">this</span>.result);
    }
    <span class="hljs-keyword">catch</span>(onRejected) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.async().catch(onRejected);
    }
    <span class="hljs-keyword">finally</span>(onFinally) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.async().then(onFinally, onFinally);
    }
    sync() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.error) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.error;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result;
    }
    then(onFulfilled, onRejected) {
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time falsy"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//TURBOPACK unreachable</span>
        ;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.async().then(onFulfilled, onRejected);
    }
    toString() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._css;
    }
    warnings() {
        <span class="hljs-keyword">return</span> [];
    }
    <span class="hljs-keyword">get</span> content() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result.css;
    }
    <span class="hljs-keyword">get</span> css() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result.css;
    }
    <span class="hljs-keyword">get</span> map() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result.map;
    }
    <span class="hljs-keyword">get</span> messages() {
        <span class="hljs-keyword">return</span> [];
    }
    <span class="hljs-keyword">get</span> opts() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result.opts;
    }
    <span class="hljs-keyword">get</span> processor() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.result.processor;
    }
    <span class="hljs-keyword">get</span> root() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._root) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._root;
        }
        <span class="hljs-keyword">let</span> root;
        <span class="hljs-keyword">let</span> parser = parse;
        <span class="hljs-keyword">try</span> {
            root = parser(<span class="hljs-keyword">this</span>._css, <span class="hljs-keyword">this</span>._opts);
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-keyword">this</span>.error = error;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.error) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.error;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._root = root;
            <span class="hljs-keyword">return</span> root;
        }
    }
    <span class="hljs-keyword">get</span> [Symbol.toStringTag]() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'NoWorkResult'</span>;
    }
}
<span class="hljs-built_in">module</span>.exports = NoWorkResult;
NoWorkResult.default = NoWorkResult;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/processor.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> NoWorkResult = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/no-work-result.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> LazyResult = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Document = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/document.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Root = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/root.js [postcss] (ecmascript)"</span>);
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Processor</span> </span>{
    <span class="hljs-keyword">constructor</span>(plugins = []){
        <span class="hljs-keyword">this</span>.version = <span class="hljs-string">'8.4.31'</span>;
        <span class="hljs-keyword">this</span>.plugins = <span class="hljs-keyword">this</span>.normalize(plugins);
    }
    normalize(plugins) {
        <span class="hljs-keyword">let</span> normalized = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> plugins){
            <span class="hljs-keyword">if</span> (i.postcss === <span class="hljs-literal">true</span>) {
                i = i();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i.postcss) {
                i = i.postcss;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(i.plugins)) {
                normalized = normalized.concat(i.plugins);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i === <span class="hljs-string">'object'</span> &amp;&amp; i.postcssPlugin) {
                normalized.push(i);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i === <span class="hljs-string">'function'</span>) {
                normalized.push(i);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> i === <span class="hljs-string">'object'</span> &amp;&amp; (i.parse || i.stringify)) {
                <span class="hljs-keyword">if</span> (<span class="hljs-string">"TURBOPACK compile-time falsy"</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//TURBOPACK unreachable</span>
                ;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(i + <span class="hljs-string">' is not a PostCSS plugin'</span>);
            }
        }
        <span class="hljs-keyword">return</span> normalized;
    }
    process(css, opts = {}) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.plugins.length === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">typeof</span> opts.parser === <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> opts.stringifier === <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> opts.syntax === <span class="hljs-string">'undefined'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NoWorkResult(<span class="hljs-keyword">this</span>, css, opts);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LazyResult(<span class="hljs-keyword">this</span>, css, opts);
        }
    }
    use(plugin) {
        <span class="hljs-keyword">this</span>.plugins = <span class="hljs-keyword">this</span>.plugins.concat(<span class="hljs-keyword">this</span>.normalize([
            plugin
        ]));
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
}
<span class="hljs-built_in">module</span>.exports = Processor;
Processor.default = Processor;
Root.registerProcessor(Processor);
Document.registerProcessor(Processor);
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/fromJSON.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> Declaration = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> PreviousMap = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Comment = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/comment.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> AtRule = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Input = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/input.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Root = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/root.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Rule = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/rule.js [postcss] (ecmascript)"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromJSON</span>(<span class="hljs-params">json, inputs</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(json)) <span class="hljs-keyword">return</span> json.map(<span class="hljs-function">(<span class="hljs-params">n</span>)=&gt;</span>fromJSON(n));
    <span class="hljs-keyword">let</span> { <span class="hljs-attr">inputs</span>: ownInputs, ...defaults } = json;
    <span class="hljs-keyword">if</span> (ownInputs) {
        inputs = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> input <span class="hljs-keyword">of</span> ownInputs){
            <span class="hljs-keyword">let</span> inputHydrated = {
                ...input,
                <span class="hljs-attr">__proto__</span>: Input.prototype
            };
            <span class="hljs-keyword">if</span> (inputHydrated.map) {
                inputHydrated.map = {
                    ...inputHydrated.map,
                    <span class="hljs-attr">__proto__</span>: PreviousMap.prototype
                };
            }
            inputs.push(inputHydrated);
        }
    }
    <span class="hljs-keyword">if</span> (defaults.nodes) {
        defaults.nodes = json.nodes.map(<span class="hljs-function">(<span class="hljs-params">n</span>)=&gt;</span>fromJSON(n, inputs));
    }
    <span class="hljs-keyword">if</span> (defaults.source) {
        <span class="hljs-keyword">let</span> { inputId, ...source } = defaults.source;
        defaults.source = source;
        <span class="hljs-keyword">if</span> (inputId != <span class="hljs-literal">null</span>) {
            defaults.source.input = inputs[inputId];
        }
    }
    <span class="hljs-keyword">if</span> (defaults.type === <span class="hljs-string">'root'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Root(defaults);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defaults.type === <span class="hljs-string">'decl'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Declaration(defaults);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defaults.type === <span class="hljs-string">'rule'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rule(defaults);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defaults.type === <span class="hljs-string">'comment'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Comment(defaults);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defaults.type === <span class="hljs-string">'atrule'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AtRule(defaults);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unknown node type: '</span> + json.type);
    }
}
<span class="hljs-built_in">module</span>.exports = fromJSON;
fromJSON.default = fromJSON;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/postcss.js [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__, <span class="hljs-built_in">module</span>, exports</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">let</span> CssSyntaxError = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Declaration = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> LazyResult = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Container = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/container.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Processor = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/processor.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> stringify = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> fromJSON = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/fromJSON.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Document = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/document.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Warning = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/warning.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Comment = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/comment.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> AtRule = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Result = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/result.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Input = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/input.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> parse = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/parse.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> list = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/list.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Rule = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/rule.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Root = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/root.js [postcss] (ecmascript)"</span>);
<span class="hljs-keyword">let</span> Node = __turbopack_context__.r(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/node.js [postcss] (ecmascript)"</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postcss</span>(<span class="hljs-params">...plugins</span>) </span>{
    <span class="hljs-keyword">if</span> (plugins.length === <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(plugins[<span class="hljs-number">0</span>])) {
        plugins = plugins[<span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Processor(plugins);
}
postcss.plugin = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plugin</span>(<span class="hljs-params">name, initializer</span>) </span>{
    <span class="hljs-keyword">let</span> warningPrinted = <span class="hljs-literal">false</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creator</span>(<span class="hljs-params">...args</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-190" id="section-190"></a>
</div>
<p>eslint-disable-next-line no-console</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> &amp;&amp; <span class="hljs-built_in">console</span>.warn &amp;&amp; !warningPrinted) {
            warningPrinted = <span class="hljs-literal">true</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-191" id="section-191"></a>
</div>
<p>eslint-disable-next-line no-console</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-built_in">console</span>.warn(name + <span class="hljs-string">': postcss.plugin was deprecated. Migration guide:\n'</span> + <span class="hljs-string">'https://evilmartians.com/chronicles/postcss-8-plugin-migration'</span>);
            <span class="hljs-keyword">if</span> (process.env.LANG &amp;&amp; process.env.LANG.startsWith(<span class="hljs-string">'cn'</span>)) {
                <span class="hljs-comment">/* c8 ignore next 7 */</span> <span class="hljs-comment">// eslint-disable-next-line no-console</span>
                <span class="hljs-built_in">console</span>.warn(name + <span class="hljs-string">':  postcss.plugin . :\n'</span> + <span class="hljs-string">'https://www.w3ctech.com/topic/2226'</span>);
            }
        }
        <span class="hljs-keyword">let</span> transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = <span class="hljs-keyword">new</span> Processor().version;
        <span class="hljs-keyword">return</span> transformer;
    }
    <span class="hljs-keyword">let</span> cache;
    <span class="hljs-built_in">Object</span>.defineProperty(creator, <span class="hljs-string">'postcss'</span>, {
        <span class="hljs-keyword">get</span> () {
            <span class="hljs-keyword">if</span> (!cache) cache = creator();
            <span class="hljs-keyword">return</span> cache;
        }
    });
    creator.process = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">css, processOpts, pluginOpts</span>) </span>{
        <span class="hljs-keyword">return</span> postcss([
            creator(pluginOpts)
        ]).process(css, processOpts);
    };
    <span class="hljs-keyword">return</span> creator;
};
postcss.stringify = stringify;
postcss.parse = parse;
postcss.fromJSON = fromJSON;
postcss.list = list;
postcss.comment = <span class="hljs-function">(<span class="hljs-params">defaults</span>)=&gt;</span><span class="hljs-keyword">new</span> Comment(defaults);
postcss.atRule = <span class="hljs-function">(<span class="hljs-params">defaults</span>)=&gt;</span><span class="hljs-keyword">new</span> AtRule(defaults);
postcss.decl = <span class="hljs-function">(<span class="hljs-params">defaults</span>)=&gt;</span><span class="hljs-keyword">new</span> Declaration(defaults);
postcss.rule = <span class="hljs-function">(<span class="hljs-params">defaults</span>)=&gt;</span><span class="hljs-keyword">new</span> Rule(defaults);
postcss.root = <span class="hljs-function">(<span class="hljs-params">defaults</span>)=&gt;</span><span class="hljs-keyword">new</span> Root(defaults);
postcss.document = <span class="hljs-function">(<span class="hljs-params">defaults</span>)=&gt;</span><span class="hljs-keyword">new</span> Document(defaults);
postcss.CssSyntaxError = CssSyntaxError;
postcss.Declaration = Declaration;
postcss.Container = Container;
postcss.Processor = Processor;
postcss.Document = Document;
postcss.Comment = Comment;
postcss.Warning = Warning;
postcss.AtRule = AtRule;
postcss.Result = Result;
postcss.Input = Input;
postcss.Rule = Rule;
postcss.Root = Root;
postcss.Node = Node;
LazyResult.registerPostcss(postcss);
<span class="hljs-built_in">module</span>.exports = postcss;
postcss.default = postcss;
}),
<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/postcss.mjs [postcss] (ecmascript)"</span>, (<span class="hljs-function">(<span class="hljs-params">__turbopack_context__</span>) =&gt;</span> {
<span class="hljs-meta">"use strict"</span>;

__turbopack_context__.s([
    <span class="hljs-string">"AtRule"</span>,
    ()=&gt;AtRule,
    <span class="hljs-string">"Comment"</span>,
    ()=&gt;Comment,
    <span class="hljs-string">"Container"</span>,
    ()=&gt;Container,
    <span class="hljs-string">"CssSyntaxError"</span>,
    ()=&gt;CssSyntaxError,
    <span class="hljs-string">"Declaration"</span>,
    ()=&gt;Declaration,
    <span class="hljs-string">"Document"</span>,
    ()=&gt;Document,
    <span class="hljs-string">"Input"</span>,
    ()=&gt;Input,
    <span class="hljs-string">"Node"</span>,
    ()=&gt;Node,
    <span class="hljs-string">"Processor"</span>,
    ()=&gt;Processor,
    <span class="hljs-string">"Result"</span>,
    ()=&gt;Result,
    <span class="hljs-string">"Root"</span>,
    ()=&gt;Root,
    <span class="hljs-string">"Rule"</span>,
    ()=&gt;Rule,
    <span class="hljs-string">"Warning"</span>,
    ()=&gt;Warning,
    <span class="hljs-string">"atRule"</span>,
    ()=&gt;atRule,
    <span class="hljs-string">"comment"</span>,
    ()=&gt;comment,
    <span class="hljs-string">"decl"</span>,
    ()=&gt;decl,
    <span class="hljs-string">"default"</span>,
    ()=&gt;__TURBOPACK__default__export__,
    <span class="hljs-string">"document"</span>,
    ()=&gt;<span class="hljs-built_in">document</span>,
    <span class="hljs-string">"fromJSON"</span>,
    ()=&gt;fromJSON,
    <span class="hljs-string">"list"</span>,
    ()=&gt;list,
    <span class="hljs-string">"parse"</span>,
    ()=&gt;parse,
    <span class="hljs-string">"plugin"</span>,
    ()=&gt;plugin,
    <span class="hljs-string">"root"</span>,
    ()=&gt;root,
    <span class="hljs-string">"rule"</span>,
    ()=&gt;rule,
    <span class="hljs-string">"stringify"</span>,
    ()=&gt;stringify
]);
<span class="hljs-keyword">var</span> __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__ = __turbopack_context__.i(<span class="hljs-string">"[project]/node_modules/.pnpm/postcss@8.4.31/node_modules/postcss/lib/postcss.js [postcss] (ecmascript)"</span>);
;
<span class="hljs-keyword">const</span> __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>];
<span class="hljs-keyword">const</span> stringify = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].stringify;
<span class="hljs-keyword">const</span> fromJSON = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].fromJSON;
<span class="hljs-keyword">const</span> plugin = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].plugin;
<span class="hljs-keyword">const</span> parse = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].parse;
<span class="hljs-keyword">const</span> list = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].list;
<span class="hljs-keyword">const</span> <span class="hljs-built_in">document</span> = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].document;
<span class="hljs-keyword">const</span> comment = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].comment;
<span class="hljs-keyword">const</span> atRule = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].atRule;
<span class="hljs-keyword">const</span> rule = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].rule;
<span class="hljs-keyword">const</span> decl = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].decl;
<span class="hljs-keyword">const</span> root = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].root;
<span class="hljs-keyword">const</span> CssSyntaxError = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].CssSyntaxError;
<span class="hljs-keyword">const</span> Declaration = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Declaration;
<span class="hljs-keyword">const</span> Container = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Container;
<span class="hljs-keyword">const</span> Processor = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Processor;
<span class="hljs-keyword">const</span> Document = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Document;
<span class="hljs-keyword">const</span> Comment = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Comment;
<span class="hljs-keyword">const</span> Warning = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Warning;
<span class="hljs-keyword">const</span> AtRule = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].AtRule;
<span class="hljs-keyword">const</span> Result = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Result;
<span class="hljs-keyword">const</span> Input = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Input;
<span class="hljs-keyword">const</span> Rule = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Rule;
<span class="hljs-keyword">const</span> Root = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Root;
<span class="hljs-keyword">const</span> Node = __TURBOPACK__imported__module__$<span class="hljs-number">5</span>b$project$<span class="hljs-number">5</span>d2f$node_modules$<span class="hljs-number">2</span>f2e$pnpm$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">40</span>$<span class="hljs-number">8</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">4</span>$<span class="hljs-number">2</span>e$<span class="hljs-number">31</span>$<span class="hljs-number">2</span>f$node_modules$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>f$lib$<span class="hljs-number">2</span>f$postcss$<span class="hljs-number">2</span>e$js__$<span class="hljs-number">5</span>b$postcss$<span class="hljs-number">5</span>d$__$<span class="hljs-number">28</span>$ecmascript$<span class="hljs-number">29</span>$__[<span class="hljs-string">"default"</span>].Node;
}),
];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="sourcemappingurlnode_modules__pnpm_56ec7204._.js.map">
  <h1>
    <a href="#sourcemappingurlnode_modules__pnpm_56ec7204._.js.map" name="sourcemappingurlnode_modules__pnpm_56ec7204._.js.map" class="pilcrow"></a>
sourceMappingURL=node_modules__pnpm_56ec7204._.js.map
  </h1>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"></pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
